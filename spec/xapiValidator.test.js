(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.xapiValidator = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch(e) {
      this.stack = e.stack;
    }
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],2:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":2,"ieee754":37,"isarray":38}],4:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":5}],5:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '3.5.0';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":6,"./chai/config":7,"./chai/core/assertions":8,"./chai/interface/assert":9,"./chai/interface/expect":10,"./chai/interface/should":11,"./chai/utils":25,"assertion-error":1}],6:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":7}],7:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],8:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'which', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    _.expectTypes(this, ['array', 'object', 'string']);

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;

    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = (obj != undefined) && ~obj.indexOf(val);
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everything').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isDeep = !!flag(this, 'deep')
      , descriptor = isDeep ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate && arguments.length > 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @namespace BDD
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true
      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';

    switch (_.type(keys)) {
      case "array":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        break;
      case "object":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all');

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length > 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, 'negate') && !flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name;
      if (!name || (name === 'Error' && constructor !== Error)) {
        name = constructor.name || (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'error' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo or approximately must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo);

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });

  /**
   * ### .oneOf(list)
   *
   * Assert that a value appears somewhere in the top level of array `list`.
   *
   *     expect('a').to.be.oneOf(['a', 'b', 'c']);
   *     expect(9).to.not.be.oneOf(['z']);
   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
   *
   *     var three = [3];
   *     // for object-types, contents are not compared
   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
   *     // comparing references works
   *     expect(three).to.be.oneOf([1, 2, three]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object');
    new Assertion(list).to.be.an('array');

    this.assert(
        list.indexOf(expected) > -1
      , 'expected #{this} to be one of #{exp}'
      , 'expected #{this} to not be one of #{exp}'
      , list
      , expected
    );
  }

  Assertion.addMethod('oneOf', oneOf);


  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangeFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , 'expected .' + prop + ' to change'
      , 'expected .' + prop + ' to not change'
    );
  }

  Assertion.addChainableMethod('change', assertChanges);
  Assertion.addChainableMethod('changes', assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial > 0
      , 'expected .' + prop + ' to increase'
      , 'expected .' + prop + ' to not increase'
    );
  }

  Assertion.addChainableMethod('increase', assertIncreases);
  Assertion.addChainableMethod('increases', assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial < 0
      , 'expected .' + prop + ' to decrease'
      , 'expected .' + prop + ' to not decrease'
    );
  }

  Assertion.addChainableMethod('decrease', assertDecreases);
  Assertion.addChainableMethod('decreases', assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isExtensible;

    try {
      isExtensible = Object.isExtensible(obj);
    } catch (err) {
      if (err instanceof TypeError) isExtensible = false;
      else throw err;
    }

    this.assert(
      isExtensible
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isSealed;

    try {
      isSealed = Object.isSealed(obj);
    } catch (err) {
      if (err instanceof TypeError) isSealed = true;
      else throw err;
    }

    this.assert(
      isSealed
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isFrozen;

    try {
      isFrozen = Object.isFrozen(obj);
    } catch (err) {
      if (err instanceof TypeError) isFrozen = true;
      else throw err;
    }

    this.assert(
      isFrozen
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });
};

},{}],9:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg).to.be.above(abv);
  };

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg).to.be.least(atlst);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg).to.be.below(blw);
  };

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg).to.be.most(atmst);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg).to.not.equal(true);
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg).to.not.equal(false);
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg).not.to.be.NaN;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.throws = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(ok, msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.approximately(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.deep.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` - using deep equality checking.
   * Order is not taken into account.
   * Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.deep.members(subset);
  }

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg).to.be.oneOf(list);
  }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changes = function (fn, obj, prop) {
    new Assertion(fn).to.change(obj, prop);
  }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop) {
    new Assertion(fn).to.not.change(obj, prop);
  }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increases = function (fn, obj, prop) {
    new Assertion(fn).to.increase(obj, prop);
  }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.increase(obj, prop);
  }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreases = function (fn, obj, prop) {
    new Assertion(fn).to.decrease(obj, prop);
  }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.decrease(obj, prop);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.frozen;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen');
};

},{}],10:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Expect
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};

},{}],11:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace Should
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],12:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":7,"./flag":16,"./transferFlags":32}],13:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":7,"./flag":16}],14:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');
var flag = require('./flag');

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function addProperty() {
        var old_ssfi = flag(this, 'ssfi');
        if (old_ssfi && config.includeStack === false)
          flag(this, 'ssfi', addProperty);

        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{"../config":7,"./flag":16}],15:[function(require,module,exports){
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var AssertionError = require('assertion-error');
var flag = require('./flag');
var type = require('type-detect');

module.exports = function (obj, types) {
  var obj = flag(obj, 'object');
  types = types.map(function (t) { return t.toLowerCase(); });
  types.sort();

  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'
  var str = types.map(function (t, index) {
    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');

  if (!types.some(function (expected) { return type(obj) === expected; })) {
    throw new AssertionError(
      'object tested must be ' + str + ', but ' + type(obj) + ' given'
    );
  }
};

},{"./flag":16,"assertion-error":1,"type-detect":39}],16:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],17:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],18:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],19:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val); })
    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":16,"./getActual":17,"./inspect":26,"./objDisplay":27}],20:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 * @namespace Utils
 * @name getName
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],21:[function(require,module,exports){
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var hasProperty = require('./hasProperty');

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

module.exports = function getPathInfo(path, obj) {
  var parsed = parsePath(path),
      last = parsed[parsed.length - 1];

  var info = {
    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: _getPathValue(parsed, obj)
  };
  info.exists = hasProperty(info.name, info.parent);

  return info;
};


/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/([^\\])\[/g, '$1.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /^\[(\d+)\]$/
      , mArr = re.exec(value);
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
  });
}


/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj, index) {
  var tmp = obj
    , res;

  index = (index === undefined ? parsed.length : index);

  for (var i = 0, l = index; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
}

},{"./hasProperty":24}],22:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

var getPathInfo = require('./getPathInfo');

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */
module.exports = function(path, obj) {
  var info = getPathInfo(path, obj);
  return info.value;
};

},{"./getPathInfo":21}],23:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],24:[function(require,module,exports){
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var type = require('type-detect');

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

var literals = {
    'number': Number
  , 'string': String
};

module.exports = function hasProperty(name, obj) {
  var ot = type(obj);

  // Bad Object, obviously no props at all
  if(ot === 'null' || ot === 'undefined')
    return false;

  // The `in` operator does not work with certain literals
  // box these before the check
  if(literals[ot] && typeof obj !== 'object')
    obj = new literals[ot](obj);

  return name in obj;
};

},{"type-detect":39}],25:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('type-detect');

/*!
 * expectTypes utility
 */
exports.expectTypes = require('./expectTypes');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Deep path info
 */

exports.getPathInfo = require('./getPathInfo');

/*!
 * Check if a property exists
 */

exports.hasProperty = require('./hasProperty');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');

},{"./addChainableMethod":12,"./addMethod":13,"./addProperty":14,"./expectTypes":15,"./flag":16,"./getActual":17,"./getMessage":19,"./getName":20,"./getPathInfo":21,"./getPathValue":22,"./hasProperty":24,"./inspect":26,"./objDisplay":27,"./overwriteChainableMethod":28,"./overwriteMethod":29,"./overwriteProperty":30,"./test":31,"./transferFlags":32,"deep-eql":33,"type-detect":39}],26:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":18,"./getName":20,"./getProperties":23}],27:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":7,"./inspect":26}],28:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],29:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],30:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],31:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":16}],32:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],33:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":34}],34:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":3,"type-detect":35}],35:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":36}],36:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],37:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],38:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],39:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./lib/type":40,"dup":35}],40:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let "new String('')" return 'object'
  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
  // PhantomJS has type "DOMWindow" for null
  if (obj === null) return 'null';
  // PhantomJS has type "DOMWindow" for undefined
  if (obj === undefined) return 'undefined';
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],41:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var xapiErrorLevels = Object.freeze({
  MAY_VIOLATION: 'MAY_VIOLATION',
  MUST_VIOLATION: 'MUST_VIOLATION',
  SHOULD_VIOLATION: 'SHOULD_VIOLATION'
});

var xapiValidationErrors = Object.freeze({
  ACTIVITIES_MUST_NOT_BE_NULL_MAP_OBJECTS: 'Activities must be non-null map objects',
  ACTOR_MUST_BE_PROVIDED: 'Actor must be provided.',
  AGENT_IFI_PROPERTIES_MUST_BE_SPECIFIED: 'Exactly one Inverse Functional Identifier property must be specified for an "agent".',
  AGENT_MUST_BE_NON_NULL_MAP_OBJECT: '"agent" must be a non-null map object',
  AGENT_MUST_NOT_HAVE_GROUP_CHARACTERISTICS: 'Invalid object with characteristics of a Group when an Agent was expected.',
  ATTACHMENTS_MUST_BE_NOT_NULL_ARRAY: '"attachments" must be a non-null Array.',
  ATTACHMENTS_MUST_NOT_BE_NULL_MAP_OBJECTS: '"attachment" instances must be non-null map objects.',
  AUTHORITY_MUST_BE_NON_NULL_MAP_OBJECT: 'If present, the "authority" property must be a non-null map object.',
  CONTEXT_ACTIVITIES_MUST_BE_ARRAY_OR_ACTIVITY_OBJ: 'Context Activities property values must be an array of Activity Objects or a single Activity Object.',
  CONTEXT_ACTIVITIES_MUST_BE_NON_NULL_MAP_OBJECT: 'The Context Activities instances must be a non-null map object.',
  CONTEXT_ACTIVITIES_MUST_NOT_BE_NULL: '"Context Activities" property values must not be null.',
  CONTEXT_ACTIVITIES_SHOULD_BE_AN_ARRAY: 'Context Activities property values should prefer to be an array of Activities rather than a single Activity object.',
  CONTEXT_MUST_BE_NON_NUL_MAP_OBJECT: 'If present, the "context" property must be a non-null map object.',
  CORRECT_RESPONSES_PATTERN_MUST_BE_ARRAY: 'If present, the "correctResponsesPattern" value must be an Array of strings.',
  CORRECT_RESPONSES_PATTERN_MUST_BE_STRINGS: '"correctResponsesPattern" items must be strings.',
  DATE_MUST_BE_VALID: 'This propertys string value must be conformant to ISO 8601 for Date Times.',
  DATE_SHOULD_INCLUDE_ZONE_INFORMATION: 'ISO 8601 date time strings used in the xAPI should include time zone information.',
  DEFINITIONS_MUST_BE_OBJECTS: '"definitions", when present, must be map objects',
  DISPLAY_SHOULD_BE_PROVIDED: '"display" property should be provided.',
  DURATION_MUST_BE_VALID: 'If present, the "duration" property value must be an ISO 8601 duration',
  EXTENSIONS_MUST_NOT_BE_NULL: 'If present, the extensions property must be a non-null map object.',
  GROUP_AUTHORITY_AGENT_MEMBERS_MUST_BE_TWO: 'If used as a Group, the "authority" property must contain a "member" property that is an array containing exactly two Agent objects.',
  GROUP_IFI_PROPERTIES_MUST_BE_SPECIFIED: 'Exactly one Inverse Functional Identifier property must be specified for a "group".',
  GROUP_MEMBER_MUST_BE_ARRAY: 'If present, the member property of a Group must be an Array',
  GROUP_MUST_BE_NON_NULL_MAP_OBJECT: '"group" must be a non-null map object',
  ID_MUST_BE_UNIQUE: '"id" properties must be unique within each interaction component array',
  ID_MUST_BE_VALID_UUID_REF: '"id" property value must be a valid UUID string for statement reference objects.',
  ID_MUST_BE_VALID: 'Id was not a valid UUID',
  ID_SHOULD_NOT_CONTAIN_WHITESPACES: '"id" properties on interaction components should not contain whitespace',
  IDS_SHOULD_BE_GENERATED_BY_LRS: 'Ids should be generated by the Activity Provider, and must be generated by the LRS',
  IFI_MUST_BE_MBOX_URI: '"mbox" property was required to be a mailto URI string but was not a string at all.',
  IFI_MUST_BE_VALID_MBOX_FORMAT: '"mbox" property was required to be a mailto URI string but did not match the mailto format.',
  INTERACTION_ACTIVITY_SHOULD_HAVE: 'Interaction Activity Definitions should have a type property of',
  INTERACTION_COMPONENT_MUST_NOT_BE_NULL: 'This interaction component collection member must be a non-null map object',
  INTERACTION_COMPONENT_SHOULD_BE_ARRAY: 'This interaction component collection property should be an array.',
  INTERACTION_TYPE_MUST_BE_CMI: 'If present, the "interactionType" value must be a CMI interaction type option.',
  INTERACTION_TYPE_MUST_BE_VALID: 'This interaction component collection property is not associated with the present interactionType of: ',
  INVALID_JSON: 'Invalid JSON. The statement could not be parsed.',
  LANGUAGE_MAP_KEY_INVALID: 'key, Language does not conform to RFC 5646',
  LANGUAGE_MAP_KEY_MUST_BE_STRING: 'key: Language Map value should be a String, but was not',
  LANGUAGE_MAPS_MUST_NOT_BE_NULL: 'Language Maps, when present, must be non-null map objects',
  LANGUAGE_MUST_BE_STRING: 'The language property must be encoded as an RFC 5646 compliant string, but was not.',
  LENGTH_MUST_BE_INTEGER: '"length" property must be provided with an integer value',
  MAX_MUST_BE_GREATER_THAN_MIN: 'If both "max" and "min" are present, the max property value should be greater than min',
  MEMBER_MUST_BE_PROVIDED_FOR_ANONYMOUS_GROUPS: '"member" property must be provided for Anonymous Groups.',
  MUST_BE_BOOLEAN_PRESENT: 'property was required to be a Boolean but was absent.',
  MUST_BE_BOOLEAN: 'property, if present, must be a Boolean.',
  MUST_BE_IRI_STRING: 'property, if present, should be a IRI-like absolute URI per RFC 3987.',
  MUST_BE_NUMBER_PRESENT: 'property was required to be a Number but was absent.',
  MUST_BE_NUMBER: 'property, if present, must be a Number.',
  MUST_BE_PRESENT: 'property was required to be a string but was absent.',
  MUST_BE_STRING: 'property, if present, must be a string.',
  MUST_BE_URI_PRESENT: 'property was required to be a URI string but was absent.',
  MUST_BE_URI_STRING: 'property, if present, must be a URI string.',
  OBJECT_MUST_BE_DEFINED: '"object" property must be provided.',
  OBJECT_MUST_BE_NON_NULL_MAP_OBJECT: '"object" property must be a non-null map object.',
  OBJECT_TYPE_MUST_BE_STATEMENT_REF: '"objectType" property value must be "StatementRef" for statement reference objects.',
  OBJECT_TYPE_MUST_BE_VALID_OPTION: 'object\'s "objectType" did not match a valid option',
  RAW_MUST_BE_GREATER_THAN_MIN: 'If both "raw" and "min" are present, the raw property value should be greater than min',
  RAW_MUST_BE_LESS_THAN_MAX: 'If both "raw" and "max" are present, the raw property value should be less than max',
  REGISTRATION_MUST_BE_UUID_STRING: 'If present, the registration property must be a UUID string.',
  RESULT_MUST_BE_MAP_OBJECT: 'If present, the result must be a map object',
  REVISION_MUST_BE_AGENT_OR_GROUP: 'The revision property must not be used if the Statement\'s Object is an Agent or Group.',
  SCALED_MUST_BE_BETWEEN_0_1: 'If present, the scaled property value must be between 0 and 1',
  SHA2_MUST_BE_PROVIDED_ON_ATTACHMENT_OBJECTS: '"sha2" property must be provided on attachment objects',
  SHA2_MUST_CONTAIN_BASE_64_STRING: '"sha2" property must contain a string with base64 contents',
  STATEMENT_ARGUMENT_IS_NOT_VALID: 'Statement argument provided was not a valid object or a valid JSON string.',
  STATEMENT_ARGUMENT_MUST_BE_PROVIDED: 'No statement argument provided.',
  STATEMENT_MUST_BE_PARSED_CORRECTLY: 'Null or non-object statement value parsed from provided statment JSON.',
  STATEMENT_MUST_NOT_BE_NULL: 'Null statement argument provided.',
  STATEMENT_REF_MUST_NOT_BE_NULL_MAP_OBJECTS: 'StatementRef instances must be non-null map objects',
  SUB_STATEMENT_MUST_NOT_CONTAIN_SUB_STATEMENT: 'A SubStatement must not contain a SubStatement',
  UNEXPECTED: 'Unexpected property not permitted',
  VERB_MUST_BE_PROVIDED: 'Verb must be provided',
  VERB_MUST_NOT_BE_NULL: 'Verb property value must a non-null map object.',
  VERSION_MUST_COMPLY_SEMANTIC_VERSIONING: '"version" must be a non-null string that complies with Semantic Versioning 1.0.0'
});

exports.xapiErrorLevels = xapiErrorLevels;
exports.xapiValidationErrors = xapiValidationErrors;

},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var xapiGeneral = Object.freeze({
  FIRST_REPORT_VERSTION: '1.0.0',
  GROUP_AUTHORITY_AGENT_MEMBERS: 2,
  INTERACTION_DEFINITION_TYPE: 'http://adlnet.gov/expapi/activities/cmi.interaction',
  MAX_SCALED_VALUE: 1,
  MIN_SCALED_VALUE: 0,
  NO_INDEX_FOUND: -1,
  NUMER_OF_SPECIFIED_IFI_PROPERTIES: 1
});

exports.xapiGeneral = xapiGeneral;

},{}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var interactionTypes = exports.interactionTypes = Object.freeze({
  CHOICE: 'choice',
  FILL_IN: 'fill-in',
  LIKERT: 'likert',
  LONG_FILL_IN: 'long-fill-in',
  MATCHING: 'matching',
  NUMERIC: 'numeric',
  OTHER: 'other',
  PERFORMANCE: 'performance',
  SEQUENCING: 'sequencing',
  TRUE_FALSE: 'true-false'
});

var xapiValidationInteractionTypes = exports.xapiValidationInteractionTypes = Object.freeze([interactionTypes.CHOICE, interactionTypes.FILL_IN, interactionTypes.LIKERT, interactionTypes.LONG_FILL_IN, interactionTypes.MATCHING, interactionTypes.NUMERIC, interactionTypes.OTHER, interactionTypes.PERFORMANCE, interactionTypes.SEQUENCING, interactionTypes.TRUE_FALSE]);

},{}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var properties = Object.freeze({
  ACCOUNT: 'account',
  ACTIVITY: 'activity',
  ACTOR: 'actor',
  AGENT: 'agent',
  ATTACHMENT: 'attachment',
  ATTACHMENTS: 'attachments',
  AUTHORITY: 'authority',
  CATEGORY: 'category',
  CHOICE: 'choice',
  CHOICES: 'choices',
  COMPLETION: 'completion',
  CONTENT_TYPE: 'contentType',
  CONTEXT_ACTIVITIES: 'contextActivities',
  CONTEXT: 'context',
  CORRECT_RESPONSES_PATTERN: 'correctResponsesPattern',
  DATE_TIME: 'dateTime',
  DEFINITION: 'definition',
  DESCRIPTION: 'description',
  DISPLAY: 'display',
  DURATION: 'duration',
  EXTENSIONS: 'extensions',
  FILE_URL: 'fileUrl',
  GROUP: 'group',
  GROUPING: 'grouping',
  HOME_PAGE: 'homePage',
  ID: 'id',
  INSTRUCTOR: 'instructor',
  INTERACTION_COMPONENTS: 'interactionComponents',
  INTERACTION_TYPE: 'interactionType',
  LANGUAGE_MAP: 'languageMap',
  LANGUAGE: 'language',
  LENGTH: 'length',
  LIKERT: 'likert',
  MATCHING: 'matching',
  MAX: 'max',
  MBOX_SHA_1_SUM: 'mbox_sha1sum',
  MBOX: 'mbox',
  MEMBER: 'member',
  MIN: 'min',
  MORE_INFO: 'moreInfo',
  NAME: 'name',
  OBJECT_TYPE: 'objectType',
  OBJECT: 'object',
  OPEN_ID: 'openID',
  OTHER: 'other',
  PARENT: 'parent',
  PERFORMANCE: 'performance',
  PLATFORM: 'platform',
  RAW: 'raw',
  REGISTRATION: 'registration',
  RESPONSE: 'response',
  RESULT: 'result',
  REVISION: 'revision',
  SCALE: 'scale',
  SCALED: 'scaled',
  SCORE: 'score',
  SEQUENCING: 'sequencing',
  SHA2: 'sha2',
  SOURCE: 'source',
  STATEMENT_REF: 'statementRef',
  STATEMENT: 'statement',
  STEPS: 'steps',
  STORED: 'stored',
  SUB_CONTEXT: 'subContext',
  SUCCESS: 'success',
  TARGET: 'target',
  TEAM: 'team',
  TIMESTAMP: 'timestamp',
  TYPE: 'type',
  USAGE_TYPE: 'usageType',
  VERB: 'verb',
  VERSION: 'version'
});

var objectTypes = Object.freeze({
  GROUP: 'Group',
  AGENT: 'Agent',
  ACTIVITY: 'Activity',
  STATEMENT_REF: 'StatementRef',
  SUB_STATEMENT: 'SubStatement'
});

var xapiValidationIfiPropertyNames = Object.freeze([properties.ACCOUNT, properties.MBOX_SHA_1_SUM, properties.MBOX, properties.OPEN_ID]);

var xApiValidObjectTypes = Object.freeze([objectTypes.GROUP, objectTypes.AGENT, objectTypes.ACTIVITY, objectTypes.STATEMENT_REF, objectTypes.SUB_STATEMENT]);

exports.properties = properties;
exports.objectTypes = objectTypes;
exports.xapiValidationIfiPropertyNames = xapiValidationIfiPropertyNames;
exports.xApiValidObjectTypes = xApiValidObjectTypes;

},{}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var xapiValidationRegex = Object.freeze({
  UUID: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
  ISO_8601_DURATION: /^P((\d+([\.,]\d+)?Y)?(\d+([\.,]\d+)?M)?(\d+([\.,]\d+)?W)?(\d+([\.,]\d+)?D)?)?(T(\d+([\.,]\d+)?H)?(\d+([\.,]\d+)?M)?(\d+([\.,]\d+)?S)?)?$/,
  ISO_8601_DATE_TIME: /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/,
  MAILTO_URI: /^mailto:/,
  CONTAINS_WHITESPACE: /\s/g,
  SEMVER_1_P_0_P_0: /^((\d+)\.(\d+)\.(\d+))(?:-([\dA-Za-z\-]+))?$/,
  BASE_64: /^(?:[A-Za-z0-9\+\/]{4})*(?:[A-Za-z0-9\+\/]{2}==|[A-Za-z0-9\+\/]{3}=|[A-Za-z0-9\+\/]{4})$/,
  IRI: /^[a-z](?:[\-a-z0-9\+\.])*:(?:\/\/(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4}:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+[\-a-z0-9\._~!\$&'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=@])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@])|[\uE000-\uF8FF\uF0000-\uFFFFD|\u100000-\u10FFFD\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[\-a-z0-9\._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&'\(\)\*\+,;=:@])|[\/\?])*)?$/i,
  BCP_47: /^(?:(en-GB-oed|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)|sgn-(?:BE-FR|BE-NL|CH-DE))|(art-lojban|cel-gaulish|no-(?:bok|nyn)|zh-(?:guoyu|hakka|min|min-nan|xiang)))$|^(x(?:-[0-9a-z]{1,8})+)$|^(?:((?:[a-z]{2,3}(?:(?:-[a-z]{3}){1,3})?)|[a-z]{4}|[a-z]{5,8})(?:-([a-z]{4}))?(?:-([a-z]{2}|[0-9]{3}))?((?:-(?:[a-z0-9]{5,8}|[0-9][a-z0-9]{3}))*)?((?:-[0-9a-wy-z](?:-[a-z0-9]{2,8}){1,})*)?(-x(?:-[0-9a-z]{1,8})+)?)$/i
});

var dateFormatRegexPositions = Object.freeze({
  YEAR: 1,
  MONTH: 2,
  DAY: 3,
  HOUR: 4,
  MINUTE: 5,
  SECOND: 6,
  MSECOND: 7,
  ZONE: 8,
  RELATIVE_TIME: 9,
  TIME_ZONE_HOUR: 10,
  TIME_ZONE_MINUTE: 11
});

exports.xapiValidationRegex = xapiValidationRegex;
exports.dateFormatRegexPositions = dateFormatRegexPositions;

},{}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.xapiWhiteListProperties = undefined;

var _properties = require('../constants/properties');

var xapiWhiteListProperties = Object.freeze({
  IFI: [_properties.properties.HOME_PAGE, _properties.properties.NAME],
  URI: [_properties.properties.ID, _properties.properties.DISPLAY],
  COMPONENT_ARRAY: [_properties.properties.ID, _properties.properties.DESCRIPTION],
  ACTIVITY_DEFINITION: [_properties.properties.NAME, _properties.properties.DESCRIPTION, _properties.properties.TYPE, _properties.properties.MORE_INFO, _properties.properties.EXTENSIONS, _properties.properties.INTERACTION_TYPE, _properties.properties.CORRECT_RESPONSES_PATTERN, _properties.properties.CHOICES, _properties.properties.SCALE, _properties.properties.SOURCE, _properties.properties.TARGET, _properties.properties.STEPS],
  ACTIVITY: [_properties.properties.OBJECT_TYPE, _properties.properties.ID, _properties.properties.DEFINITION],
  STATEMENT_REF: [_properties.properties.ID, _properties.properties.OBJECT_TYPE],
  SCORE: [_properties.properties.SCALED, _properties.properties.RAW, _properties.properties.MIN, _properties.properties.MAX],
  RESULT: [_properties.properties.SCORE, _properties.properties.SUCCESS, _properties.properties.COMPLETION, _properties.properties.RESPONSE, _properties.properties.DURATION, _properties.properties.EXTENSIONS],
  ATTACHMENT: [_properties.properties.USAGE_TYPE, _properties.properties.DISPLAY, _properties.properties.DESCRIPTION, _properties.properties.CONTENT_TYPE, _properties.properties.LENGTH, _properties.properties.SHA2, _properties.properties.FILE_URL],
  AGENT: [_properties.properties.OBJECT_TYPE, _properties.properties.NAME, _properties.properties.ACCOUNT, _properties.properties.MBOX_SHA_1_SUM, _properties.properties.MBOX, _properties.properties.OPEN_ID],
  GROUP: [_properties.properties.OBJECT_TYPE, _properties.properties.NAME, _properties.properties.MEMBER, _properties.properties.ACCOUNT, _properties.properties.MBOX_SHA_1_SUM, _properties.properties.MBOX, _properties.properties.OPEN_ID],
  CONTEXT_ACTIVITIES: [_properties.properties.PARENT, _properties.properties.GROUPING, _properties.properties.CATEGORY, _properties.properties.OTHER],
  STATEMENT: [_properties.properties.ID, _properties.properties.ACTOR, _properties.properties.VERB, _properties.properties.OBJECT, _properties.properties.RESULT, _properties.properties.CONTEXT, _properties.properties.TIMESTAMP, _properties.properties.STORED, _properties.properties.AUTHORITY, _properties.properties.VERSION, _properties.properties.ATTACHMENTS],
  SUB_STATEMENT: [_properties.properties.ACTOR, _properties.properties.VERB, _properties.properties.OBJECT, _properties.properties.RESULT, _properties.properties.CONTEXT, _properties.properties.TIMESTAMP, _properties.properties.ATTACHMENTS, _properties.properties.OBJECT_TYPE],
  EXTENSIONS: [_properties.properties.REGISTRATION, _properties.properties.INSTRUCTOR, _properties.properties.TEAM, _properties.properties.CONTEXT_ACTIVITIES, _properties.properties.REVISION, _properties.properties.PLATFORM, _properties.properties.LANGUAGE, _properties.properties.STATEMENT, _properties.properties.EXTENSIONS]
});

exports.xapiWhiteListProperties = xapiWhiteListProperties;

},{"../constants/properties":45}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var IS_STRING = '[object String]',
    IS_ARRAY = '[object Array]',
    IS_BOOLEAN = '[object Boolean]',
    IS_NUMBER = '[object Number]';

var toString = Object.prototype.toString;
var xapiValidationUtils;

exports.xapiValidationUtils = xapiValidationUtils = {
  isString: function isString(obj) {
    return toString.call(obj) === IS_STRING;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },


  isArray: Array.isArray || function (obj) {
    return toString.call(obj) === IS_ARRAY;
  },

  isBoolean: function isBoolean(obj) {
    return obj === true || obj === false || toString.call(obj) === IS_BOOLEAN;
  },
  isNumber: function isNumber(obj) {
    return toString.call(obj) === IS_NUMBER;
  },
  isDefined: function isDefined(obj) {
    return obj !== null || obj !== undefined;
  },
  isNonNullMapObject: function isNonNullMapObject(target) {
    return this.isDefined(target) && this.isObject(target) && !this.isArray(target);
  },
  isValidLanguageTag: function isValidLanguageTag(target, validLanguageRegex) {
    // TODO - use more precise 5646 handling, rather than this simplified BCP 47 regex, which combines RFC 5646 and RFC 4647.
    // return this.isDefined(target) && this.isString(target) && xapiValidationRegex.BCP_47.test(target);
    return this.isDefined(target) && this.isString(target) && validLanguageRegex.test(target);
  },
  addPropToTrace: function addPropToTrace(trace, addendum) {
    return this.isDefined(addendum) ? trace + '.' + addendum : trace;
  },
  addLookupToTrace: function addLookupToTrace(trace, key) {
    return !this.isDefined(key) ? trace : this.isNumber(key) ? trace + '[' + key + ']' : trace + '["' + key + '"]';
  },
  localTraceToString: function localTraceToString(trace, addendum) {
    return this.addPropToTrace(trace, addendum);
  },
  isGroup: function isGroup(actorOrGroup, groupType) {
    // return (actorOrGroup.member !== null && actorOrGroup.member !== undefined) || actorOrGroup.objectType === objectTypes.GROUP;
    return actorOrGroup.member !== null && actorOrGroup.member !== undefined || actorOrGroup.objectType === groupType;
  }
};

exports.xapiValidationUtils = xapiValidationUtils;

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateStatement = undefined;

var _properties = require('./constants/properties');

var _whitelists = require('./constants/whitelists');

var _errors = require('./constants/errors');

var _interactionTypes = require('./constants/interaction-types');

var _regex = require('./constants/regex');

var _general = require('./constants/general');

var _utils = require('./utils/utils');

function makeV1Report(instance, errors) {
  var version;

  instance = instance || null;
  errors = errors || null;
  version = _general.xapiGeneral.FIRST_REPORT_VERSTION;
  return { instance: instance, errors: errors, version: version };
}

function makeV1SingleErrorReport(instance, error) {
  return makeV1Report(instance, error === null || error === undefined ? [] : [error]);
}

function validateAbsenceOfNonWhitelistedProperties(target, allowedProperties, trace, errors) {
  var localErrors, localTrace, propertyName;

  localErrors = errors || [];
  localTrace = trace || '';

  for (propertyName in target) {
    if (target.hasOwnProperty(propertyName) && allowedProperties.indexOf(propertyName) === _general.xapiGeneral.NO_INDEX_FOUND) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, propertyName),
        message: _errors.xapiValidationErrors.UNEXPECTED,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  return localErrors;
}

function validatePropertyIsString(parent, propertyName, trace, errors, isRequired, violationType) {
  var localErrors, localTrace, propValue, localViolationType;

  localErrors = errors || [];
  localTrace = trace || '';
  propValue = parent[propertyName], localViolationType = violationType || _errors.xapiErrorLevels.MUST_VIOLATION;

  if (propValue !== undefined) {
    if (propValue === null || !_utils.xapiValidationUtils.isString(propValue)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
        message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_STRING,
        level: localViolationType
      });
    }
  } else if (isRequired) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
      message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_PRESENT,
      level: localViolationType
    });
  }

  return localErrors;
}

function validatePropertyIsUri(target, propertyName, trace, errors, isRequired) {
  var localErrors, localTrace, propValue;

  localErrors = errors || [];
  localTrace = trace || '';
  propValue = target[propertyName];

  if (propValue !== undefined) {
    if (propValue === null || !_utils.xapiValidationUtils.isString(propValue)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
        message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_URI_STRING,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    } else if (!_regex.xapiValidationRegex.IRI.test(propValue)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
        message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_IRI_STRING,
        level: _errors.xapiErrorLevels.SHOULD_VIOLATION
      });
    }
  } else if (isRequired) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
      message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_URI_PRESENT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }
  return localErrors;
}

function validatePropertyIsUrl(target, propertyName, trace, errors, isRequired) {
  // TODO - check whether a formal URL format definition is recommended/enforced for xAPI
  return validatePropertyIsString(target, propertyName, trace, errors, isRequired);
}

function validatePropertyIsBoolean(parent, propertyName, trace, errors, isRequired) {
  var localErrors, localTrace, propValue;

  localErrors = errors || [];
  localTrace = trace || '';
  propValue = parent[propertyName];

  if (propValue !== undefined) {
    if (propValue === null || !_utils.xapiValidationUtils.isBoolean(propValue)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
        message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_BOOLEAN,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  } else if (isRequired) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
      message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_BOOLEAN_PRESENT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }
  return localErrors;
}

function validatePropertyIsNumber(parent, propertyName, trace, errors, isRequired) {
  var localErrors, localTrace, propValue;

  localErrors = errors || [];
  localTrace = trace || '';
  propValue = parent[propertyName];

  if (propValue !== undefined) {
    if (propValue === null || !_utils.xapiValidationUtils.isNumber(propValue)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
        message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_NUMBER,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  } else if (isRequired) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
      message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_NUMBER_PRESENT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }
  return localErrors;
}

function validateIFIProperties(target, trace, errors) {
  var localErrors, localTrace, accountTrace;

  localErrors = errors || [];
  localTrace = trace || '';

  if (target.mbox !== undefined && target.mbox !== null) {
    if (!_utils.xapiValidationUtils.isString(target.mbox)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.MBOX),
        message: _errors.xapiValidationErrors.IFI_MUST_BE_MBOX_URI,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    } else if (!_regex.xapiValidationRegex.MAILTO_URI.test(target.mbox)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.MBOX),
        message: _errors.xapiValidationErrors.IFI_MUST_BE_VALID_MBOX_FORMAT,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  validatePropertyIsString(target, _properties.properties.MBOX_SHA_1_SUM, localTrace, localErrors, /*isRequired*/false);
  validatePropertyIsUri(target, _properties.properties.OPEN_ID, localTrace, localErrors, /*isRequired*/false);

  if (target.account !== undefined && target.account !== null) {
    accountTrace = _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.ACCOUNT);
    validatePropertyIsUri(target.account, _properties.properties.HOME_PAGE, accountTrace, localErrors, /*isRequired*/true);
    validatePropertyIsString(target.account, _properties.properties.NAME, accountTrace, localErrors, /*isRequired*/true);
    validateAbsenceOfNonWhitelistedProperties(target.account, _whitelists.xapiWhiteListProperties.IFI, accountTrace, localErrors);
  }

  return localErrors;
}

function getIFIs(target) {
  var ifis;

  if (target === null || target === undefined) {
    return [];
  }

  ifis = _properties.xapiValidationIfiPropertyNames.filter(function (name) {
    if (target[name] !== undefined && target[name] !== null) {
      return { key: name, value: target[name] };
    }
  });

  return ifis;
}

function getIFICount(target) {
  return getIFIs(target).length;
}

function validateExtensions(extensions, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [], localTrace = trace || _properties.properties.EXTENSIONS;

  if (extensions === undefined) {
    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(extensions)) {
    localErrors.push({
      trace: localTrace,
      message: _errors.xapiValidationErrors.EXTENSIONS_MUST_NOT_BE_NULL,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }
  // TODO - double-check what further enforceable constraints exist on extension object properties
  return localErrors;
}

function validateLanguageMap(languageMap, trace, errors) {
  var localErrors, localTrace, propName, mappedValue;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.LANGUAGE_MAP;

  if (languageMap === undefined) {
    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(languageMap)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace),
      message: _errors.xapiValidationErrors.LANGUAGE_MAPS_MUST_NOT_BE_NULL,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  for (propName in languageMap) {

    if (languageMap.hasOwnProperty(propName)) {
      if (!_utils.xapiValidationUtils.isValidLanguageTag(propName, _regex.xapiValidationRegex.BCP_47)) {
        localErrors.push({
          trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, propName),
          message: propName + ' ' + _errors.xapiValidationErrors.LANGUAGE_MAP_KEY_INVALID,
          level: _errors.xapiErrorLevels.MUST_VIOLATION
        });
      }

      mappedValue = languageMap[propName];

      if (mappedValue === null || mappedValue === undefined || !_utils.xapiValidationUtils.isString(mappedValue)) {
        localErrors.push({
          trace: _utils.xapiValidationUtils.addLookupToTrace(localTrace, propName),
          message: propName + ' ' + _errors.xapiValidationErrors.LANGUAGE_MAP_KEY_MUST_BE_STRING,
          level: _errors.xapiErrorLevels.MUST_VIOLATION
        });
      }
    }
  }

  return localErrors;
}

function validateVerb(verb, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.VERB;

  if (verb === undefined) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.VERB_MUST_BE_PROVIDED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(verb)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.VERB_MUST_NOT_BE_NULL,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  validatePropertyIsUri(verb, _properties.properties.ID, localTrace, localErrors, /*isRequired*/true);

  if (verb.display === undefined) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DISPLAY),
      message: _errors.xapiValidationErrors.DISPLAY_SHOULD_BE_PROVIDED,
      level: _errors.xapiErrorLevels.SHOULD_VIOLATION
    });
  } else {
    validateLanguageMap(verb.display, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DISPLAY), localErrors);
  }

  validateAbsenceOfNonWhitelistedProperties(verb, _whitelists.xapiWhiteListProperties.URI, localTrace, localErrors);

  return localErrors;
}

function validateInteractionComponentArray(components, interactionType, allowedInteractionTypes, trace, errors) {
  var localErrors, localTrace, isAllowedComponentType, ids, perComponentTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.INTERACTION_COMPONENTS;
  isAllowedComponentType = allowedInteractionTypes.indexOf(interactionType) !== _general.xapiGeneral.NO_INDEX_FOUND;
  ids = [];

  if (isAllowedComponentType && components !== undefined) {
    if (components === null || !_utils.xapiValidationUtils.isArray(components)) {
      localErrors.push({
        trace: localTrace,
        message: _errors.xapiValidationErrors.INTERACTION_COMPONENT_SHOULD_BE_ARRAY,
        level: _errors.xapiErrorLevels.SHOULD_VIOLATION
      });
    } else {
      components.forEach(function (interactionComponent, i) {
        perComponentTrace = _utils.xapiValidationUtils.addLookupToTrace(localTrace, i);

        if (!_utils.xapiValidationUtils.isNonNullMapObject(interactionComponent)) {
          localErrors.push({
            trace: perComponentTrace,
            message: _errors.xapiValidationErrors.INTERACTION_COMPONENT_MUST_NOT_BE_NULL,
            level: _errors.xapiErrorLevels.MUST_VIOLATION
          });
        } else {
          validatePropertyIsString(interactionComponent, _properties.properties.ID, perComponentTrace, localErrors, /*isRequired*/true, _errors.xapiErrorLevels.MUST_VIOLATION);
          if (ids.indexOf(interactionComponent.id) !== _general.xapiGeneral.NO_INDEX_FOUND) {
            localErrors.push({
              trace: _utils.xapiValidationUtils.addPropToTrace(perComponentTrace, _properties.properties.ID),
              message: _errors.xapiValidationErrors.ID_MUST_BE_UNIQUE,
              level: _errors.xapiErrorLevels.MUST_VIOLATION
            });
          } else {
            ids.push(interactionComponent.id);
          }

          if (interactionComponent.id && _regex.xapiValidationRegex.CONTAINS_WHITESPACE.test(interactionComponent.id)) {
            localErrors.push({
              trace: _utils.xapiValidationUtils.addPropToTrace(perComponentTrace, _properties.properties.ID),
              message: _errors.xapiValidationErrors.ID_SHOULD_NOT_CONTAIN_WHITESPACES,
              level: _errors.xapiErrorLevels.SHOULD_VIOLATION
            });
          }

          validateLanguageMap(interactionComponent.description, _utils.xapiValidationUtils.addPropToTrace(perComponentTrace, _properties.properties.DESCRIPTION), localErrors);
          validateAbsenceOfNonWhitelistedProperties(interactionComponent, _whitelists.xapiWhiteListProperties.COMPONENT_ARRAY, perComponentTrace, localErrors);
        }
      });
    }
  } else if (interactionType && components) {
    localErrors.push({
      trace: localTrace,
      message: _errors.xapiValidationErrors.INTERACTION_TYPE_MUST_BE_VALID + ' ' + interactionType,
      level: _errors.xapiErrorLevels.SHOULD_VIOLATION
    });
  }

  return localErrors;
}

function validateActivityDefintion(definition, trace, errors) {
  var localErrors, localTrace, correctResponsesPatternTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.DEFINITION;
  correctResponsesPatternTrace = _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.CORRECT_RESPONSES_PATTERN);

  if (!_utils.xapiValidationUtils.isNonNullMapObject(definition)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace),
      message: _errors.xapiValidationErrors.DEFINITIONS_MUST_BE_OBJECTS,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  validateLanguageMap(definition.name, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.NAME), localErrors);
  validateLanguageMap(definition.description, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DESCRIPTION), localErrors);

  validatePropertyIsUri(definition, _properties.properties.TYPE, localTrace, localErrors, /*isRequired*/false);
  validatePropertyIsUrl(definition, _properties.properties.MORE_INFO, localTrace, localErrors, /*isRequired*/false);
  validateExtensions(definition.extensions, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.EXTENSIONS), localErrors);

  if (definition.interactionType !== undefined) {
    if (definition.type !== _general.xapiGeneral.INTERACTION_DEFINITION_TYPE) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.TYPE),
        message: _errors.xapiValidationErrors.INTERACTION_ACTIVITY_SHOULD_HAVE + ' "' + _general.xapiGeneral.INTERACTION_DEFINITION_TYPE + '"',
        level: _errors.xapiErrorLevels.SHOULD_VIOLATION
      });
    }

    if (_interactionTypes.xapiValidationInteractionTypes.indexOf(definition.interactionType) === _general.xapiGeneral.NO_INDEX_FOUND) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.INTERACTION_TYPE),
        message: _errors.xapiValidationErrors.INTERACTION_TYPE_MUST_BE_CMI,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  if (definition.correctResponsesPattern !== undefined) {
    if (!_utils.xapiValidationUtils.isArray(definition.correctResponsesPattern)) {
      localErrors.push({
        trace: correctResponsesPatternTrace,
        message: _errors.xapiValidationErrors.CORRECT_RESPONSES_PATTERN_MUST_BE_ARRAY,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    } else {
      definition.correctResponsesPattern.forEach(function (response, i) {
        if (response === null || response === undefined || !_utils.xapiValidationUtils.isString(response)) {
          localErrors.push({
            trace: _utils.xapiValidationUtils.addLookupToTrace(correctResponsesPatternTrace, i),
            message: _errors.xapiValidationErrors.CORRECT_RESPONSES_PATTERN_MUST_BE_STRINGS,
            level: _errors.xapiErrorLevels.MUST_VIOLATION
          });
        }
      });
    }
  }

  validateInteractionComponentArray(definition.choices, definition.interactionType, [_properties.properties.CHOICE, _properties.properties.SEQUENCING], _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.CHOICES), localErrors);

  validateInteractionComponentArray(definition.scale, definition.interactionType, [_properties.properties.LIKERT], _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.SCALE), localErrors);

  validateInteractionComponentArray(definition.source, definition.interactionType, [_properties.properties.MATCHING], _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.SOURCE), localErrors);

  validateInteractionComponentArray(definition.target, definition.interactionType, [_properties.properties.MATCHING], _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.TARGET), localErrors);

  validateInteractionComponentArray(definition.steps, definition.interactionType, [_properties.properties.PERFORMANCE], _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.STEPS), localErrors);

  validateAbsenceOfNonWhitelistedProperties(definition, _whitelists.xapiWhiteListProperties.ACTIVITY_DEFINITION, localTrace, localErrors);
  return localErrors;
}

function validateActivity(activity, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.ACTIVITY;

  if (!_utils.xapiValidationUtils.isNonNullMapObject(activity)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.ACTIVITIES_MUST_NOT_BE_NULL,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  validatePropertyIsUri(activity, _properties.properties.ID, localTrace, localErrors, /*isRequired*/true);

  if (activity.definition !== undefined) {
    validateActivityDefintion(activity.definition, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DEFINITION), localErrors);
  }

  validateAbsenceOfNonWhitelistedProperties(activity, _whitelists.xapiWhiteListProperties.ACTIVITY, localTrace, localErrors);

  return localErrors;
}

function validateStatementRef(statementRef, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.STATEMENT_REF;

  if (!_utils.xapiValidationUtils.isNonNullMapObject(statementRef)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.STATEMENT_REF_MUST_NOT_BE_NULL_MAP_OBJECTS,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
    return localErrors;
  }

  if (statementRef.objectType !== _properties.objectTypes.STATEMENT_REF) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.OBJECT_TYPE),
      message: _errors.xapiValidationErrors.OBJECT_TYPE_MUST_BE_STATEMENT_REF,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if (!statementRef.id || !_regex.xapiValidationRegex.UUID.test(statementRef.id)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.ID),
      message: _errors.xapiValidationErrors.ID_MUST_BE_VALID_UUID_REF,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  validateAbsenceOfNonWhitelistedProperties(statementRef, _whitelists.xapiWhiteListProperties.STATEMENT_REF, localTrace, localErrors);

  return localErrors;
}

function validateScore(score, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.SCORE;

  if (score === undefined) {
    return localErrors;
  }

  validatePropertyIsNumber(score, _properties.properties.SCALED, localTrace, localErrors, /*isRequired*/false);

  if (score.scaled !== undefined) {
    if (score.scaled < _general.xapiGeneral.MIN_SCALED_VALUE || score.scaled > _general.xapiGeneral.MAX_SCALED_VALUE) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.SCALED),
        message: _errors.xapiValidationErrors.SCALED_MUST_BE_BETWEEN_0_1,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  if (score.min !== undefined) {
    validatePropertyIsNumber(score, _properties.properties.MIN, localTrace, localErrors, /*isRequired*/false);

    if (score.raw !== undefined && score.raw < score.min) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.RAW),
        message: _errors.xapiValidationErrors.RAW_MUST_BE_GREATER_THAN_MIN,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }

    if (score.max !== undefined && score.max < score.min) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.MAX),
        message: _errors.xapiValidationErrors.MAX_MUST_BE_GREATER_THAN_MIN,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  if (score.max !== undefined) {
    validatePropertyIsNumber(score, _properties.properties.MAX, localTrace, localErrors, /*isRequired*/false);

    if (score.raw !== undefined && score.raw > score.max) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.RAW),
        message: _errors.xapiValidationErrors.RAW_MUST_BE_LESS_THAN_MAX,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  validatePropertyIsNumber(score, _properties.properties.RAW, localTrace, localErrors, /*isRequired*/false);
  validateAbsenceOfNonWhitelistedProperties(score, _whitelists.xapiWhiteListProperties.SCORE, localTrace, localErrors);

  return localErrors;
}

function validateResult(result, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.RESULT;

  if (result === undefined) {
    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(result)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace),
      message: _errors.xapiValidationErrors.RESULT_MUST_BE_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  validateScore(result.score, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.SCORE), localErrors);
  validatePropertyIsBoolean(result, _properties.properties.SUCCESS, localTrace, localErrors, /*isRequired*/false);
  validatePropertyIsBoolean(result, _properties.properties.COMPLETION, localTrace, localErrors, /*isRequired*/false);
  validatePropertyIsString(result, _properties.properties.RESPONSE, localTrace, localErrors, /*isRequired*/false);
  validateExtensions(result.extensions, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.EXTENSIONS), localErrors);

  if (result.duration !== undefined && (result.duration === null || !_utils.xapiValidationUtils.isString(result.duration) || !_regex.xapiValidationRegex.ISO_8601_DURATION.test(result.duration))) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DURATION),
      message: _errors.xapiValidationErrors.DURATION_MUST_BE_VALID,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  validateAbsenceOfNonWhitelistedProperties(result, _whitelists.xapiWhiteListProperties.RESULT, localTrace, localErrors);

  return localErrors;
}

function validatePropertyIsISO8601String(parent, propertyName, trace, errors) {
  var localErrors, localTrace, matched, datetime;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.DATE_TIME;
  datetime = parent[propertyName];

  if (datetime === undefined) {
    return localErrors;
  }

  if (datetime === null || !_utils.xapiValidationUtils.isString(datetime)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
      message: propertyName + ' ' + _errors.xapiValidationErrors.MUST_BE_STRING,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  matched = _regex.xapiValidationRegex.ISO_8601_DATE_TIME.exec(datetime);

  if (matched) {
    if (!dateIncludesZoneInformation(matched)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
        message: _errors.xapiValidationErrors.DATE_SHOULD_INCLUDE_ZONE_INFORMATION,
        level: _errors.xapiErrorLevels.SHOULD_VIOLATION
      });
    }
  } else {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, propertyName),
      message: _errors.xapiValidationErrors.DATE_MUST_BE_VALID,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  return localErrors;
}

function validateVersion(version, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.VERSION;

  if (version === undefined) {
    return localErrors;
  }

  if (version === null || !_utils.xapiValidationUtils.isString(version) || !_regex.xapiValidationRegex.SEMVER_1_P_0_P_0.test(version)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.VERSION_MUST_COMPLY_SEMANTIC_VERSIONING,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  return localErrors;
}

function validateAttachmentObject(attachment, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.ATTACHMENT;

  if (!_utils.xapiValidationUtils.isNonNullMapObject(attachment)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.ATTACHMENTS_MUST_NOT_BE_NULL_MAP_OBJECTS,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  if (attachment.display === undefined) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.DISPLAY),
      message: _errors.xapiValidationErrors.DISPLAY_SHOULD_BE_PROVIDED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  } else {
    validateLanguageMap(attachment.display, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DISPLAY), localErrors);
  }

  validateLanguageMap(attachment.description, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.DESCRIPTION), localErrors);
  validatePropertyIsUri(attachment, _properties.properties.USAGE_TYPE, localTrace, localErrors, /*isRequired*/true, _errors.xapiErrorLevels.MUST_VIOLATION);
  validatePropertyIsUri(attachment, _properties.properties.FILE_URL, localTrace, localErrors, /*isRequired*/false, _errors.xapiErrorLevels.MUST_VIOLATION);

  // TODO - more complete validation for Internet Media Type via RFC 2046
  validatePropertyIsString(attachment, _properties.properties.CONTENT_TYPE, localTrace, localErrors, /*isRequired*/true, _errors.xapiErrorLevels.MUST_VIOLATION);

  if (attachment.length === undefined || attachment.length === null || !_utils.xapiValidationUtils.isNumber(attachment.length) || attachment.length % 1 !== 0) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.LENGTH),
      message: _errors.xapiValidationErrors.LENGTH_MUST_BE_INTEGER,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if (attachment.sha2 === undefined) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.SHA2),
      message: _errors.xapiValidationErrors.SHA2_MUST_BE_PROVIDED_ON_ATTACHMENT_OBJECTS,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  } else if (attachment.sha2 === null || !_utils.xapiValidationUtils.isString(attachment.sha2) || !_regex.xapiValidationRegex.BASE_64.test(attachment.sha2)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.SHA2),
      message: _errors.xapiValidationErrors.SHA2_MUST_CONTAIN_BASE_64_STRING,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  validateAbsenceOfNonWhitelistedProperties(attachment, _whitelists.xapiWhiteListProperties.ATTACHMENT, localTrace, localErrors);
  return localErrors;
}

function validateAttachments(attachments, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.ATTACHMENTS;

  if (attachments === undefined) {
    return localErrors;
  }

  if (attachments === null || !_utils.xapiValidationUtils.isArray(attachments)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.ATTACHMENTS_MUST_BE_NOT_NULL_ARRAY,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  attachments.forEach(function (attachment, i) {
    validateAttachmentObject(attachment, _utils.xapiValidationUtils.addLookupToTrace(localTrace, i), localErrors);
  });

  return localErrors;
}

function validateAgent(agent, trace, errors) {
  var localErrors, localTrace, ifiCount;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.AGENT;

  if (!_utils.xapiValidationUtils.isNonNullMapObject(agent)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.AGENT_MUST_BE_NON_NULL_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
    return localErrors;
  }

  ifiCount = getIFICount(agent);

  if (ifiCount !== _general.xapiGeneral.NUMER_OF_SPECIFIED_IFI_PROPERTIES) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.AGENT_IFI_PROPERTIES_MUST_BE_SPECIFIED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if (agent.objectType === _properties.objectTypes.GROUP) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.AGENT_MUST_NOT_HAVE_GROUP_CHARACTERISTICS,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  validateIFIProperties(agent, localTrace, localErrors);
  validatePropertyIsString(agent, _properties.properties.NAME, localTrace, localErrors, /*isRequired*/false);

  validateAbsenceOfNonWhitelistedProperties(agent, _whitelists.xapiWhiteListProperties.AGENT, localTrace, localErrors);

  return localErrors;
}

function validateGroup(group, trace, errors) {
  var localErrors, localTrace, memberTrace, ifiCount;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.GROUP;
  memberTrace = _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.MEMBER);

  if (!_utils.xapiValidationUtils.isNonNullMapObject(group)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.GROUP_MUST_BE_NON_NULL_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  ifiCount = getIFICount(group);

  if (ifiCount === 0) {
    if (group.member === null || group.member === undefined) {
      localErrors.push({
        trace: memberTrace,
        message: _errors.xapiValidationErrors.MEMBER_MUST_BE_PROVIDED_FOR_ANONYMOUS_GROUPS,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  } else if (ifiCount > _general.xapiGeneral.NUMER_OF_SPECIFIED_IFI_PROPERTIES) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.GROUP_IFI_PROPERTIES_MUST_BE_SPECIFIED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  validateIFIProperties(group, localTrace, localErrors);

  validatePropertyIsString(group, _properties.properties.NAME, localTrace, localErrors, /*isRequired*/false);

  if (group.member !== undefined) {
    if (group.member === null || !_utils.xapiValidationUtils.isArray(group.member)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.MEMBER),
        message: _errors.xapiValidationErrors.GROUP_MEMBER_MUST_BE_ARRAY,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    } else {
      group.member.forEach(function (member, i) {
        validateAgent(member, _utils.xapiValidationUtils.addLookupToTrace(memberTrace, i), localErrors);
      });
    }
  }

  validateAbsenceOfNonWhitelistedProperties(group, _whitelists.xapiWhiteListProperties.GROUP, localTrace, localErrors);

  return localErrors;
}

function validateActor(actor, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.ACTOR;

  if (actor === null || actor === undefined) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.ACTOR_MUST_BE_PROVIDED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  if (_utils.xapiValidationUtils.isGroup(actor, _properties.objectTypes.GROUP)) {
    validateGroup(actor, localTrace, localErrors);
  } else {
    validateAgent(actor, localTrace, localErrors);
  }

  return localErrors;
}

function validateAuthority(authority, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.AUTHORITY;

  if (authority === undefined) {
    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(authority)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.AUTHORITY_MUST_BE_NON_NULL_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }
  if (_utils.xapiValidationUtils.isGroup(authority, _properties.objectTypes.GROUP)) {
    validateGroup(authority, localTrace, localErrors);
    if (!authority.member || !authority.member.length || authority.member.length !== _general.xapiGeneral.GROUP_AUTHORITY_AGENT_MEMBERS) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.MEMBER),
        message: _errors.xapiValidationErrors.GROUP_AUTHORITY_AGENT_MEMBERS_MUST_BE_TWO,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  } else {
    validateAgent(authority, localTrace, localErrors);
  }

  return localErrors;
}

function validateContextActivitySubContext(subContext, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.SUB_CONTEXT;

  if (subContext === undefined) {
    return localErrors;
  }

  if (subContext === null) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.CONTEXT_ACTIVITIES_MUST_NOT_BE_NULL,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  } else if (_utils.xapiValidationUtils.isArray(subContext)) {
    subContext.forEach(function (activity, i) {
      validateActivity(activity, _utils.xapiValidationUtils.addLookupToTrace(localTrace, i), localErrors);
    });
  } else if (_utils.xapiValidationUtils.isObject(subContext)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.CONTEXT_ACTIVITIES_SHOULD_BE_AN_ARRAY,
      level: _errors.xapiErrorLevels.SHOULD_VIOLATION
    });

    validateActivity(subContext, localTrace, localErrors);
  } else {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.CONTEXT_ACTIVITIES_MUST_BE_ARRAY_OR_ACTIVITY_OBJ,
      level: _errors.xapiErrorLevels.MUST_VIOLATION });
  }
  return localErrors;
}

function validateContextActivities(contextActivities, trace, errors) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.CONTEXT_ACTIVITIES;

  if (contextActivities === undefined) {
    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(contextActivities)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.CONTEXT_ACTIVITIES_MUST_BE_NON_NULL_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
    return localErrors;
  }

  validateContextActivitySubContext(contextActivities.parent, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.PARENT), localErrors);
  validateContextActivitySubContext(contextActivities.grouping, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.GROUPING), localErrors);
  validateContextActivitySubContext(contextActivities.category, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.CATEGORY), localErrors);
  validateContextActivitySubContext(contextActivities.other, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.OTHER), localErrors);

  validateAbsenceOfNonWhitelistedProperties(contextActivities, _whitelists.xapiWhiteListProperties.CONTEXT_ACTIVITIES, localTrace, localErrors);

  return localErrors;
}

function validateContext(context, trace, errors, statementObjectObjectType) {
  var localErrors, localTrace;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.CONTEXT;

  if (context === undefined) {
    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(context)) {
    localErrors.push({
      trace: localTrace,
      message: _errors.xapiValidationErrors.CONTEXT_MUST_BE_NON_NUL_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  if (context.registration !== undefined && (context.registration === null || !_utils.xapiValidationUtils.isString(context.registration) || !_regex.xapiValidationRegex.UUID.test(context.registration))) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.REGISTRATION),
      message: _errors.xapiValidationErrors.REGISTRATION_MUST_BE_UUID_STRING,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if ([_properties.objectTypes.GROUP, _properties.objectTypes.AGENT].indexOf(statementObjectObjectType) !== _general.xapiGeneral.NO_INDEX_FOUND) {
    if (context.revision !== undefined) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.REVISION),
        message: _errors.xapiValidationErrors.REVISION_MUST_BE_AGENT_OR_GROUP,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }

    if (context.platform !== undefined) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.PLATFORM),
        message: _errors.xapiValidationErrors.PLATFORM_MUST_NOT_BE_USED_WITH_REVISION_AGENT_OR_GROUP,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  }

  validatePropertyIsString(context, _properties.properties.REVISION, localTrace, localErrors, /*isRequired*/false, _errors.xapiErrorLevels.MUST_VIOLATION);
  validatePropertyIsString(context, _properties.properties.PLATFORM, localTrace, localErrors, /*isRequired*/false, _errors.xapiErrorLevels.MUST_VIOLATION);

  if (context.team !== undefined) {
    validateGroup(context.team, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.TEAM), localErrors);
  }

  if (context.contextActivities !== undefined) {
    validateContextActivities(context.contextActivities, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.CONTEXT_ACTIVITIES), localErrors);
  }

  if (context.language !== undefined && !_utils.xapiValidationUtils.isValidLanguageTag(context.language, _regex.xapiValidationRegex.BCP_47)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.LANGUAGE),
      message: _errors.xapiValidationErrors.LANGUAGE_MUST_BE_STRING,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if (context.statement !== undefined) {
    validateStatementRef(context.statement, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.STATEMENT), localErrors);
  }

  if (context.instructor !== undefined) {
    if (_utils.xapiValidationUtils.isGroup(context.instructor, _properties.objectTypes.GROUP)) {
      validateGroup(context.instructor, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.INSTRUCTOR), localErrors);
    } else {
      validateAgent(context.instructor, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.INSTRUCTOR), localErrors);
    }
  }

  validateExtensions(context.extensions, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.EXTENSIONS), localErrors);
  validateAbsenceOfNonWhitelistedProperties(context, _whitelists.xapiWhiteListProperties.EXTENSIONS, localTrace, localErrors);

  return localErrors;
}

function validateObject(object, trace, errors, isWithinSubStatement) {
  var localErrors, localTrace, objectType;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.OBJECT;

  if (object === undefined) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.OBJECT_MUST_BE_DEFINED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  if (!_utils.xapiValidationUtils.isNonNullMapObject(object)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.OBJECT_MUST_BE_NON_NULL_MAP_OBJECT,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  validatePropertyIsString(object, _properties.properties.OBJECT_TYPE, localTrace, localErrors, /*isRequired*/true, _errors.xapiErrorLevels.SHOULD_VIOLATION);

  objectType = object.objectType || _properties.objectTypes.ACTIVITY;

  switch (objectType) {
    case _properties.objectTypes.ACTIVITY:
      validateActivity(object, localTrace, localErrors);
      break;
    case _properties.objectTypes.AGENT:
      validateAgent(object, localTrace, localErrors);
      break;
    case _properties.objectTypes.GROUP:
      validateGroup(object, localTrace, localErrors);
      break;
    case _properties.objectTypes.STATEMENT_REF:
      validateStatementRef(object, localTrace, localErrors);
      break;
    case _properties.objectTypes.SUB_STATEMENT:
      if (isWithinSubStatement) {
        localErrors.push({
          trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.OBJECT_TYPE),
          message: _errors.xapiValidationErrors.SUB_STATEMENT_MUST_NOT_CONTAIN_SUB_STATEMENT,
          level: _errors.xapiErrorLevels.MUST_VIOLATION
        });
      }
      validate(object, localTrace, localErrors, /*isSubStatement*/true);
      break;
    default:
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.OBJECT_TYPE),
        message: _errors.xapiValidationErrors.OBJECT_TYPE_MUST_BE_VALID_OPTION + ' ' + _properties.xApiValidObjectTypes.toString(),
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
  }

  return localErrors;
}

function validate(statement, trace, errors, isSubStatement) {
  var localErrors, localTrace, statementObjectObjectType, whitelistedProperties;

  localErrors = errors || [];
  localTrace = trace || _properties.properties.STATEMENT;

  whitelistedProperties = _whitelists.xapiWhiteListProperties.STATEMENT;

  if (!_utils.xapiValidationUtils.isNonNullMapObject(statement)) {
    localErrors.push({
      trace: _utils.xapiValidationUtils.localTraceToString(localTrace),
      message: _errors.xapiValidationErrors.STATEMENT_REF_MUST_NOT_BE_NULL_MAP_OBJECTS,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });

    return localErrors;
  }

  if (!isSubStatement) {
    if (statement.id === null || statement.id === undefined || !_utils.xapiValidationUtils.isString(statement.id)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.ID),
        message: _errors.xapiValidationErrors.IDS_SHOULD_BE_GENERATED_BY_LRS,
        level: _errors.xapiErrorLevels.SHOULD_VIOLATION
      });
    } else if (!_regex.xapiValidationRegex.UUID.test(statement.id)) {
      localErrors.push({
        trace: _utils.xapiValidationUtils.localTraceToString(localTrace, _properties.properties.ID),
        message: _errors.xapiValidationErrors.ID_MUST_BE_VALID,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }
  } else {
    whitelistedProperties = _whitelists.xapiWhiteListProperties.SUB_STATEMENT;
  }

  validateActor(statement.actor, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.ACTOR), localErrors);
  validateVerb(statement.verb, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.VERB), localErrors);
  validateObject(statement.object, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.OBJECT), localErrors, isSubStatement);
  validateResult(statement.result, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.RESULT), localErrors);

  statementObjectObjectType = statement.object && statement.object.objectType ? statement.object.objectType : _properties.objectTypes.ACTIVITY;

  validateContext(statement.context, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.CONTEXT), localErrors, statementObjectObjectType);
  validatePropertyIsISO8601String(statement, _properties.properties.TIMESTAMP, localTrace, localErrors);
  validatePropertyIsISO8601String(statement, _properties.properties.STORED, localTrace, localErrors);

  validateAuthority(statement.authority, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.AUTHORITY), localErrors);
  validateVersion(statement.version, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.VERSION), localErrors);
  validateAttachments(statement.attachments, _utils.xapiValidationUtils.addPropToTrace(localTrace, _properties.properties.ATTACHMENTS), localErrors);

  validateAbsenceOfNonWhitelistedProperties(statement, whitelistedProperties, localTrace, localErrors);

  return localErrors;
}

function makeStatementReport(statement) {
  var localErrors;

  localErrors = [];
  validate(statement, _properties.properties.STATEMENT, localErrors, /*isRequired*/false);

  return makeV1Report(statement, localErrors);
}

function validateAmbiguousTypeStatement(statement) {
  var statementObject;

  if (statement === undefined) {
    return makeV1SingleErrorReport( /*instance*/null, {
      trace: _properties.properties.STATEMENT,
      message: _errors.xapiValidationErrors.STATEMENT_ARGUMENT_MUST_BE_PROVIDED,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if (statement === null) {
    return makeV1SingleErrorReport( /*instance*/null, {
      trace: _properties.properties.STATEMENT,
      message: _errors.xapiValidationErrors.STATEMENT_MUST_NOT_BE_NULL,
      level: _errors.xapiErrorLevels.MUST_VIOLATION
    });
  }

  if (_utils.xapiValidationUtils.isString(statement)) {
    try {
      statementObject = JSON.parse(statement);
      if (statementObject === null || !_utils.xapiValidationUtils.isObject(statementObject) || _utils.xapiValidationUtils.isArray(statementObject)) {
        return makeV1SingleErrorReport(statementObject, {
          trace: _properties.properties.STATEMENT,
          message: _errors.xapiValidationErrors.STATEMENT_MUST_BE_PARSED_CORRECTLY,
          level: _errors.xapiErrorLevels.MUST_VIOLATION
        });
      }
    } catch (e) {
      return makeV1SingleErrorReport(statementObject, {
        trace: _properties.properties.STATEMENT,
        message: _errors.xapiValidationErrors.INVALID_JSON + ': ' + e.message,
        level: _errors.xapiErrorLevels.MUST_VIOLATION
      });
    }

    return makeStatementReport(statementObject);
  }

  if (_utils.xapiValidationUtils.isObject(statement) && !_utils.xapiValidationUtils.isArray(statement)) {
    return makeStatementReport(statement);
  }

  return makeV1SingleErrorReport( /*instance*/null, {
    trace: _properties.properties.STATEMENT,
    message: _errors.xapiValidationErrors.STATEMENT_ARGUMENT_IS_NOT_VALID,
    level: _errors.xapiErrorLevels.MUST_VIOLATION
  });
}

function dateIncludesZoneInformation(matched) {
  return matched[_regex.dateFormatRegexPositions.ZONE] || matched[_regex.dateFormatRegexPositions.RELATIVE_TIME] && matched[_regex.dateFormatRegexPositions.TIME_ZONE_HOUR];
}

var validateStatement = exports.validateStatement = validateAmbiguousTypeStatement;

},{"./constants/errors":42,"./constants/general":43,"./constants/interaction-types":44,"./constants/properties":45,"./constants/regex":46,"./constants/whitelists":47,"./utils/utils":48}],50:[function(require,module,exports){
'use strict';var _underscore=require('underscore');var _chai=require('chai');var _xapiValidator=require('../src/xapiValidator');var xapiValidator;xapiValidator={validateStatement:_xapiValidator.validateStatement};describe("xapiValidator",function(){describe("#validateStatement",function(){function reportHasErrorWithTracePrefix(report,prefix,targetLevel){if(report===null||report===undefined||report.errors===null||report.errors===undefined){return false;}var hasTargetLevel=targetLevel!==null&&targetLevel!==undefined;return _underscore._.any(report.errors,function(err){var foundPrefix=err.trace.indexOf(prefix)===0;return hasTargetLevel?targetLevel===err.level&&foundPrefix:foundPrefix;});}describe("when passed no arguments",function(){it("returns non-null report",function(){var result=xapiValidator.validateStatement();(0,_chai.expect)(result).to.be.not.null;(0,_chai.expect)(result).to.be.a("Object");});it("includes one error",function(){var result=xapiValidator.validateStatement();var errors=result.errors;(0,_chai.expect)(errors).to.be.instanceOf(Array);(0,_chai.expect)(errors).to.have.length(1);(0,_chai.expect)(errors[0]).to.have.property("message").that.is.a('string').that.equals('No statement argument provided.');(0,_chai.expect)(errors[0]).to.have.property("level").that.equals("MUST_VIOLATION");});it("has a null instance property in the report",function(){(0,_chai.expect)(xapiValidator.validateStatement()).to.have.property("instance").that.is.null;});});describe("when passed a null argument",function(){it("returns non-null report",function(){var result=xapiValidator.validateStatement(null);(0,_chai.expect)(result).to.be.not.null;(0,_chai.expect)(result).to.be.a("Object");(0,_chai.expect)(result).to.have.property("errors").that.is.a("Array");(0,_chai.expect)(result).to.have.property("instance");});it("includes one error",function(){var result=xapiValidator.validateStatement(null);var errors=result.errors;(0,_chai.expect)(errors).to.be.instanceOf(Array);(0,_chai.expect)(errors).to.have.length(1);(0,_chai.expect)(errors[0]).to.have.property("message").that.is.a('string').that.equals('Null statement argument provided.');(0,_chai.expect)(errors[0]).to.have.property("level").that.equals("MUST_VIOLATION");});it("has a null instance property in the report",function(){(0,_chai.expect)(xapiValidator.validateStatement(null)).to.have.property("instance").that.is.null;});});describe("when passed a json string argument",function(){var minimalJsonString="{\"id\":\"whatever\"}";it("returns non-null report",function(){var result=xapiValidator.validateStatement(minimalJsonString);(0,_chai.expect)(result).to.be.not.null;(0,_chai.expect)(result).to.be.a("Object");(0,_chai.expect)(result).to.have.property("errors").that.is.a("Array");(0,_chai.expect)(result).to.have.property("instance");});it("has an instance property with the deserialized JSON in the report",function(){var result=xapiValidator.validateStatement(minimalJsonString);(0,_chai.expect)(result).to.have.property("instance").that.is.an("Object").that.deep.equals({"id":"whatever"});});});describe("when passed a json string argument encoding null",function(){var minimalJsonString="null";it("returns non-null report",function(){var result=xapiValidator.validateStatement(minimalJsonString);(0,_chai.expect)(result).to.be.not.null;(0,_chai.expect)(result).to.be.a("Object");(0,_chai.expect)(result).to.have.property("errors").that.is.a("Array");(0,_chai.expect)(result).to.have.property("instance");});it("includes one error",function(){var result=xapiValidator.validateStatement(minimalJsonString);var errors=result.errors;(0,_chai.expect)(errors).to.be.instanceOf(Array);(0,_chai.expect)(errors).to.have.length(1);(0,_chai.expect)(errors[0]).to.have.property("message");(0,_chai.expect)(errors[0]).to.have.property("level").that.equals("MUST_VIOLATION");});it("has an instance property with null value",function(){var result=xapiValidator.validateStatement(minimalJsonString);(0,_chai.expect)(result).to.have.property("instance").that.is.null;});});describe("when passed an invalid json string argument",function(){var minimalJsonString="derp";it("returns non-null report",function(){var result=xapiValidator.validateStatement(minimalJsonString);(0,_chai.expect)(result).to.be.not.null;(0,_chai.expect)(result).to.be.a("Object");(0,_chai.expect)(result).to.have.property("errors").that.is.a("Array");(0,_chai.expect)(result).to.have.property("instance");});it("includes one error",function(){var result=xapiValidator.validateStatement(minimalJsonString);var errors=result.errors;(0,_chai.expect)(errors).to.be.instanceOf(Array);(0,_chai.expect)(errors).to.have.length(1);(0,_chai.expect)(errors[0]).to.have.property("message");(0,_chai.expect)(errors[0]).to.have.property("level").that.equals("MUST_VIOLATION");});it("has an instance property with null value",function(){var result=xapiValidator.validateStatement(minimalJsonString);(0,_chai.expect)(result).to.have.property("instance").that.is.null;});});describe("when passed a statement object",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("returns non-null report",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(result).to.be.not.null;(0,_chai.expect)(result).to.be.a("Object");(0,_chai.expect)(result).to.have.property("errors").that.is.a("Array");(0,_chai.expect)(result).to.have.property("instance");});it("has an instance property that matches the input object",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(result).to.have.property("instance").that.deep.equals(inputStatement);});});describe("when given a null id property",function(){var inputStatement={id:null,actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("has an error about the id property",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.id")).to.be.true;});});describe("when given an invalid UUID id property",function(){var inputStatement={id:"abc123",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("has an error about the id property",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.id")).to.be.true;});});describe("when given a valid UUID id property",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("has an error about the id property",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.id")).to.be.false;});});describe("when given a null actor property",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:null,verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("has an error about the actor property",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor")).to.be.true;});});describe("when given an empty non-null actor property",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("has an error about the actor property",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor")).to.be.true;});});describe("when given an otherwise valid actor",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:group@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("the name property is optional",function(){var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(result.errors).to.have.property("length",0);});it("the name property produces no errors when a simple string",function(){inputStatement.actor.name="hello";var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(result.errors).to.have.property("length",0);});it("the name property produces no errors when a simple string",function(){inputStatement.actor.name=1.23;var result=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor.name")).to.be.true;(0,_chai.expect)(result.errors).to.have.property("length",1);});});describe("when given an actor with an objectType of 'Group'",function(){var moreValidStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{objectType:"Group",member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("the member property has no errors about it when present",function(){var result=xapiValidator.validateStatement(moreValidStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor.member")).to.be.false;});it("the member property is required to be present if the actor is unidentified, and produces an error when absent",function(){var inputInvalidStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{objectType:"Group"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var result=xapiValidator.validateStatement(inputInvalidStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor.member")).to.be.true;});it("the member property is not required to be present if the actor is identified",function(){var result=xapiValidator.validateStatement({id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{objectType:"Group",mbox:"mailto:group@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}});(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor.member")).to.be.false;});it("the member property is allowed to be present if the actor is identified",function(){var result=xapiValidator.validateStatement({id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{objectType:"Group",mbox:"mailto:group@example.com",member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}});(0,_chai.expect)(reportHasErrorWithTracePrefix(result,"statement.actor.member")).to.be.false;});});describe("when given an actor with a members property",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};it("the member property has no errors about it when present but empty",function(){(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.be.empty;});it("the member property has no errors when populated with a simple agent",function(){inputStatement.actor.member=[{mbox:"mailto:group@example.com"}];(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.be.empty;});it("the member property reports an error when populated with a Group object via objectType",function(){inputStatement.actor.member=[{mbox:"mailto:group@example.com",objectType:"Group"}];(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.have.property("length",1);});it("the member property's agent reports an error when given an account missing its homePage",function(){inputStatement.actor.member=[{account:{name:"bob"}}];(0,_chai.expect)(reportHasErrorWithTracePrefix(xapiValidator.validateStatement(inputStatement),"statement.actor.member[0].account.homePage")).to.be.true;});it("the member property's agent reports an error when given an account missing its name",function(){inputStatement.actor.member=[{account:{homePage:"http://example.com"}}];(0,_chai.expect)(reportHasErrorWithTracePrefix(xapiValidator.validateStatement(inputStatement),"statement.actor.member[0].account.name")).to.be.true;});it("the member property's agent reports an error when given an account with an all-lowercase homepage",function(){inputStatement.actor.member=[{account:{homepage:"http://example.com",name:"bob"}}];var report=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(report,"statement.actor.member[0].account.homepage")).to.be.true;(0,_chai.expect)(report.errors).to.have.property("length",2);});it("the member property's agent reports no error when given a full account",function(){inputStatement.actor.member=[{account:{homePage:"http://example.com",name:"bob"}}];(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.have.property("length",0);});it("the member property's agent reports no error when given a valid mbox",function(){inputStatement.actor.member=[{mbox:"mailto:bob@example.com"}];(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.have.property("length",0);});it("the member property's agent reports an error when given an invalid mbox",function(){inputStatement.actor.member=[{mbox:"SOMETHINGWRONG:bob@example.com"}];var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.actor.member[0].mbox")).to.be.true;(0,_chai.expect)(results.errors).to.have.property("length",1);});it("the member property reports an error when populated with a Group object via member",function(){inputStatement.actor.member=[{mbox:"mailto:group@example.com",member:[]}];(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.have.property("length",1);});});describe("when given a statement without a verb property",function(){it("reports an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb")).to.be.true;});});describe("when given a verb without an id property",function(){it("reports an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb.id","MUST_VIOLATION")).to.be.true;});});describe("when given a verb with a non-string id property",function(){it("reports an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":12.34,"display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb.id","MUST_VIOLATION")).to.be.true;});});describe("when given a verb with a relative URI id property",function(){it("reports an SHOULD_VIOLATION error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"fragment","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb.id","SHOULD_VIOLATION")).to.be.true;});});describe("when given a verb without a display property",function(){it("reports an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created"},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb.display","SHOULD_VIOLATION")).to.be.true;});});describe("when given a verb with an empty display property",function(){it("reports no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.have.property("length",0);});});describe("when given a verb.display with RFC 5646 key and string value",function(){it("reports no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};(0,_chai.expect)(xapiValidator.validateStatement(inputStatement).errors).to.have.property("length",0);});});describe("when given a verb.display with RFC 5646 key and non-string value",function(){it("reports an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":1.23}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb.display[\"en-US\"]","MUST_VIOLATION")).to.be.true;});});describe("when given a verb.display with invalid key and string value",function(){it("reports an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"123totallyWrong":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.verb.display.123totallyWrong","MUST_VIOLATION")).to.be.true;});});describe("when the object property is absent",function(){it("reports a MUST_VIOLATION error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object","MUST_VIOLATION")).to.be.true;});});describe("when the object property is null",function(){it("reports a MUST_VIOLATION error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object","MUST_VIOLATION")).to.be.true;});});describe("when the object lacks an objectType property",function(){it("reports a SHOULD_VIOLATION error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.objectType","SHOULD_VIOLATION")).to.be.true;});});describe("when the object is an activity with a null definition property",function(){it("reports a MUST_VIOLATION error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition","MUST_VIOLATION")).to.be.true;});});describe("when the object is an activity with an array definition property",function(){it("reports a MUST_VIOLATION error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:[]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition","MUST_VIOLATION")).to.be.true;});});describe("when the object is an Activity with a definition",function(){it("an array for the name property produces a must violation error.",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{name:[]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.name","MUST_VIOLATION")).to.be.true;});it("a number for the name property produces a must violation error.",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{name:1.23}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.name","MUST_VIOLATION")).to.be.true;});it("an invalid language Map key for the name property produces a must violation error.",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{name:{"123 totally not a language code":"created"}}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.name","MUST_VIOLATION")).to.be.true;});it("a CMI interactionType value produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{type:"http://adlnet.gov/expapi/activities/cmi.interaction",interactionType:"true-false"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.name","MUST_VIOLATION")).to.be.false;});it("a non-CMI interactionType value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{type:"http://adlnet.gov/expapi/activities/cmi.interaction",interactionType:"graphicGapMatchInteraction"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.interactionType","MUST_VIOLATION")).to.be.true;});it("a numeric correctResponsesPattern value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{correctResponsesPattern:1.23}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.correctResponsesPattern","MUST_VIOLATION")).to.be.true;});it("a flat string correctResponsesPattern value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{correctResponsesPattern:"1.23"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.correctResponsesPattern","MUST_VIOLATION")).to.be.true;});it("a nested number in a correctResponsesPattern Array value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{correctResponsesPattern:[1.23]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.correctResponsesPattern[0]","MUST_VIOLATION")).to.be.true;});it("a nested string in a correctResponsesPattern Array value produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{correctResponsesPattern:["1.23"]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.correctResponsesPattern","MUST_VIOLATION")).to.be.false;});it("an interaction activity without the standard \"http://adlnet.gov/expapi/activities/cmi.interaction\" value for the type property should produce a SHOULD error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{type:"http://example.com/somethingElse",interactionType:"choice",choices:[]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.type","SHOULD_VIOLATION")).to.be.true;});it("an interaction component array property not associated with the current interactionType produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{type:"http://adlnet.gov/expapi/activities/cmi.interaction",interactionType:"choice",steps:[]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.steps","SHOULD_VIOLATION")).to.be.true;});it("an interaction component with whitespace in the id property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{type:"http://adlnet.gov/expapi/activities/cmi.interaction",interactionType:"choice",choices:[{id:"hello invalid id",description:{}}]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.choices[0]","SHOULD_VIOLATION")).to.be.true;});it("an interaction component with repeated non-unique id produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{member:[]},verb:{"id":"http://adlnet.gov/expapi/verbs/created",display:{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity",definition:{type:"http://adlnet.gov/expapi/activities/cmi.interaction",interactionType:"choice",choices:[{id:"idA",description:{}},{id:"idA",description:{}}]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.definition.choices[1]","MUST_VIOLATION")).to.be.true;});describe("given a statement reference type object",function(){it("reports a MUST error when the id property is missing",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{objectType:"StatementRef"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.id","MUST_VIOLATION")).to.be.true;});it("reports a MUST error when the id property is not a UUID",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"not a UUID",objectType:"StatementRef"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.id","MUST_VIOLATION")).to.be.true;});});describe("given a substatement type object",function(){it("should not report an error when valid",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{objectType:"SubStatement",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("reports a MUST error when the id property is present",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa1",objectType:"SubStatement",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.id","MUST_VIOLATION")).to.be.true;});it("reports a MUST error when the version property is present",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{version:"1.0.0",objectType:"SubStatement",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.version","MUST_VIOLATION")).to.be.true;});it("reports a MUST error when the stored property is present",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{stored:"2013-05-28T07:12:57.245Z",objectType:"SubStatement",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.stored","MUST_VIOLATION")).to.be.true;});it("reports a MUST error when the authority property is present",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{authority:{mbox:"mailto:agent@example.com"},objectType:"SubStatement",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.object.authority","MUST_VIOLATION")).to.be.true;});});describe("given a non-Object results property",function(){it("if null, produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result","MUST_VIOLATION")).to.be.true;});it("if an Array, produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:[]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result","MUST_VIOLATION")).to.be.true;});it("if an number, produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:1.23};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result","MUST_VIOLATION")).to.be.true;});});describe("given a results property that is an object",function(){it("if empty, all is okay, no properties were required",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-Boolean success property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{success:123}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.success","MUST_VIOLATION")).to.be.true;});it("a Boolean success property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{success:false}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-Boolean completion property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{completion:123}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.completion","MUST_VIOLATION")).to.be.true;});it("a Boolean completion property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{completion:false}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-String response property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{response:123}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.response","MUST_VIOLATION")).to.be.true;});it("a String response property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{response:"idA"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-String duration property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{duration:123}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.duration","MUST_VIOLATION")).to.be.true;});it("a non-ISO 8601 duration String duration property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{duration:"not an ISO compliant duration"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.duration","MUST_VIOLATION")).to.be.true;});it("an ISO 8601 duration String response property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{duration:"P3Y6M4DT12H30M5S"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an ISO 8601 duration String response property with fractional seconds produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{duration:"P3Y6M4DT12H30M5.01S"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});});describe("given a score property on the results",function(){it("a non-Number raw property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{raw:"123"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.raw","MUST_VIOLATION")).to.be.true;});it("a Number raw property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{raw:123}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a Number raw property below min produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{raw:123,min:200}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.raw","MUST_VIOLATION")).to.be.true;});it("a Number raw property above max produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{raw:123,max:100}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.raw","MUST_VIOLATION")).to.be.true;});it("a Number raw property between min and max produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{raw:123,min:120,max:125}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-Number scaled property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{scaled:"0.5"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.scaled","MUST_VIOLATION")).to.be.true;});it("a Number scaled property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{scaled:0.5}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a Number scaled property below 0 produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{scaled:-0.5}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.scaled","MUST_VIOLATION")).to.be.true;});it("a Number scaled property above 1 produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{scaled:2}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.scaled","MUST_VIOLATION")).to.be.true;});it("a non-Number max property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{max:"123"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.max","MUST_VIOLATION")).to.be.true;});it("a Number max property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{max:123}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a Number max property below min produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{max:123,min:200}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.max","MUST_VIOLATION")).to.be.true;});it("a non-Number min property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{min:"123"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.min","MUST_VIOLATION")).to.be.true;});it("a Number min property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{min:123}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a Number min property above max produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},result:{score:{max:123,min:200}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.result.score.max","MUST_VIOLATION")).to.be.true;});});describe("for a given defined context property",function(){it("an empty object produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an non-object context value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:123};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context","MUST_VIOLATION")).to.be.true;});it("an array context value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:[]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context","MUST_VIOLATION")).to.be.true;});it("a non-UUID registration value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{registration:"not a UUID"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.registration","MUST_VIOLATION")).to.be.true;});it("a UUID registration value produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{registration:"ed41c918-b88b-4b20-a0a5-a4c32391aaa0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an empty map for an instructor value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{instructor:{}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.instructor","MUST_VIOLATION")).to.be.true;});it("an unidentified Agent for an instructor value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{instructor:{objectType:"Agent"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.instructor","MUST_VIOLATION")).to.be.true;});it("an unidentified Group with no member property for an instructor value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{instructor:{objectType:"Group"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.instructor","MUST_VIOLATION")).to.be.true;});it("an Agent instructor value produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{instructor:{mbox:"mailto:bob@example.com"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a Group instructor identified by member property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{instructor:{mbox:"mailto:bob@example.com",member:[]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a Group instructor identified by objectType property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{instructor:{mbox:"mailto:bob@example.com",objectType:"Group"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("if the statement's object is an Agent, the presence of the revision property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{mbox:"mailto:bob@example.com",objectType:"Agent"},context:{revision:"1.0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.revision","MUST_VIOLATION")).to.be.true;});it("if the statement's object is an Group, the presence of the revision property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{mbox:"mailto:group@example.com",objectType:"Group"},context:{revision:"1.0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.revision","MUST_VIOLATION")).to.be.true;});it("a String revision property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{revision:"1.0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-String numeric revision property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{revision:1.0}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.revision","MUST_VIOLATION")).to.be.true;});it("a null revision property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{revision:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.revision","MUST_VIOLATION")).to.be.true;});///
it("if the statement's object is an Agent, the presence of the platform property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{mbox:"mailto:bob@example.com",objectType:"Agent"},context:{platform:"1.0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.platform","MUST_VIOLATION")).to.be.true;});it("if the statement's object is an Group, the presence of the platform property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{mbox:"mailto:group@example.com",objectType:"Group"},context:{platform:"1.0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.platform","MUST_VIOLATION")).to.be.true;});it("a String platform property produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{platform:"1.0"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-String numeric platform property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{platform:1.0}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.platform","MUST_VIOLATION")).to.be.true;});it("a null platform property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{platform:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.platform","MUST_VIOLATION")).to.be.true;});it("a null team property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{team:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.team","MUST_VIOLATION")).to.be.true;});it("a Group object team property will result in no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{team:{objectType:"Group",mbox:"mailto:group@example.com"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a RFC 5646 string value for the language property will result in no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{language:"en-US"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a non-RFC 5646 string value for the language property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{language:"123 totally not RFC compliant"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.language","MUST_VIOLATION")).to.be.true;});it("a null value for the language property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{language:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.language","MUST_VIOLATION")).to.be.true;});it("a non-String value for the language property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{language:1}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.language","MUST_VIOLATION")).to.be.true;});it("a null value for the context's statement property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{statement:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.statement","MUST_VIOLATION")).to.be.true;});it("an Array value for the context's statement property will result in an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{statement:[]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.statement","MUST_VIOLATION")).to.be.true;});it("an empty object value for the context's statement property will result in errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{statement:{}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",2);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.statement.objectType","MUST_VIOLATION")).to.be.true;(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.statement.id","MUST_VIOLATION")).to.be.true;});it("a valid statement reference for the context's statement property will result in no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{statement:{objectType:"StatementRef",id:"abcdc918-b88b-4b20-a0a5-a4c32391aaa0"}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});});describe("for a context property with a contextActivities property",function(){it("a null contextActivities value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:null}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.contextActivities","MUST_VIOLATION")).to.be.true;});it("an Array contextActivities value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:[]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.contextActivities","MUST_VIOLATION")).to.be.true;});it("an Numeric contextActivities value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:1.23}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.contextActivities","MUST_VIOLATION")).to.be.true;});it("an empty contextActivities object value produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:{}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a single Activity parent property value produces a SHOULD warning",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:{parent:{id:"http://example.com/myOtherActivityUniqueId",objectType:"Activity"}}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.contextActivities","SHOULD_VIOLATION")).to.be.true;});it("an empty Array parent property value produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:{parent:[]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an Array with a valid Activity in the parent property produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:{parent:[{id:"http://example.com/myOtherActivityUniqueId",objectType:"Activity"}]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an Array with a invalid Activity in the parent property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},context:{contextActivities:{parent:[{objectType:"Activity"}]}}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.context.contextActivities.parent[0].id","MUST_VIOLATION")).to.be.true;});});describe("given a timestamp property on the statement",function(){it("a null value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.timestamp","MUST_VIOLATION")).to.be.true;});it("a numeric value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:1.23};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.timestamp","MUST_VIOLATION")).to.be.true;});it("a Date value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:new Date()};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.timestamp","MUST_VIOLATION")).to.be.true;});it("a String value not in ISO 8601 produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"totally wrong"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.timestamp","MUST_VIOLATION")).to.be.true;});it("a String value with ISO 8601 at UTC via Z produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15Z"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 at UTC via Z with millisecond precision produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15.008Z"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a positive timezone offset hour produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15+01"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a positive timezone offset hour and minutes produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15+01:02"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a negative timezone offset hour produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15-01"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a negative timezone offset hour and minutes produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15-01:02"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO8601 with no timezone offset or Z produces a SHOULD error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},timestamp:"2013-05-09T14:45:15"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.timestamp","SHOULD_VIOLATION")).to.be.true;});});describe("given a stored property on the statement",function(){it("a null value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.stored","MUST_VIOLATION")).to.be.true;});it("a numeric value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:1.23};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.stored","MUST_VIOLATION")).to.be.true;});it("a Date value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:new Date()};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.stored","MUST_VIOLATION")).to.be.true;});it("a String value not in ISO 8601 produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"totally wrong"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.stored","MUST_VIOLATION")).to.be.true;});it("a String value with ISO 8601 at UTC via Z produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15Z"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 at UTC via Z with millisecond precision produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15.008Z"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a positive timezone offset hour produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15+01"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a positive timezone offset hour and minutes produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15+01:02"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a negative timezone offset hour produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15-01"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO 8601 with a negative timezone offset hour and minutes produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15-01:02"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a String value with ISO8601 with no timezone offset or Z produces a SHOULD error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},stored:"2013-05-09T14:45:15"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.stored","SHOULD_VIOLATION")).to.be.true;});});describe("for a non-object authority property on the statement",function(){it("a null authority value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority","MUST_VIOLATION")).to.be.true;});it("an Array authority value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:[]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority","MUST_VIOLATION")).to.be.true;});it("an Numeric authority value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:[]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority","MUST_VIOLATION")).to.be.true;});});describe("for an authority property with an object value on the statement",function(){it("an Agent authority value produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:{objectType:"Agent",mbox:"mailto:bob@example.com"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an Agent authority value produces an error if an invalid Agent",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:{objectType:"Agent"}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority","MUST_VIOLATION")).to.be.true;});it("an Group authority value with two members produces no errors",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:{objectType:"Group",member:[{objectType:"Agent",mbox:"mailto:bob@example.com"},{objectType:"Agent",mbox:"mailto:tom@example.com"}]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an Group authority value with less than two members produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:{objectType:"Group",member:[{objectType:"Agent",mbox:"mailto:bob@example.com"}]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority.member","MUST_VIOLATION")).to.be.true;});it("an Group authority value with more than two members produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:{objectType:"Group",member:[{objectType:"Agent",mbox:"mailto:bob@example.com"},{objectType:"Agent",mbox:"mailto:tom@example.com"},{objectType:"Agent",mbox:"mailto:frank@example.com"}]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority.member","MUST_VIOLATION")).to.be.true;});it("an Group authority value with an invalid member produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},authority:{objectType:"Group",member:[{objectType:"Agent",mbox:"mailto:bob@example.com"},{objectType:"Agent"}]}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.authority.member[1]","MUST_VIOLATION")).to.be.true;});});describe("for an version property on the statement with a non-string value",function(){it("a null value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.version","MUST_VIOLATION")).to.be.true;});it("a numeric value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:1.0};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.version","MUST_VIOLATION")).to.be.true;});});describe("for an version property with a string value",function(){it("a simple semantic version produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:"1.0.0"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a semantic version with intermixed non-numbers in the major/minor/patch produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:"1.0.a"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.version","MUST_VIOLATION")).to.be.true;});it("a semantic version with valid pre-release info produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:"1.0.0-rc1"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("a semantic version with invalid pre-release info produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:"1.0.0-rc.1"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.version","MUST_VIOLATION")).to.be.true;});it("a semantic version with SemVer 2.0.0 build release info characters not in SemVer 1.0.0 produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:"1.0.0-alpha.1"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.version","MUST_VIOLATION")).to.be.true;});it("a semantic version with SemVer 2.0.0 build release metadata not in SemVer 1.0.0 produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},version:"1.0.0-alpha+001"};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.version","MUST_VIOLATION")).to.be.true;});});describe("for an attachments property on the statement with a non-Array value",function(){it("a null value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:null};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments","MUST_VIOLATION")).to.be.true;});it("a numeric value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:1.0};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments","MUST_VIOLATION")).to.be.true;});it("an object map value produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:{}};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments","MUST_VIOLATION")).to.be.true;});});describe("for an attachments property on the statement with an Array value",function(){it("an empty Array produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});});describe("for an attachment object within the attachments property's Array on the statement",function(){it("a null object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[null]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0]","MUST_VIOLATION")).to.be.true;});it("minimal valid attachment object produces no error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",0);});it("an absent usageType property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{display:{},contentType:"text/plain",length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].usageType","MUST_VIOLATION")).to.be.true;});it("a null usageType property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:null,display:{},contentType:"text/plain",length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].usageType","MUST_VIOLATION")).to.be.true;});it("a numeric usageType property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:123,display:{},contentType:"text/plain",length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].usageType","MUST_VIOLATION")).to.be.true;});it("an object usageType property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:{},display:{},contentType:"text/plain",length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].usageType","MUST_VIOLATION")).to.be.true;});it("an absent contentType property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].contentType","MUST_VIOLATION")).to.be.true;});it("a null contentType property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:null,length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].contentType","MUST_VIOLATION")).to.be.true;});it("an absent length property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].length","MUST_VIOLATION")).to.be.true;});it("a null length property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:null,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].length","MUST_VIOLATION")).to.be.true;});it("a string length property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:"11",sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].length","MUST_VIOLATION")).to.be.true;});it("a non-integer length property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:11.5,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].length","MUST_VIOLATION")).to.be.true;});it("a null sha2 property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:11,sha2:null}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].sha2","MUST_VIOLATION")).to.be.true;});it("an absent sha2 property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:11}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].sha2","MUST_VIOLATION")).to.be.true;});it("a numeric sha2 property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:11,sha2:1.23}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].sha2","MUST_VIOLATION")).to.be.true;});it("a non-base64 sha2 property object produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},contentType:"text/plain",length:11,sha2:"uses ~ - characters &^% not in base64"}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].sha2","MUST_VIOLATION")).to.be.true;});it("a null fileUrl property produces an error",function(){var inputStatement={id:"fd41c918-b88b-4b20-a0a5-a4c32391aaa0",actor:{mbox:"mailto:agent@example.com"},verb:{"id":"http://adlnet.gov/expapi/verbs/created","display":{"en-US":"created"}},object:{id:"http://example.com/myUniqueId",objectType:"Activity"},attachments:[{usageType:"http://example.com/usage/info/A",display:{},fileUrl:null,contentType:"text/plain",length:11,sha2:"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="}]};var results=xapiValidator.validateStatement(inputStatement);(0,_chai.expect)(results.errors).to.have.property("length",1);(0,_chai.expect)(reportHasErrorWithTracePrefix(results,"statement.attachments[0].fileUrl","MUST_VIOLATION")).to.be.true;});});});});});

},{"../src/xapiValidator":49,"chai":4,"underscore":41}]},{},[50])(50)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2Uvc2hvdWxkLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkQ2hhaW5hYmxlTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2ZsYWcuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRBY3R1YWwuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRFbnVtZXJhYmxlUHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldE1lc3NhZ2UuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXROYW1lLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UGF0aEluZm8uanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQYXRoVmFsdWUuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRQcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaGFzUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luc3BlY3QuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vYmpEaXNwbGF5LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90ZXN0LmpzIiwibm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxbC9saWIvZXFsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwLWVxbC9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvbGliL3R5cGUuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2xpYi90eXBlLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsInNyYy9jb25zdGFudHMvZXJyb3JzLmpzIiwic3JjL2NvbnN0YW50cy9nZW5lcmFsLmpzIiwic3JjL2NvbnN0YW50cy9pbnRlcmFjdGlvbi10eXBlcy5qcyIsInNyYy9jb25zdGFudHMvcHJvcGVydGllcy5qcyIsInNyYy9jb25zdGFudHMvcmVnZXguanMiLCJzcmMvY29uc3RhbnRzL3doaXRlbGlzdHMuanMiLCJzcmMvdXRpbHMvdXRpbHMuanMiLCJzcmMveGFwaVZhbGlkYXRvci5qcyIsInRlc3QveGFwaVZhbGlkYXRvci50ZXN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcDBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTlCLENBQXVDLGtDQUF2QyxDQUEyRSxnQkFBM0UsQ0FBUCxFQUFxRyxFQUFyRyxDQUF3RyxFQUF4RyxDQUEyRyxJQUEzRyxDQUNILENBVEQsRUFVRCxDQTFMRCxFQTJMRCxDQWxuREQsRUFtbkRELENBL21FRCxFQWduRUQsQ0FqbkVEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIVxuICogYXNzZXJ0aW9uLWVycm9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAcXVhbGlhbmN5LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb2JqZWN0IHRvIGFub3RoZXIgZXhjbHVkaW5nIGFueSBvcmlnaW5hbGx5XG4gKiBsaXN0ZWQuIFJldHVybmVkIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IGB7fWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2x1ZGVkIHByb3BlcnRpZXMgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBleGNsdWRlICgpIHtcbiAgdmFyIGV4Y2x1ZGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZ1bmN0aW9uIGV4Y2x1ZGVQcm9wcyAocmVzLCBvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF+ZXhjbHVkZXMuaW5kZXhPZihrZXkpKSByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZEV4Y2x1ZGUgKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAsIGkgPSAwXG4gICAgICAsIHJlcyA9IHt9O1xuXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNsdWRlUHJvcHMocmVzLCBhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqICMjIyBBc3NlcnRpb25FcnJvclxuICpcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgSmF2YVNjcmlwdCBgRXJyb3JgIGNvbnN0cnVjdG9yIGZvclxuICogYXNzZXJ0aW9uIGFuZCB2YWxpZGF0aW9uIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgdG8gaW5jbHVkZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge2NhbGxlZX0gc3RhcnQgc3RhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICovXG5cbmZ1bmN0aW9uIEFzc2VydGlvbkVycm9yIChtZXNzYWdlLCBfcHJvcHMsIHNzZikge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicpXG4gICAgLCBwcm9wcyA9IGV4dGVuZChfcHJvcHMgfHwge30pO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWVzXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vuc3BlY2lmaWVkIEFzc2VydGlvbkVycm9yJztcbiAgdGhpcy5zaG93RGlmZiA9IGZhbHNlO1xuXG4gIC8vIGNvcHkgZnJvbSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICAvLyBjYXB0dXJlIHN0YWNrIHRyYWNlXG4gIHNzZiA9IHNzZiB8fCBhcmd1bWVudHMuY2FsbGVlO1xuICBpZiAoc3NmICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXJyb3IucHJvdG90eXBlXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vKiFcbiAqIFN0YXRpY2FsbHkgc2V0IG5hbWVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbi8qIVxuICogRW5zdXJlIGNvcnJlY3QgY29uc3RydWN0b3JcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiBBbGxvdyBlcnJvcnMgdG8gYmUgY29udmVydGVkIHRvIEpTT04gZm9yIHN0YXRpYyB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGUgc3RhY2sgKGRlZmF1bHQ6IGB0cnVlYClcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHRoYXQgY2FuIGJlIGBKU09OLnN0cmluZ2lmeWBcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCdjb25zdHJ1Y3RvcicsICd0b0pTT04nLCAnc3RhY2snKVxuICAgICwgcHJvcHMgPSBleHRlbmQoeyBuYW1lOiB0aGlzLm5hbWUgfSwgdGhpcyk7XG5cbiAgLy8gaW5jbHVkZSBzdGFjayBpZiBleGlzdHMgYW5kIG5vdCB0dXJuZWQgb2ZmXG4gIGlmIChmYWxzZSAhPT0gc3RhY2sgJiYgdGhpcy5zdGFjaykge1xuICAgIHByb3BzLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiBiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIobGVuICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cblxuICB2YXIgTCA9IDBcblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBvdXRwdXQgPSAnJ1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPT0nXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAxMF1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9J1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpXG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoYWknKTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB1c2VkID0gW11cbiAgLCBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyohXG4gKiBDaGFpIHZlcnNpb25cbiAqL1xuXG5leHBvcnRzLnZlcnNpb24gPSAnMy41LjAnO1xuXG4vKiFcbiAqIEFzc2VydGlvbiBFcnJvclxuICovXG5cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCdhc3NlcnRpb24tZXJyb3InKTtcblxuLyohXG4gKiBVdGlscyBmb3IgcGx1Z2lucyAobm90IGV4cG9ydGVkKVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi9jaGFpL3V0aWxzJyk7XG5cbi8qKlxuICogIyAudXNlKGZ1bmN0aW9uKVxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGV4dGVuZCB0aGUgaW50ZXJuYWxzIG9mIENoYWlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQHJldHVybnMge3RoaXN9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAoIX51c2VkLmluZGV4T2YoZm4pKSB7XG4gICAgZm4odGhpcywgdXRpbCk7XG4gICAgdXNlZC5wdXNoKGZuKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBVdGlsaXR5IEZ1bmN0aW9uc1xuICovXG5cbmV4cG9ydHMudXRpbCA9IHV0aWw7XG5cbi8qIVxuICogQ29uZmlndXJhdGlvblxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NoYWkvY29uZmlnJyk7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcblxuLyohXG4gKiBQcmltYXJ5IGBBc3NlcnRpb25gIHByb3RvdHlwZVxuICovXG5cbnZhciBhc3NlcnRpb24gPSByZXF1aXJlKCcuL2NoYWkvYXNzZXJ0aW9uJyk7XG5leHBvcnRzLnVzZShhc3NlcnRpb24pO1xuXG4vKiFcbiAqIENvcmUgQXNzZXJ0aW9uc1xuICovXG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jaGFpL2NvcmUvYXNzZXJ0aW9ucycpO1xuZXhwb3J0cy51c2UoY29yZSk7XG5cbi8qIVxuICogRXhwZWN0IGludGVyZmFjZVxuICovXG5cbnZhciBleHBlY3QgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2V4cGVjdCcpO1xuZXhwb3J0cy51c2UoZXhwZWN0KTtcblxuLyohXG4gKiBTaG91bGQgaW50ZXJmYWNlXG4gKi9cblxudmFyIHNob3VsZCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2Uvc2hvdWxkJyk7XG5leHBvcnRzLnVzZShzaG91bGQpO1xuXG4vKiFcbiAqIEFzc2VydCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9hc3NlcnQnKTtcbmV4cG9ydHMudXNlKGFzc2VydCk7XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKF9jaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uRXJyb3IgPSBfY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgX2NoYWkuQXNzZXJ0aW9uID0gQXNzZXJ0aW9uO1xuXG4gIC8qIVxuICAgKiBBc3NlcnRpb24gQ29uc3RydWN0b3JcbiAgICpcbiAgICogQ3JlYXRlcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gQXNzZXJ0aW9uIChvYmosIG1zZywgc3RhY2spIHtcbiAgICBmbGFnKHRoaXMsICdzc2ZpJywgc3RhY2sgfHwgYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0Jywgb2JqKTtcbiAgICBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdpbmNsdWRlU3RhY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLmluY2x1ZGVTdGFjaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLmluY2x1ZGVTdGFjayBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuaW5jbHVkZVN0YWNrIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuaW5jbHVkZVN0YWNrID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnc2hvd0RpZmYnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5zaG93RGlmZjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQXNzZXJ0aW9uLnNob3dEaWZmIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5zaG93RGlmZiBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLnNob3dEaWZmID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZFByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwuYWRkQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlLCBleHBlY3RlZCwgYWN0dWFsLCBzaG93RGlmZilcbiAgICpcbiAgICogRXhlY3V0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgY2hlY2sgZXhwZWN0YXRpb25zLiBUaHJvd3MgQXNzZXJ0aW9uRXJyb3IgZm9yIHJlcG9ydGluZyBpZiB0ZXN0IGRvZXNuJ3QgcGFzcy5cbiAgICpcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBwYXJhbSB7UGhpbG9zb3BoaWNhbH0gZXhwcmVzc2lvbiB0byBiZSB0ZXN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG1lc3NhZ2Ugb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuZWdhdGVkTWVzc2FnZSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbmVnYXRlZE1lc3NhZ2UgdG8gZGlzcGxheSBpZiBuZWdhdGVkIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWQgdmFsdWUgKHJlbWVtYmVyIHRvIGNoZWNrIGZvciBuZWdhdGlvbilcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsIChvcHRpb25hbCkgd2lsbCBkZWZhdWx0IHRvIGB0aGlzLm9iamBcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93RGlmZiAob3B0aW9uYWwpIHdoZW4gc2V0IHRvIGB0cnVlYCwgYXNzZXJ0IHdpbGwgZGlzcGxheSBhIGRpZmYgaW4gYWRkaXRpb24gdG8gdGhlIG1lc3NhZ2UgaWYgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwciwgbXNnLCBuZWdhdGVNc2csIGV4cGVjdGVkLCBfYWN0dWFsLCBzaG93RGlmZikge1xuICAgIHZhciBvayA9IHV0aWwudGVzdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0cnVlICE9PSBzaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcbiAgICBpZiAodHJ1ZSAhPT0gY29uZmlnLnNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvaykge1xuICAgICAgdmFyIG1zZyA9IHV0aWwuZ2V0TWVzc2FnZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICwgYWN0dWFsID0gdXRpbC5nZXRBY3R1YWwodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2csIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIHNob3dEaWZmOiBzaG93RGlmZlxuICAgICAgfSwgKGNvbmZpZy5pbmNsdWRlU3RhY2spID8gdGhpcy5hc3NlcnQgOiBmbGFnKHRoaXMsICdzc2ZpJykpO1xuICAgIH1cbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5fb2JqXG4gICAqXG4gICAqIFF1aWNrIHJlZmVyZW5jZSB0byBzdG9yZWQgYGFjdHVhbGAgdmFsdWUgZm9yIHBsdWdpbiBkZXZlbG9wZXJzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsICdfb2JqJyxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgLCBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsKTtcbiAgICAgIH1cbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCwgZm9yXG4gICAqIGV4YW1wbGUgZm9yIGxhcmdlIGRhdGEgc3RydWN0dXJlcywgdGhlIHZhbHVlIGlzIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nXG4gICAqIGxpa2UgYFsgQXJyYXkoMykgXWAgb3IgYHsgT2JqZWN0IChwcm9wMSwgcHJvcDIpIH1gLlxuICAgKlxuICAgKiBTZXQgaXQgdG8gemVybyBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIHRydW5jYXRpbmcgYWx0b2dldGhlci5cbiAgICpcbiAgICogVGhpcyBpcyBlc3BlY2lhbGx5IHVzZXJmdWwgd2hlbiBkb2luZyBhc3NlcnRpb25zIG9uIGFycmF5czogaGF2aW5nIHRoaXNcbiAgICogc2V0IHRvIGEgcmVhc29uYWJsZSBsYXJnZSB2YWx1ZSBtYWtlcyB0aGUgZmFpbHVyZSBtZXNzYWdlcyByZWFkaWx5XG4gICAqIGluc3BlY3RhYmxlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgPSAwOyAgLy8gZGlzYWJsZSB0cnVuY2F0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB0cnVuY2F0ZVRocmVzaG9sZDogNDBcblxufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvXG4gICAqIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mIHlvdXIgYXNzZXJ0aW9ucy4gVGhleVxuICAgKiBkbyBub3QgcHJvdmlkZSB0ZXN0aW5nIGNhcGFiaWxpdGllcyB1bmxlc3MgdGhleVxuICAgKiBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gYnkgYSBwbHVnaW4uXG4gICAqXG4gICAqICoqQ2hhaW5zKipcbiAgICpcbiAgICogLSB0b1xuICAgKiAtIGJlXG4gICAqIC0gYmVlblxuICAgKiAtIGlzXG4gICAqIC0gdGhhdFxuICAgKiAtIHdoaWNoXG4gICAqIC0gYW5kXG4gICAqIC0gaGFzXG4gICAqIC0gaGF2ZVxuICAgKiAtIHdpdGhcbiAgICogLSBhdFxuICAgKiAtIG9mXG4gICAqIC0gc2FtZVxuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbidcbiAgLCAnaXMnLCAnYW5kJywgJ2hhcycsICdoYXZlJ1xuICAsICd3aXRoJywgJ3RoYXQnLCAnd2hpY2gnLCAnYXQnXG4gICwgJ29mJywgJ3NhbWUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBBc3NlcnRpb24uYWRkUHJvcGVydHkoY2hhaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5ub3RcbiAgICpcbiAgICogTmVnYXRlcyBhbnkgb2YgYXNzZXJ0aW9ucyBmb2xsb3dpbmcgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8ubm90LmVxdWFsKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXonIH0pLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC5hbmQubm90LmVxdWFsKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgbm90XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbm90JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lZ2F0ZScsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwXG4gICAqXG4gICAqIFNldHMgdGhlIGBkZWVwYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgZXF1YWxgIGFuZFxuICAgKiBgcHJvcGVydHlgIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5kZWVwLmVxdWFsKHsgYmFyOiAnYmF6JyB9KTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogeyBiYXI6IHsgYmF6OiAncXV1eCcgfSB9IH0pXG4gICAqICAgICAgIC50by5oYXZlLmRlZXAucHJvcGVydHkoJ2Zvby5iYXIuYmF6JywgJ3F1dXgnKTtcbiAgICpcbiAgICogYC5kZWVwLnByb3BlcnR5YCBzcGVjaWFsIGNoYXJhY3RlcnMgY2FuIGJlIGVzY2FwZWRcbiAgICogYnkgYWRkaW5nIHR3byBzbGFzaGVzIGJlZm9yZSB0aGUgYC5gIG9yIGBbXWAuXG4gICAqXG4gICAqICAgICB2YXIgZGVlcENzcyA9IHsgJy5saW5rJzogeyAnW3RhcmdldF0nOiA0MiB9fTtcbiAgICogICAgIGV4cGVjdChkZWVwQ3NzKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1xcXFwubGluay5cXFxcW3RhcmdldFxcXFxdJywgNDIpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZGVlcCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdkZWVwJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFueVxuICAgKlxuICAgKiBTZXRzIHRoZSBgYW55YCBmbGFnLCAob3Bwb3NpdGUgb2YgdGhlIGBhbGxgIGZsYWcpXG4gICAqIGxhdGVyIHVzZWQgaW4gdGhlIGBrZXlzYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5oYXZlLmFueS5rZXlzKCdiYXInLCAnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIGFueVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FueScsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdhbnknLCB0cnVlKTtcbiAgICBmbGFnKHRoaXMsICdhbGwnLCBmYWxzZSlcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5hbGxcbiAgICpcbiAgICogU2V0cyB0aGUgYGFsbGAgZmxhZyAob3Bwb3NpdGUgb2YgdGhlIGBhbnlgIGZsYWcpXG4gICAqIGxhdGVyIHVzZWQgYnkgdGhlIGBrZXlzYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5oYXZlLmFsbC5rZXlzKCdiYXInLCAnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIGFsbFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdhbGwnLCB0cnVlKTtcbiAgICBmbGFnKHRoaXMsICdhbnknLCBmYWxzZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmEodHlwZSlcbiAgICpcbiAgICogVGhlIGBhYCBhbmQgYGFuYCBhc3NlcnRpb25zIGFyZSBhbGlhc2VzIHRoYXQgY2FuIGJlXG4gICAqIHVzZWQgZWl0aGVyIGFzIGxhbmd1YWdlIGNoYWlucyBvciB0byBhc3NlcnQgYSB2YWx1ZSdzXG4gICAqIHR5cGUuXG4gICAqXG4gICAqICAgICAvLyB0eXBlb2ZcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmJlLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5iZS5hbignb2JqZWN0Jyk7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUuYSgnbnVsbCcpO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUuYW4oJ3VuZGVmaW5lZCcpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBFcnJvcikudG8uYmUuYW4oJ2Vycm9yJyk7XG4gICAqICAgICBleHBlY3QobmV3IFByb21pc2UpLnRvLmJlLmEoJ3Byb21pc2UnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRmxvYXQzMkFycmF5KCkpLnRvLmJlLmEoJ2Zsb2F0MzJhcnJheScpO1xuICAgKiAgICAgZXhwZWN0KFN5bWJvbCgpKS50by5iZS5hKCdzeW1ib2wnKTtcbiAgICpcbiAgICogICAgIC8vIGVzNiBvdmVycmlkZXNcbiAgICogICAgIGV4cGVjdCh7W1N5bWJvbC50b1N0cmluZ1RhZ106KCk9Pidmb28nfSkudG8uYmUuYSgnZm9vJyk7XG4gICAqXG4gICAqICAgICAvLyBsYW5ndWFnZSBjaGFpblxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uYmUuYW4uaW5zdGFuY2VvZihGb28pO1xuICAgKlxuICAgKiBAbmFtZSBhXG4gICAqIEBhbGlhcyBhblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFuICh0eXBlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBhcnRpY2xlID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHR5cGUuY2hhckF0KDApKSA/ICdhbiAnIDogJ2EgJztcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlID09PSBfLnR5cGUob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbicsIGFuKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYScsIGFuKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKHZhbHVlKVxuICAgKlxuICAgKiBUaGUgYGluY2x1ZGVgIGFuZCBgY29udGFpbmAgYXNzZXJ0aW9ucyBjYW4gYmUgdXNlZCBhcyBlaXRoZXIgcHJvcGVydHlcbiAgICogYmFzZWQgbGFuZ3VhZ2UgY2hhaW5zIG9yIGFzIG1ldGhvZHMgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYW4gb2JqZWN0XG4gICAqIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLiBXaGVuIHVzZWQgYXMgbGFuZ3VhZ2UgY2hhaW5zLFxuICAgKiB0aGV5IHRvZ2dsZSB0aGUgYGNvbnRhaW5zYCBmbGFnIGZvciB0aGUgYGtleXNgIGFzc2VydGlvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwyLDNdKS50by5pbmNsdWRlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5jb250YWluKCdmb28nKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicsIGhlbGxvOiAndW5pdmVyc2UnIH0pLnRvLmluY2x1ZGUua2V5cygnZm9vJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQGFsaWFzIGNvbnRhaW5cbiAgICogQGFsaWFzIGluY2x1ZGVzXG4gICAqIEBhbGlhcyBjb250YWluc1xuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TnVtYmVyfSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgZmxhZyh0aGlzLCAnY29udGFpbnMnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCwgbXNnKSB7XG4gICAgXy5leHBlY3RUeXBlcyh0aGlzLCBbJ2FycmF5JywgJ29iamVjdCcsICdzdHJpbmcnXSk7XG5cbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoXy50eXBlKG9iaikgPT09ICdhcnJheScgJiYgXy50eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoXy5lcWwob2JqW2ldLCB2YWwpKSB7XG4gICAgICAgICAgZXhwZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLnR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghZmxhZyh0aGlzLCAnbmVnYXRlJykpIHtcbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWwpIG5ldyBBc3NlcnRpb24ob2JqKS5wcm9wZXJ0eShrLCB2YWxba10pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3Vic2V0ID0ge307XG4gICAgICBmb3IgKHZhciBrIGluIHZhbCkgc3Vic2V0W2tdID0gb2JqW2tdO1xuICAgICAgZXhwZWN0ZWQgPSBfLmVxbChzdWJzZXQsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGVjdGVkID0gKG9iaiAhPSB1bmRlZmluZWQpICYmIH5vYmouaW5kZXhPZih2YWwpO1xuICAgIH1cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZXhwZWN0ZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGluY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY2x1ZGUnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2NvbnRhaW4nLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2NvbnRhaW5zJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlcycsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcblxuICAvKipcbiAgICogIyMjIC5va1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2V2ZXJ5dGhpbmcnKS50by5iZS5vaztcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vaztcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8ubm90LmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS5vaztcbiAgICpcbiAgICogQG5hbWUgb2tcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdvaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1dGh5J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzeScpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC50cnVlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGB0cnVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS50cnVlO1xuICAgKlxuICAgKiBAbmFtZSB0cnVlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndHJ1ZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc2UnXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZmFsc2VcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7XG4gICAqICAgICBleHBlY3QoMCkudG8ubm90LmJlLmZhbHNlO1xuICAgKlxuICAgKiBAbmFtZSBmYWxzZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZhbHNlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmYWxzZSA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc2UnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsIHRoaXMubmVnYXRlID8gdHJ1ZSA6IGZhbHNlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubnVsbFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgbnVsbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5udWxsO1xuICAgKlxuICAgKiBAbmFtZSBudWxsXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbnVsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgbnVsbCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIG51bGwnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudW5kZWZpbmVkXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUudW5kZWZpbmVkO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS51bmRlZmluZWQ7XG4gICAqXG4gICAqIEBuYW1lIHVuZGVmaW5lZFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3VuZGVmaW5lZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdW5kZWZpbmVkID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB1bmRlZmluZWQnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSB1bmRlZmluZWQnXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuTmFOXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBOYU5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5OYU47XG4gICAqICAgICBleHBlY3QoNCkubm90LnRvLmJlLk5hTjtcbiAgICpcbiAgICogQG5hbWUgTmFOXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnTmFOJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc05hTihmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBOYU4nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIE5hTidcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJ1xuICAgKiAgICAgICAsIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXIpLnRvLm5vdC5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXopLnRvLm5vdC5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCAhPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBsZW5ndGggaXMgYDBgLiBGb3IgYXJyYXlzIGFuZCBzdHJpbmdzLCBpdCBjaGVja3NcbiAgICogdGhlIGBsZW5ndGhgIHByb3BlcnR5LiBGb3Igb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2ZcbiAgICogZW51bWVyYWJsZSBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBleHBlY3RlZCA9IG9iajtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBleHBlY3RlZCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAhZXhwZWN0ZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYXJndW1lbnRzIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnW29iamVjdCBBcmd1bWVudHNdJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IGVxdWFsIChgPT09YCkgdG8gYHZhbHVlYC5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdoZWxsbycpLnRvLmVxdWFsKCdoZWxsbycpO1xuICAgKiAgICAgZXhwZWN0KDQyKS50by5lcXVhbCg0Mik7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmVxdWFsKHRydWUpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5ub3QuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5kZWVwLmVxdWFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQGFsaWFzIGVxdWFsc1xuICAgKiBAYWxpYXMgZXFcbiAgICogQGFsaWFzIGRlZXAuZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RlZXAnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXFsKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gb2JqXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdGhpcy5fb2JqXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbCcsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWxzJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcScsIGFzc2VydEVxdWFsKTtcblxuICAvKipcbiAgICogIyMjIC5lcWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5lcWwoWyAxLCAyLCAzIF0pO1xuICAgKlxuICAgKiBAbmFtZSBlcWxcbiAgICogQGFsaWFzIGVxbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcWwob2JqLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5lcWwob2JqLCBmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsIG9ialxuICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWwnLCBhc3NlcnRFcWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWxzJywgYXNzZXJ0RXFsKTtcblxuICAvKipcbiAgICogIyMjIC5hYm92ZSh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmFib3ZlKDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWluaW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICpcbiAgICogQG5hbWUgYWJvdmVcbiAgICogQGFsaWFzIGd0XG4gICAqIEBhbGlhcyBncmVhdGVyVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEwKS50by5iZS5hdC5sZWFzdCgxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0LmxlYXN0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJlbG93KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5iZWxvdygxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtYXhpbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2JlbG93JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdCcsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVzc1RoYW4nLCBhc3NlcnRCZWxvdyk7XG5cbiAgLyoqXG4gICAqICMjIyAubW9zdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNSkudG8uYmUuYXQubW9zdCg1KTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TW9zdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21vc3QnLCBhc3NlcnRNb3N0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHRlJywgYXNzZXJ0TW9zdCk7XG5cbiAgLyoqXG4gICAqICMjIyAud2l0aGluKHN0YXJ0LCBmaW5pc2gpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHdpdGhpbiBhIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDcpLnRvLmJlLndpdGhpbig1LDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIGxlbmd0aCByYW5nZS4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSB3aXRoaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHJhbmdlID0gc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID49IHN0YXJ0ICYmIGxlbiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gc3RhcnQgJiYgb2JqIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlb2YoY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIENoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2hhaSkudG8uYmUuYW4uaW5zdGFuY2VvZihUZWEpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5iZS5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgbmFtZSA9IF8uZ2V0TmFtZShjb25zdHJ1Y3Rvcik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lLCBbdmFsdWVdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSBgbmFtZWAsIG9wdGlvbmFsbHkgYXNzZXJ0aW5nIHRoYXRcbiAgICogdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gIGB2YWx1ZWAuXG4gICAqIElmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHlvdSBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlcyBpbnRvIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIG9iaiA9IHsgZm9vOiAnYmFyJyB9O1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqICAgICAvLyBkZWVwIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgZGVlcE9iaiA9IHtcbiAgICogICAgICAgICBncmVlbjogeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgLCB0ZWFzOiBbICdjaGFpJywgJ21hdGNoYScsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnZ3JlZW4udGVhJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgndGVhc1sxXScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3RlYXNbMl0udGVhJywgJ2tvbmFjaGEnKTtcbiAgICpcbiAgICogWW91IGNhbiBhbHNvIHVzZSBhbiBhcnJheSBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgYSBgZGVlcC5wcm9wZXJ0eWBcbiAgICogYXNzZXJ0aW9uLCBvciB0cmF2ZXJzZSBuZXN0ZWQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgdmFyIGFyciA9IFtcbiAgICogICAgICAgICBbICdjaGFpJywgJ21hdGNoYScsICdrb25hY2hhJyBdXG4gICAqICAgICAgICwgWyB7IHRlYTogJ2NoYWknIH1cbiAgICogICAgICAgICAsIHsgdGVhOiAnbWF0Y2hhJyB9XG4gICAqICAgICAgICAgLCB7IHRlYTogJ2tvbmFjaGEnIH0gXVxuICAgKiAgICAgXTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhcnIpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnWzBdWzFdJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGFycikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdbMV1bMl0udGVhJywgJ2tvbmFjaGEnKTtcbiAgICpcbiAgICogRnVydGhlcm1vcmUsIGBwcm9wZXJ0eWAgY2hhbmdlcyB0aGUgc3ViamVjdCBvZiB0aGUgYXNzZXJ0aW9uXG4gICAqIHRvIGJlIHRoZSB2YWx1ZSBvZiB0aGF0IHByb3BlcnR5IGZyb20gdGhlIG9yaWdpbmFsIG9iamVjdC4gVGhpc1xuICAgKiBwZXJtaXRzIGZvciBmdXJ0aGVyIGNoYWluYWJsZSBhc3NlcnRpb25zIG9uIHRoYXQgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nKVxuICAgKiAgICAgICAudGhhdC5pcy5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLnByb3BlcnR5KCdncmVlbicpXG4gICAqICAgICAgIC50aGF0LmlzLmFuKCdvYmplY3QnKVxuICAgKiAgICAgICAudGhhdC5kZWVwLmVxdWFscyh7IHRlYTogJ21hdGNoYScgfSk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5wcm9wZXJ0eSgndGVhcycpXG4gICAqICAgICAgIC50aGF0LmlzLmFuKCdhcnJheScpXG4gICAqICAgICAgIC53aXRoLmRlZXAucHJvcGVydHkoJ1syXScpXG4gICAqICAgICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoeyB0ZWE6ICdrb25hY2hhJyB9KTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGRvdHMgYW5kIGJyYWNrZXQgaW4gYG5hbWVgIG11c3QgYmUgYmFja3NsYXNoLWVzY2FwZWQgd2hlblxuICAgKiB0aGUgYGRlZXBgIGZsYWcgaXMgc2V0LCB3aGlsZSB0aGV5IG11c3QgTk9UIGJlIGVzY2FwZWQgd2hlbiB0aGUgYGRlZXBgXG4gICAqIGZsYWcgaXMgbm90IHNldC5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIGNzcyA9IHsgJy5saW5rW3RhcmdldF0nOiA0MiB9O1xuICAgKiAgICAgZXhwZWN0KGNzcykudG8uaGF2ZS5wcm9wZXJ0eSgnLmxpbmtbdGFyZ2V0XScsIDQyKTtcbiAgICpcbiAgICogICAgIC8vIGRlZXAgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBkZWVwQ3NzID0geyAnLmxpbmsnOiB7ICdbdGFyZ2V0XSc6IDQyIH19O1xuICAgKiAgICAgZXhwZWN0KGRlZXBDc3MpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnXFxcXC5saW5rLlxcXFxbdGFyZ2V0XFxcXF0nLCA0Mik7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBhbGlhcyBkZWVwLnByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBmdW5jdGlvbiAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBpc0RlZXAgPSAhIWZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgLCBkZXNjcmlwdG9yID0gaXNEZWVwID8gJ2RlZXAgcHJvcGVydHkgJyA6ICdwcm9wZXJ0eSAnXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHBhdGhJbmZvID0gaXNEZWVwID8gXy5nZXRQYXRoSW5mbyhuYW1lLCBvYmopIDogbnVsbFxuICAgICAgLCBoYXNQcm9wZXJ0eSA9IGlzRGVlcFxuICAgICAgICA/IHBhdGhJbmZvLmV4aXN0c1xuICAgICAgICA6IF8uaGFzUHJvcGVydHkobmFtZSwgb2JqKVxuICAgICAgLCB2YWx1ZSA9IGlzRGVlcFxuICAgICAgICA/IHBhdGhJbmZvLnZhbHVlXG4gICAgICAgIDogb2JqW25hbWVdO1xuXG4gICAgaWYgKG5lZ2F0ZSAmJiBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgbXNnID0gKG1zZyAhPSBudWxsKSA/IG1zZyArICc6ICcgOiAnJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyArIF8uaW5zcGVjdChvYmopICsgJyBoYXMgbm8gJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBoYXNQcm9wZXJ0eVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShuYW1lKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYW4gb3duIHByb3BlcnR5IGBuYW1lYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eURlc2NyaXB0b3IobmFtZVssIGRlc2NyaXB0b3JbLCBtZXNzYWdlXV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBgbmFtZWAsIHRoYXQgb3B0aW9uYWxseSBtYXRjaGVzIGBkZXNjcmlwdG9yYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnKTtcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiA0IH0pO1xuICAgKiAgICAgZXhwZWN0KCd0ZXN0Jykubm90LnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiAzIH0pO1xuICAgKiAgICAgZXhwZWN0KCd0ZXN0Jykub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnKS50by5oYXZlLnByb3BlcnR5KCdlbnVtZXJhYmxlJywgZmFsc2UpO1xuICAgKiAgICAgZXhwZWN0KCd0ZXN0Jykub3duUHJvcGVydHlEZXNjcmlwdG9yKCdsZW5ndGgnKS50by5oYXZlLmtleXMoJ3ZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5RGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRvciBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yIChuYW1lLCBkZXNjcmlwdG9yLCBtc2cpIHtcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBkZXNjcmlwdG9yO1xuICAgICAgZGVzY3JpcHRvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB2YXIgYWN0dWFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iaiksIG5hbWUpO1xuICAgIGlmIChhY3R1YWxEZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIF8uZXFsKGRlc2NyaXB0b3IsIGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpICsgJywgZ290ICcgKyBfLmluc3BlY3QoYWN0dWFsRGVzY3JpcHRvcilcbiAgICAgICAgLCAnZXhwZWN0ZWQgdGhlIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvbiAje3RoaXN9IHRvIG5vdCBtYXRjaCAnICsgXy5pbnNwZWN0KGRlc2NyaXB0b3IpXG4gICAgICAgICwgZGVzY3JpcHRvclxuICAgICAgICAsIGFjdHVhbERlc2NyaXB0b3JcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGFuIG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICApO1xuICAgIH1cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBhY3R1YWxEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5RGVzY3JpcHRvcicsIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvcik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aFxuICAgKlxuICAgKiBTZXRzIHRoZSBgZG9MZW5ndGhgIGZsYWcgbGF0ZXIgdXNlZCBhcyBhIGNoYWluIHByZWN1cnNvciB0byBhIHZhbHVlXG4gICAqIGNvbXBhcmlzb24gZm9yIHRoZSBgbGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogKkRlcHJlY2F0aW9uIG5vdGljZToqIFVzaW5nIGBsZW5ndGhgIGFzIGFuIGFzc2VydGlvbiB3aWxsIGJlIGRlcHJlY2F0ZWRcbiAgICogaW4gdmVyc2lvbiAyLjQuMCBhbmQgcmVtb3ZlZCBpbiAzLjAuMC4gQ29kZSB1c2luZyB0aGUgb2xkIHN0eWxlIG9mXG4gICAqIGFzc2VydGluZyBmb3IgYGxlbmd0aGAgcHJvcGVydHkgdmFsdWUgdXNpbmcgYGxlbmd0aCh2YWx1ZSlgIHNob3VsZCBiZVxuICAgKiBzd2l0Y2hlZCB0byB1c2UgYGxlbmd0aE9mKHZhbHVlKWAgaW5zdGVhZC5cbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKHZhbHVlWywgbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaGFzXG4gICAqIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLmxlbmd0aE9mKDYpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoQ2hhaW4gKCkge1xuICAgIGZsYWcodGhpcywgJ2RvTGVuZ3RoJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGggKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsZW4gPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGxlblxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHJlZ2V4cClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgbWF0Y2hlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubWF0Y2goL15mb28vKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQGFsaWFzIG1hdGNoZXNcbiAgICogQHBhcmFtIHtSZWdFeHB9IFJlZ3VsYXJFeHByZXNzaW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydE1hdGNoKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaCcsIGFzc2VydE1hdGNoKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2hlcycsIGFzc2VydE1hdGNoKTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpbmcoc3RyaW5nKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHN0cmluZyB0YXJnZXQgY29udGFpbnMgYW5vdGhlciBzdHJpbmcuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzdHJpbmcnLCBmdW5jdGlvbiAoc3RyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnc3RyaW5nJyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgfm9iai5pbmRleE9mKHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5rZXlzKGtleTEsIFtrZXkyXSwgWy4uLl0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGNvbnRhaW5zIGFueSBvciBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzLlxuICAgKiBVc2UgaW4gY29tYmluYXRpb24gd2l0aCBgYW55YCwgYGFsbGAsIGBjb250YWluc2AsIG9yIGBoYXZlYCB3aWxsIGFmZmVjdFxuICAgKiB3aGF0IHdpbGwgcGFzcy5cbiAgICpcbiAgICogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGFueWAsIGF0IGxlYXN0IG9uZSBrZXkgdGhhdCBpcyBwYXNzZWRcbiAgICogaW4gbXVzdCBleGlzdCBpbiB0aGUgdGFyZ2V0IG9iamVjdC4gVGhpcyBpcyByZWdhcmRsZXNzIHdoZXRoZXIgb3Igbm90XG4gICAqIHRoZSBgaGF2ZWAgb3IgYGNvbnRhaW5gIHF1YWxpZmllcnMgYXJlIHVzZWQuIE5vdGUsIGVpdGhlciBgYW55YCBvciBgYWxsYFxuICAgKiBzaG91bGQgYmUgdXNlZCBpbiB0aGUgYXNzZXJ0aW9uLiBJZiBuZWl0aGVyIGFyZSB1c2VkLCB0aGUgYXNzZXJ0aW9uIGlzXG4gICAqIGRlZmF1bHRlZCB0byBgYWxsYC5cbiAgICpcbiAgICogV2hlbiBib3RoIGBhbGxgIGFuZCBgY29udGFpbmAgYXJlIHVzZWQsIHRoZSB0YXJnZXQgb2JqZWN0IG11c3QgaGF2ZSBhdFxuICAgKiBsZWFzdCBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzIGJ1dCBtYXkgaGF2ZSBtb3JlIGtleXMgbm90IGxpc3RlZC5cbiAgICpcbiAgICogV2hlbiBib3RoIGBhbGxgIGFuZCBgaGF2ZWAgYXJlIHVzZWQsIHRoZSB0YXJnZXQgb2JqZWN0IG11c3QgYm90aCBjb250YWluXG4gICAqIGFsbCBvZiB0aGUgcGFzc2VkLWluIGtleXMgQU5EIHRoZSBudW1iZXIgb2Yga2V5cyBpbiB0aGUgdGFyZ2V0IG9iamVjdCBtdXN0XG4gICAqIG1hdGNoIHRoZSBudW1iZXIgb2Yga2V5cyBwYXNzZWQgaW4gKGluIG90aGVyIHdvcmRzLCBhIHRhcmdldCBvYmplY3QgbXVzdFxuICAgKiBoYXZlIGFsbCBhbmQgb25seSBhbGwgb2YgdGhlIHBhc3NlZC1pbiBrZXlzKS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUuYW55LmtleXMoJ2ZvbycsICdiYXonKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUuYW55LmtleXMoJ2ZvbycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIgfSkudG8uY29udGFpbi5hbnkua2V5cygnYmFyJywgJ2JheicpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIgfSkudG8uY29udGFpbi5hbnkua2V5cyhbJ2ZvbyddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmNvbnRhaW4uYW55LmtleXMoeydmb28nOiA2fSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmFsbC5rZXlzKFsnYmFyJywgJ2ZvbyddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyIH0pLnRvLmhhdmUuYWxsLmtleXMoeydiYXInOiA2LCAnZm9vJzogN30pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9KS50by5jb250YWluLmFsbC5rZXlzKFsnYmFyJywgJ2ZvbyddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyLCBiYXo6IDMgfSkudG8uY29udGFpbi5hbGwua2V5cyh7J2Jhcic6IDZ9KTtcbiAgICpcbiAgICpcbiAgICogQG5hbWUga2V5c1xuICAgKiBAYWxpYXMga2V5XG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfEFycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRLZXlzIChrZXlzKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHN0clxuICAgICAgLCBvayA9IHRydWVcbiAgICAgICwgbWl4ZWRBcmdzTXNnID0gJ2tleXMgbXVzdCBiZSBnaXZlbiBzaW5nbGUgYXJndW1lbnQgb2YgQXJyYXl8T2JqZWN0fFN0cmluZywgb3IgbXVsdGlwbGUgU3RyaW5nIGFyZ3VtZW50cyc7XG5cbiAgICBzd2l0Y2ggKF8udHlwZShrZXlzKSkge1xuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgdGhyb3cgKG5ldyBFcnJvcihtaXhlZEFyZ3NNc2cpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgdGhyb3cgKG5ldyBFcnJvcihtaXhlZEFyZ3NNc2cpKTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGtleXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICgha2V5cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigna2V5cyByZXF1aXJlZCcpO1xuXG4gICAgdmFyIGFjdHVhbCA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICwgZXhwZWN0ZWQgPSBrZXlzXG4gICAgICAsIGxlbiA9IGtleXMubGVuZ3RoXG4gICAgICAsIGFueSA9IGZsYWcodGhpcywgJ2FueScpXG4gICAgICAsIGFsbCA9IGZsYWcodGhpcywgJ2FsbCcpO1xuXG4gICAgaWYgKCFhbnkgJiYgIWFsbCkge1xuICAgICAgYWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBIYXMgYW55XG4gICAgaWYgKGFueSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGV4cGVjdGVkLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgICAgfSk7XG4gICAgICBvayA9IGludGVyc2VjdGlvbi5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8vIEhhcyBhbGxcbiAgICBpZiAoYWxsKSB7XG4gICAgICBvayA9IGtleXMuZXZlcnkoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpICYmICFmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICAgIG9rID0gb2sgJiYga2V5cy5sZW5ndGggPT0gYWN0dWFsLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBLZXkgc3RyaW5nXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIGtleXMgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpe1xuICAgICAgICByZXR1cm4gXy5pbnNwZWN0KGtleSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0ga2V5cy5wb3AoKTtcbiAgICAgIGlmIChhbGwpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgICAgfVxuICAgICAgaWYgKGFueSkge1xuICAgICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBvciAnICsgbGFzdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gXy5pbnNwZWN0KGtleXNbMF0pO1xuICAgIH1cblxuICAgIC8vIEZvcm1cbiAgICBzdHIgPSAobGVuID4gMSA/ICdrZXlzICcgOiAna2V5ICcpICsgc3RyO1xuXG4gICAgLy8gSGF2ZSAvIGluY2x1ZGVcbiAgICBzdHIgPSAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSA/ICdjb250YWluICcgOiAnaGF2ZSAnKSArIHN0cjtcblxuICAgIC8vIEFzc2VydGlvblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBva1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgc3RyXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCAnICsgc3RyXG4gICAgICAsIGV4cGVjdGVkLnNsaWNlKDApLnNvcnQoKVxuICAgICAgLCBhY3R1YWwuc29ydCgpXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5cycsIGFzc2VydEtleXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXknLCBhc3NlcnRLZXlzKTtcblxuICAvKipcbiAgICogIyMjIC50aHJvdyhjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBmdW5jdGlvbiB0YXJnZXQgd2lsbCB0aHJvdyBhIHNwZWNpZmljIGVycm9yLCBvciBzcGVjaWZpYyB0eXBlIG9mIGVycm9yXG4gICAqIChhcyBkZXRlcm1pbmVkIHVzaW5nIGBpbnN0YW5jZW9mYCksIG9wdGlvbmFsbHkgd2l0aCBhIFJlZ0V4cCBvciBzdHJpbmcgaW5jbHVzaW9uIHRlc3RcbiAgICogZm9yIHRoZSBlcnJvcidzIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFJlZmVyZW5jZUVycm9yKCdUaGlzIGlzIGEgYmFkIGZ1bmN0aW9uLicpO1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KCdnb29kIGZ1bmN0aW9uJyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yLCAvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KGVycik7XG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgd2hlbiBhIHRocm93IGV4cGVjdGF0aW9uIGlzIG5lZ2F0ZWQsIGl0IHdpbGwgY2hlY2sgZWFjaFxuICAgKiBwYXJhbWV0ZXIgaW5kZXBlbmRlbnRseSwgc3RhcnRpbmcgd2l0aCBlcnJvciBjb25zdHJ1Y3RvciB0eXBlLiBUaGUgYXBwcm9wcmlhdGUgd2F5XG4gICAqIHRvIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgdHlwZSBvZiBlcnJvciBidXQgZm9yIGEgbWVzc2FnZSB0aGF0IGRvZXMgbm90IG1hdGNoXG4gICAqIGlzIHRvIHVzZSBgYW5kYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpXG4gICAqICAgICAgICAuYW5kLm5vdC50aHJvdygvZ29vZCBmdW5jdGlvbi8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd1xuICAgKiBAYWxpYXMgdGhyb3dzXG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXhwZWN0ZWQgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQHJldHVybnMgZXJyb3IgZm9yIGNoYWluaW5nIChudWxsIGlmIG5vIGVycm9yKVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRUaHJvd3MgKGNvbnN0cnVjdG9yLCBlcnJNc2csIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIHRocm93biA9IGZhbHNlXG4gICAgICAsIGRlc2lyZWRFcnJvciA9IG51bGxcbiAgICAgICwgbmFtZSA9IG51bGxcbiAgICAgICwgdGhyb3duRXJyb3IgPSBudWxsO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGVyck1zZyA9IG51bGw7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBSZWdFeHAgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgIGVyck1zZyA9IGNvbnN0cnVjdG9yO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZGVzaXJlZEVycm9yID0gY29uc3RydWN0b3I7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICBlcnJNc2cgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBuYW1lID0gY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWU7XG4gICAgICBpZiAoIW5hbWUgfHwgKG5hbWUgPT09ICdFcnJvcicgJiYgY29uc3RydWN0b3IgIT09IEVycm9yKSkge1xuICAgICAgICBuYW1lID0gY29uc3RydWN0b3IubmFtZSB8fCAobmV3IGNvbnN0cnVjdG9yKCkpLm5hbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgb2JqKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgZGVzaXJlZCBlcnJvclxuICAgICAgaWYgKGRlc2lyZWRFcnJvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciA9PT0gZGVzaXJlZEVycm9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSdcbiAgICAgICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgbmFtZVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFlcnJNc2cpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIG1lc3NhZ2VcbiAgICAgIHZhciBtZXNzYWdlID0gJ2Vycm9yJyA9PT0gXy50eXBlKGVycikgJiYgXCJtZXNzYWdlXCIgaW4gZXJyXG4gICAgICAgID8gZXJyLm1lc3NhZ2VcbiAgICAgICAgOiAnJyArIGVycjtcblxuICAgICAgaWYgKChtZXNzYWdlICE9IG51bGwpICYmIGVyck1zZyAmJiBlcnJNc2cgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnJNc2cuZXhlYyhtZXNzYWdlKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgbWF0Y2hpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IG1hdGNoaW5nICN7ZXhwfSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgJ3N0cmluZycgPT09IHR5cGVvZiBlcnJNc2cpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICB+bWVzc2FnZS5pbmRleE9mKGVyck1zZylcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIGluY2x1ZGluZyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBub3QgaW5jbHVkaW5nICN7YWN0fSdcbiAgICAgICAgICAsIGVyck1zZ1xuICAgICAgICAgICwgbWVzc2FnZVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3duID0gdHJ1ZTtcbiAgICAgICAgdGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFjdHVhbGx5R290ID0gJydcbiAgICAgICwgZXhwZWN0ZWRUaHJvd24gPSBuYW1lICE9PSBudWxsXG4gICAgICAgID8gbmFtZVxuICAgICAgICA6IGRlc2lyZWRFcnJvclxuICAgICAgICAgID8gJyN7ZXhwfScgLy9fLmluc3BlY3QoZGVzaXJlZEVycm9yKVxuICAgICAgICAgIDogJ2FuIGVycm9yJztcblxuICAgIGlmICh0aHJvd24pIHtcbiAgICAgIGFjdHVhbGx5R290ID0gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRocm93biA9PT0gdHJ1ZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAnICsgZXhwZWN0ZWRUaHJvd24gKyBhY3R1YWxseUdvdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgKGRlc2lyZWRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZGVzaXJlZEVycm9yLnRvU3RyaW5nKCkgOiBkZXNpcmVkRXJyb3IpXG4gICAgICAsICh0aHJvd25FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdGhyb3duRXJyb3IudG9TdHJpbmcoKSA6IHRocm93bkVycm9yKVxuICAgICk7XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB0aHJvd25FcnJvcik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvd3MnLCBhc3NlcnRUaHJvd3MpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdUaHJvdycsIGFzc2VydFRocm93cyk7XG5cbiAgLyoqXG4gICAqICMjIyAucmVzcG9uZFRvKG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBvYmplY3Qgb3IgY2xhc3MgdGFyZ2V0IHdpbGwgcmVzcG9uZCB0byBhIG1ldGhvZC5cbiAgICpcbiAgICogICAgIEtsYXNzLnByb3RvdHlwZS5iYXIgPSBmdW5jdGlvbigpe307XG4gICAqICAgICBleHBlY3QoS2xhc3MpLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKlxuICAgKiBUbyBjaGVjayBpZiBhIGNvbnN0cnVjdG9yIHdpbGwgcmVzcG9uZCB0byBhIHN0YXRpYyBmdW5jdGlvbixcbiAgICogc2V0IHRoZSBgaXRzZWxmYCBmbGFnLlxuICAgKlxuICAgKiAgICAgS2xhc3MuYmF6ID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgcmVzcG9uZFRvXG4gICAqIEBhbGlhcyByZXNwb25kc1RvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiByZXNwb25kVG8gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gXy50eXBlKG9iaikgJiYgIWl0c2VsZilcbiAgICAgICAgPyBvYmoucHJvdG90eXBlW21ldGhvZF1cbiAgICAgICAgOiBvYmpbbWV0aG9kXTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udGV4dFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZFRvJywgcmVzcG9uZFRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZHNUbycsIHJlc3BvbmRUbyk7XG5cbiAgLyoqXG4gICAqICMjIyAuaXRzZWxmXG4gICAqXG4gICAqIFNldHMgdGhlIGBpdHNlbGZgIGZsYWcsIGxhdGVyIHVzZWQgYnkgdGhlIGByZXNwb25kVG9gIGFzc2VydGlvbi5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIEZvbygpIHt9XG4gICAqICAgICBGb28uYmFyID0gZnVuY3Rpb24oKSB7fVxuICAgKiAgICAgRm9vLnByb3RvdHlwZS5iYXogPSBmdW5jdGlvbigpIHt9XG4gICAqXG4gICAqICAgICBleHBlY3QoRm9vKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChGb28pLml0c2VsZi5ub3QudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgaXRzZWxmXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnaXRzZWxmJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2l0c2VsZicsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zYXRpc2Z5KG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgcGFzc2VzIGEgZ2l2ZW4gdHJ1dGggdGVzdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtID4gMDsgfSk7XG4gICAqXG4gICAqIEBuYW1lIHNhdGlzZnlcbiAgICogQGFsaWFzIHNhdGlzZmllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gc2F0aXNmeSAobWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciByZXN1bHQgPSBtYXRjaGVyKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIHJlc3VsdFxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzYXRpc2Z5Jywgc2F0aXNmeSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZmllcycsIHNhdGlzZnkpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAYWxpYXMgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xvc2VUbyhleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ251bWJlcicpO1xuICAgIGlmIChfLnR5cGUoZXhwZWN0ZWQpICE9PSAnbnVtYmVyJyB8fCBfLnR5cGUoZGVsdGEpICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXJndW1lbnRzIHRvIGNsb3NlVG8gb3IgYXBwcm94aW1hdGVseSBtdXN0IGJlIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Nsb3NlVG8nLCBjbG9zZVRvKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYXBwcm94aW1hdGVseScsIGNsb3NlVG8pO1xuXG4gIGZ1bmN0aW9uIGlzU3Vic2V0T2Yoc3Vic2V0LCBzdXBlcnNldCwgY21wKSB7XG4gICAgcmV0dXJuIHN1YnNldC5ldmVyeShmdW5jdGlvbihlbGVtKSB7XG4gICAgICBpZiAoIWNtcCkgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YoZWxlbSkgIT09IC0xO1xuXG4gICAgICByZXR1cm4gc3VwZXJzZXQuc29tZShmdW5jdGlvbihlbGVtMikge1xuICAgICAgICByZXR1cm4gY21wKGVsZW0sIGVsZW0yKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogIyMjIC5tZW1iZXJzKHNldClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBzdXBlcnNldCBvZiBgc2V0YCxcbiAgICogb3IgdGhhdCB0aGUgdGFyZ2V0IGFuZCBgc2V0YCBoYXZlIHRoZSBzYW1lIHN0cmljdGx5LWVxdWFsICg9PT0pIG1lbWJlcnMuXG4gICAqIEFsdGVybmF0ZWx5LCBpZiB0aGUgYGRlZXBgIGZsYWcgaXMgc2V0LCBzZXQgbWVtYmVycyBhcmUgY29tcGFyZWQgZm9yIGRlZXBcbiAgICogZXF1YWxpdHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzMsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5pbmNsdWRlLm1lbWJlcnMoWzMsIDIsIDhdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChbNCwgMl0pLnRvLmhhdmUubWVtYmVycyhbMiwgNF0pO1xuICAgKiAgICAgZXhwZWN0KFs1LCAyXSkudG8ubm90LmhhdmUubWVtYmVycyhbNSwgMiwgMV0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KFt7IGlkOiAxIH1dKS50by5kZWVwLmluY2x1ZGUubWVtYmVycyhbeyBpZDogMSB9XSk7XG4gICAqXG4gICAqIEBuYW1lIG1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWVtYmVycycsIGZ1bmN0aW9uIChzdWJzZXQsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqKS50by5iZS5hbignYXJyYXknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1YnNldCkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB2YXIgY21wID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gXy5lcWwgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmosIGNtcClcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhIHN1cGVyc2V0IG9mICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYSBzdXBlcnNldCBvZiAje2FjdH0nXG4gICAgICAgICwgb2JqXG4gICAgICAgICwgc3Vic2V0XG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc1N1YnNldE9mKG9iaiwgc3Vic2V0LCBjbXApICYmIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmosIGNtcClcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgYXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgYXMgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9uZU9mKGxpc3QpXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgYXBwZWFycyBzb21ld2hlcmUgaW4gdGhlIHRvcCBsZXZlbCBvZiBhcnJheSBgbGlzdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2EnKS50by5iZS5vbmVPZihbJ2EnLCAnYicsICdjJ10pO1xuICAgKiAgICAgZXhwZWN0KDkpLnRvLm5vdC5iZS5vbmVPZihbJ3onXSk7XG4gICAqICAgICBleHBlY3QoWzNdKS50by5ub3QuYmUub25lT2YoWzEsIDIsIFszXV0pO1xuICAgKlxuICAgKiAgICAgdmFyIHRocmVlID0gWzNdO1xuICAgKiAgICAgLy8gZm9yIG9iamVjdC10eXBlcywgY29udGVudHMgYXJlIG5vdCBjb21wYXJlZFxuICAgKiAgICAgZXhwZWN0KHRocmVlKS50by5ub3QuYmUub25lT2YoWzEsIDIsIFszXV0pO1xuICAgKiAgICAgLy8gY29tcGFyaW5nIHJlZmVyZW5jZXMgd29ya3NcbiAgICogICAgIGV4cGVjdCh0aHJlZSkudG8uYmUub25lT2YoWzEsIDIsIHRocmVlXSk7XG4gICAqXG4gICAqIEBuYW1lIG9uZU9mXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGxpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBvbmVPZiAobGlzdCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihsaXN0KS50by5iZS5hbignYXJyYXknKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsaXN0LmluZGV4T2YoZXhwZWN0ZWQpID4gLTFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgb25lIG9mICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIG9uZSBvZiAje2V4cH0nXG4gICAgICAsIGxpc3RcbiAgICAgICwgZXhwZWN0ZWRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb25lT2YnLCBvbmVPZik7XG5cblxuICAvKipcbiAgICogIyMjIC5jaGFuZ2UoZnVuY3Rpb24pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGNoYW5nZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCArPSAzIH07XG4gICAqICAgICB2YXIgbm9DaGFuZ2VGbiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2ZvbycgKyAnYmFyJzsgfVxuICAgKiAgICAgZXhwZWN0KGZuKS50by5jaGFuZ2Uob2JqLCAndmFsJyk7XG4gICAqICAgICBleHBlY3Qobm9DaGFuZ2VGbikudG8ubm90LmNoYW5nZShvYmosICd2YWwnKVxuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VcbiAgICogQGFsaWFzIGNoYW5nZXNcbiAgICogQGFsaWFzIENoYW5nZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0Q2hhbmdlcyAob2JqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iamVjdCwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbCA9IG9iamVjdFtwcm9wXTtcbiAgICBmbigpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbml0aWFsICE9PSBvYmplY3RbcHJvcF1cbiAgICAgICwgJ2V4cGVjdGVkIC4nICsgcHJvcCArICcgdG8gY2hhbmdlJ1xuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBub3QgY2hhbmdlJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjaGFuZ2UnLCBhc3NlcnRDaGFuZ2VzKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY2hhbmdlcycsIGFzc2VydENoYW5nZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlKGZ1bmN0aW9uKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBleHBlY3QoZm4pLnRvLmluY3JlYXNlKG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZVxuICAgKiBAYWxpYXMgaW5jcmVhc2VzXG4gICAqIEBhbGlhcyBJbmNyZWFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5jcmVhc2VzIChvYmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqZWN0LCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgbmV3IEFzc2VydGlvbihmbikuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsID0gb2JqZWN0W3Byb3BdO1xuICAgIGZuKCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIG9iamVjdFtwcm9wXSAtIGluaXRpYWwgPiAwXG4gICAgICAsICdleHBlY3RlZCAuJyArIHByb3AgKyAnIHRvIGluY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBub3QgaW5jcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY3JlYXNlJywgYXNzZXJ0SW5jcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jcmVhc2VzJywgYXNzZXJ0SW5jcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZShmdW5jdGlvbilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZGVjcmVhc2VzIGFuIG9iamVjdCBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSA1IH07XG4gICAqICAgICBleHBlY3QoZm4pLnRvLmRlY3JlYXNlKG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZVxuICAgKiBAYWxpYXMgZGVjcmVhc2VzXG4gICAqIEBhbGlhcyBEZWNyZWFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RGVjcmVhc2VzIChvYmplY3QsIHByb3AsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBmbiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqZWN0LCBtc2cpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gICAgbmV3IEFzc2VydGlvbihmbikuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsID0gb2JqZWN0W3Byb3BdO1xuICAgIGZuKCk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIG9iamVjdFtwcm9wXSAtIGluaXRpYWwgPCAwXG4gICAgICAsICdleHBlY3RlZCAuJyArIHByb3AgKyAnIHRvIGRlY3JlYXNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgLicgKyBwcm9wICsgJyB0byBub3QgZGVjcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2RlY3JlYXNlJywgYXNzZXJ0RGVjcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZGVjcmVhc2VzJywgYXNzZXJ0RGVjcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5leHRlbnNpYmxlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGV4dGVuc2libGUgKGNhbiBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvXG4gICAqIGl0KS5cbiAgICpcbiAgICogICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICogICAgIHZhciBzZWFsZWRPYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqICAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3Qobm9uRXh0ZW5zaWJsZU9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3Qoc2VhbGVkT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBAbmFtZSBleHRlbnNpYmxlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIG5vdCBhbiBvYmplY3QgKGEgcHJpbWl0aXZlKSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBub24tZXh0ZW5zaWJsZSBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gZmFsc2UuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRXh0ZW5zaWJsZVxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIHdoZW4gYSBUeXBlRXJyb3IgaXMgdGhyb3duIHVuZGVyIEVTNS5cblxuICAgIHZhciBpc0V4dGVuc2libGU7XG5cbiAgICB0cnkge1xuICAgICAgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikgaXNFeHRlbnNpYmxlID0gZmFsc2U7XG4gICAgICBlbHNlIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzRXh0ZW5zaWJsZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBleHRlbnNpYmxlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZXh0ZW5zaWJsZSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zZWFsZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc2VhbGVkIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIHJlbW92ZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzZWFsZWRPYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdCh7fSkudG8ubm90LmJlLnNlYWxlZDtcbiAgICpcbiAgICogQG5hbWUgc2VhbGVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnc2VhbGVkJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgbm90IGFuIG9iamVjdCAoYSBwcmltaXRpdmUpLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIHNlYWxlZCBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzU2VhbGVkXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3Igd2hlbiBhIFR5cGVFcnJvciBpcyB0aHJvd24gdW5kZXIgRVM1LlxuXG4gICAgdmFyIGlzU2VhbGVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlzU2VhbGVkID0gT2JqZWN0LmlzU2VhbGVkKG9iaik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSBpc1NlYWxlZCA9IHRydWU7XG4gICAgICBlbHNlIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzU2VhbGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHNlYWxlZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIHNlYWxlZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mcm96ZW5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZnJvemVuIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIG1vZGlmaWVkKS5cbiAgICpcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLmZyb3plbjtcbiAgICogICAgIGV4cGVjdCh7fSkudG8ubm90LmJlLmZyb3plbjtcbiAgICpcbiAgICogQG5hbWUgZnJvemVuXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZnJvemVuJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgLy8gSW4gRVM1LCBpZiB0aGUgYXJndW1lbnQgdG8gdGhpcyBtZXRob2QgaXMgbm90IGFuIG9iamVjdCAoYSBwcmltaXRpdmUpLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIGZyb3plbiBvcmRpbmFyeSBvYmplY3QsIHNpbXBseSByZXR1cm4gdHJ1ZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzRnJvemVuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3Igd2hlbiBhIFR5cGVFcnJvciBpcyB0aHJvd24gdW5kZXIgRVM1LlxuXG4gICAgdmFyIGlzRnJvemVuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlzRnJvemVuID0gT2JqZWN0LmlzRnJvemVuKG9iaik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSBpc0Zyb3plbiA9IHRydWU7XG4gICAgICBlbHNlIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzRnJvemVuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZyb3plbidcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGZyb3plbidcbiAgICApO1xuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcblxuICAvKiFcbiAgICogQ2hhaSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgZmxhZyA9IHV0aWwuZmxhZztcblxuICAvKiFcbiAgICogTW9kdWxlIGV4cG9ydC5cbiAgICovXG5cbiAgLyoqXG4gICAqICMjIyBhc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSlcbiAgICpcbiAgICogV3JpdGUgeW91ciBvd24gdGVzdCBleHByZXNzaW9ucy5cbiAgICpcbiAgICogICAgIGFzc2VydCgnZm9vJyAhPT0gJ2JhcicsICdmb28gaXMgbm90IGJhcicpO1xuICAgKiAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkoW10pLCAnZW1wdHkgYXJyYXlzIGFyZSBhcnJheXMnKTtcbiAgICpcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwcmVzc2lvbiB0byB0ZXN0IGZvciB0cnV0aGluZXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRvIGRpc3BsYXkgb24gZXJyb3JcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHZhciBhc3NlcnQgPSBjaGFpLmFzc2VydCA9IGZ1bmN0aW9uIChleHByZXNzLCBlcnJtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24obnVsbCwgbnVsbCwgY2hhaS5hc3NlcnQpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHByZXNzXG4gICAgICAsIGVycm1zZ1xuICAgICAgLCAnWyBuZWdhdGlvbiBtZXNzYWdlIHVuYXZhaWxhYmxlIF0nXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLiBOb2RlLmpzIGBhc3NlcnRgIG1vZHVsZS1jb21wYXRpYmxlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnYXNzZXJ0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgYXNzZXJ0LmZhaWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNPaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQuaXNPayhmYWxzZSwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2tcbiAgICogQGFsaWFzIG9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXMub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90T2soJ2V2ZXJ5dGhpbmcnLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9rKGZhbHNlLCAndGhpcyB3aWxsIHBhc3MnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPa1xuICAgKiBAYWxpYXMgbm90T2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5ub3Qub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCA9PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCB0cnVlLCAndGhlc2UgYm9vbGVhbnMgYXJlIHN0cmljdGx5IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBpbmVxdWFsaXR5IChgIT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoMywgJzMnLCAnbm8gY29lcmNpb24gZm9yIHN0cmljdCBlcXVhbGl0eScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQWJvdmUodmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVBYm92ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiAoPikgYHZhbHVlVG9CZUFib3ZlYFxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQWJvdmUoNSwgMiwgJzUgaXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIDInKTtcbiAgICpcbiAgICogQG5hbWUgaXNBYm92ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQWJvdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQWJvdmUgPSBmdW5jdGlvbiAodmFsLCBhYnYsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmFib3ZlKGFidik7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRMZWFzdCh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUF0TGVhc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gKD49KSBgdmFsdWVUb0JlQXRMZWFzdGBcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TGVhc3QoNSwgMiwgJzUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyJyk7XG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDMsIDMsICczIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TGVhc3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0NoZWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9CZUF0TGVhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRMZWFzdCA9IGZ1bmN0aW9uICh2YWwsIGF0bHN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5sZWFzdChhdGxzdCk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQmVsb3codmFsdWVUb0NoZWNrLCB2YWx1ZVRvQmVCZWxvdywgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZVRvQ2hlY2tgIGlzIHN0cmljdGx5IGxlc3MgdGhhbiAoPCkgYHZhbHVlVG9CZUJlbG93YFxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzQmVsb3coMywgNiwgJzMgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIDYnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCZWxvd1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQmVsb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQmVsb3cgPSBmdW5jdGlvbiAodmFsLCBibHcsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmJlbG93KGJsdyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRNb3N0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRNb3N0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICg8PSkgYHZhbHVlVG9CZUF0TW9zdGBcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCgzLCA2LCAnMyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRNb3N0KDQsIDQsICc0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byA0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQXRNb3N0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdE1vc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzQXRNb3N0ID0gZnVuY3Rpb24gKHZhbCwgYXRtc3QsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLm1vc3QoYXRtc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IHRydWU7XG4gICAqICAgICBhc3NlcnQuaXNUcnVlKHRlYVNlcnZlZCwgJ3RoZSB0ZWEgaGFzIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ3RydWUnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFRydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90VHJ1ZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFRydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90VHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5lcXVhbCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0ZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKiAgICAgYXNzZXJ0LmlzRmFsc2UodGVhU2VydmVkLCAnbm8gdGVhIHlldD8gaG1tLi4uJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBmYWxzZS5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAndGFzdHkgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RGYWxzZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEZhbHNlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEZhbHNlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbnVsbC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc051bGwoZXJyLCAndGhlcmUgd2FzIG5vIGVycm9yJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBudWxsLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bGwodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOYU5cbiAgICogQXNzZXJ0cyB0aGF0IHZhbHVlIGlzIE5hTlxuICAgKlxuICAgKiAgICBhc3NlcnQuaXNOYU4oJ2ZvbycsICdmb28gaXMgTmFOJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTmFOXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05hTiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE5hTlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgbm90IE5hTlxuICAgKlxuICAgKiAgICBhc3NlcnQuaXNOb3ROYU4oNCwgJzQgaXMgbm90IE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE5hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgYXNzZXJ0LmlzTm90TmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykubm90LnRvLmJlLk5hTjtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKiBfVGhlIGFzc2VydGlvbiBkb2VzIG5vdCBtYXRjaCBzdWJjbGFzc2VkIG9iamVjdHMuX1xuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9IHsgbmFtZTogJ0NoYWknLCBzZXJ2ZTogJ3dpdGggc3BpY2VzJyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzT2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIG9iamVjdCBvZiB0eXBlICdPYmplY3QnIChhcyByZXZlYWxlZCBieSBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2ApLlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9ICdjaGFpJ1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KG51bGwsICdudWxsIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9IFsgJ2dyZWVuJywgJ2NoYWknLCAnb29sb25nJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzQXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90QXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9ICdncmVlbnxjaGFpfG9vbG9uZyc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEFycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEFycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gJ2NoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzU3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzU3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gNDtcbiAgICogICAgIGFzc2VydC5pc05vdFN0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFN0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9IDI7XG4gICAqICAgICBhc3NlcnQuaXNOdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAnMiBjdXBzIHBsZWFzZSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdW1iZXJcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSB0cnVlXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90Qm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSAneWVwJ1xuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9ICdub3BlJztcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEJvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50eXBlT2YoeyB0ZWE6ICdjaGFpJyB9LCAnb2JqZWN0JywgJ3dlIGhhdmUgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKFsnY2hhaScsICdqYXNtaW5lJ10sICdhcnJheScsICd3ZSBoYXZlIGFuIGFycmF5Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKCd0ZWEnLCAnc3RyaW5nJywgJ3dlIGhhdmUgYSBzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoL3RlYS8sICdyZWdleHAnLCAnd2UgaGF2ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihudWxsLCAnbnVsbCcsICd3ZSBoYXZlIGEgbnVsbCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih1bmRlZmluZWQsICd1bmRlZmluZWQnLCAnd2UgaGF2ZSBhbiB1bmRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgdHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50eXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgX25vdF8gYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RUeXBlT2YoJ3RlYScsICdudW1iZXInLCAnc3RyaW5ncyBhcmUgbm90IG51bWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90VHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlb2YgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90VHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgU3RyaW5nKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBXb3Jrc1xuICAgKiBmb3Igc3RyaW5ncyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoJ2Zvb2JhcicsICdiYXInLCAnZm9vYmFyIGNvbnRhaW5zIHN0cmluZyBcImJhclwiJyk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbIDEsIDIsIDMgXSwgMywgJ2FycmF5IGNvbnRhaW5zIHZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmluY2x1ZGUpLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgJ3N0cmluZyBub3QgaW5jbHVkZSBzdWJzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFsgMSwgMiwgMyBdLCA0LCAnYXJyYXkgbm90IGluY2x1ZGUgY29udGFpbiB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RJbmNsdWRlKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8ubm90Lm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaCBjYW4gYmUgYVxuICAgKiBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBiYWQnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwXG4gICAqIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5Tm90VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCBidXQgd2l0aCBhIHZhbHVlXG4gICAqIGRpZmZlcmVudCBmcm9tIHRoYXQgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kXG4gICAqIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG9iamVjdCwgbGVuZ3RoLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihbMSwyLDNdLCAzLCAnYXJyYXkgaGFzIGxlbmd0aCBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoJ2Zvb2JhcicsIDYsICdzdHJpbmcgaGFzIGxlbmd0aCBvZiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5sZW5ndGhPZiA9IGZ1bmN0aW9uIChleHAsIGxlbiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8uaGF2ZS5sZW5ndGgobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50aHJvd3MoZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93c1xuICAgKiBAYWxpYXMgdGhyb3dcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50aHJvd3MgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycnQgfHwgZXJydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJycyA9IGVycnQ7XG4gICAgICBlcnJ0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by50aHJvdyhlcnJ0LCBlcnJzKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIHR5cGUsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgIG1zZyA9IHR5cGU7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIHZhciBvaztcbiAgICBzd2l0Y2gob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgb2sgPSB2YWwgPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgICBvayA9IHZhbCA9PT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc+JzpcbiAgICAgICAgb2sgPSB2YWwgPiB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgb2sgPSB2YWwgPj0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgb2sgPSB2YWwgPCB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgb2sgPSB2YWwgPD0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPSc6XG4gICAgICAgIG9rID0gdmFsICE9IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgb2sgPSB2YWwgIT09IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihvaywgbXNnKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIG5vdCBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMikgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNsb3NlVG8oMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2xvc2VUbyA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmJlLmNsb3NlVG8oZXhwLCBkZWx0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuYXBwcm94aW1hdGVseShhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5hcHByb3hpbWF0ZWx5KDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmFwcHJveGltYXRlbHkgPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5iZS5hcHByb3hpbWF0ZWx5KGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycy5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZykudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5zYW1lRGVlcE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIC0gdXNpbmcgYSBkZWVwIGVxdWFsaXR5IGNoZWNraW5nLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycyhbIHtiOiAzfSwge2E6IDJ9LCB7YzogNX0gXSwgWyB7YzogNX0sIHtiOiAzfSwge2E6IDJ9IF0sICdzYW1lIGRlZXAgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lRGVlcE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2cpLnRvLmhhdmUuc2FtZS5kZWVwLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZykudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlRGVlcE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCAtIHVzaW5nIGRlZXAgZXF1YWxpdHkgY2hlY2tpbmcuXG4gICAqIE9yZGVyIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAqIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzKFsge2E6IDF9LCB7YjogMn0sIHtjOiAzfSBdLCBbIHtiOiAyfSwge2E6IDF9LCB7YjogMn0gXSwgJ2luY2x1ZGUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2cpLnRvLmluY2x1ZGUuZGVlcC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5vbmVPZihpbkxpc3QsIGxpc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IG5vbi1vYmplY3QsIG5vbi1hcnJheSB2YWx1ZSBgaW5MaXN0YCBhcHBlYXJzIGluIHRoZSBmbGF0IGFycmF5IGBsaXN0YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vbmVPZigxLCBbIDIsIDEgXSwgJ05vdCBmb3VuZCBpbiBsaXN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIG9uZU9mXG4gICAqIEBwYXJhbSB7Kn0gaW5MaXN0XG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGxpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9uZU9mID0gZnVuY3Rpb24gKGluTGlzdCwgbGlzdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihpbkxpc3QsIG1zZykudG8uYmUub25lT2YobGlzdCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuY2hhbmdlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAyMiB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wKSB7XG4gICAgbmV3IEFzc2VydGlvbihmbikudG8uY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdENoYW5nZShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdmb28nKTsgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90Q2hhbmdlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdENoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLm5vdC5jaGFuZ2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXMoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHkpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGluY3JlYXNlcyBhbiBvYmplY3QgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTMgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdEluY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBpbmNyZWFzZSBvYmplY3QgcHJvcGVydHlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gOCB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZShmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RJbmNyZWFzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RJbmNyZWFzZSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wKSB7XG4gICAgbmV3IEFzc2VydGlvbihmbikudG8ubm90LmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkZWNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCkge1xuICAgIG5ldyBBc3NlcnRpb24oZm4pLnRvLmRlY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuZG9lc05vdERlY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYW4gb2JqZWN0IHByb3BlcnR5XG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdERlY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdERlY3JlYXNlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3ApIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGZuKS50by5ub3QuZGVjcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qIVxuICAgKiAjIyMgLmlmRXJyb3Iob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIGlmIHZhbHVlIGlzIG5vdCBhIGZhbHNlIHZhbHVlLCBhbmQgdGhyb3dzIGlmIGl0IGlzIGEgdHJ1ZSB2YWx1ZS5cbiAgICogVGhpcyBpcyBhZGRlZCB0byBhbGxvdyBmb3IgY2hhaSB0byBiZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIE5vZGUnc1xuICAgKiBhc3NlcnQgY2xhc3MuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdJIGFtIGEgY3VzdG9tIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQuaWZFcnJvcihlcnIpOyAvLyBSZXRocm93cyBlcnIhXG4gICAqXG4gICAqIEBuYW1lIGlmRXJyb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aHJvdyh2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0V4dGVuc2libGUob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZXh0ZW5zaWJsZSAoY2FuIGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXQpLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzRXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgZXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGV4dGVuc2libGUuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlc2Uoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShub25FeHRlbnNpYmxlT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RFeHRlbnNpYmxlXG4gICAqIEBhbGlhcyBub3RFeHRlbnNpYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgc2VhbGVkIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIHJlbW92ZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc1NlYWxlZChmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc1NlYWxlZFxuICAgKiBAYWxpYXMgc2VhbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTZWFsZWQgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gc2VhbGVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90U2VhbGVkKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTZWFsZWRcbiAgICogQGFsaWFzIG5vdFNlYWxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U2VhbGVkID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmJlLnNlYWxlZDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0Zyb3plbihvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmcm96ZW4gKGNhbm5vdCBoYXZlIG5ldyBwcm9wZXJ0aWVzIGFkZGVkIHRvIGl0XG4gICAqIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW5ub3QgYmUgbW9kaWZpZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKiAgICAgYXNzZXJ0LmZyb3plbihmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Zyb3plblxuICAgKiBAYWxpYXMgZnJvemVuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGcm96ZW4gPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gZnJvemVuLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RnJvemVuKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGcm96ZW5cbiAgICogQGFsaWFzIG5vdEZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmJlLmZyb3plbjtcbiAgfTtcblxuICAvKiFcbiAgICogQWxpYXNlcy5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIGFsaWFzKG5hbWUsIGFzKXtcbiAgICBhc3NlcnRbYXNdID0gYXNzZXJ0W25hbWVdO1xuICAgIHJldHVybiBhbGlhcztcbiAgfSlcbiAgKCdpc09rJywgJ29rJylcbiAgKCdpc05vdE9rJywgJ25vdE9rJylcbiAgKCd0aHJvd3MnLCAndGhyb3cnKVxuICAoJ3Rocm93cycsICdUaHJvdycpXG4gICgnaXNFeHRlbnNpYmxlJywgJ2V4dGVuc2libGUnKVxuICAoJ2lzTm90RXh0ZW5zaWJsZScsICdub3RFeHRlbnNpYmxlJylcbiAgKCdpc1NlYWxlZCcsICdzZWFsZWQnKVxuICAoJ2lzTm90U2VhbGVkJywgJ25vdFNlYWxlZCcpXG4gICgnaXNGcm96ZW4nLCAnZnJvemVuJylcbiAgKCdpc05vdEZyb3plbicsICdub3RGcm96ZW4nKTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIGNoYWkuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgY2hhaS5Bc3NlcnRpb24odmFsLCBtZXNzYWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLlxuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBFeHBlY3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgY2hhaS5leHBlY3QuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdleHBlY3QuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBjaGFpLmV4cGVjdC5mYWlsKTtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvbjtcblxuICBmdW5jdGlvbiBsb2FkU2hvdWxkICgpIHtcbiAgICAvLyBleHBsaWNpdGx5IGRlZmluZSB0aGlzIG1ldGhvZCBhcyBmdW5jdGlvbiBhcyB0byBoYXZlIGl0J3MgbmFtZSB0byBpbmNsdWRlIGFzIGBzc2ZpYFxuICAgIGZ1bmN0aW9uIHNob3VsZEdldHRlcigpIHtcbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgU3RyaW5nIHx8IHRoaXMgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdGhpcyBpbnN0YW5jZW9mIEJvb2xlYW4gKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMudmFsdWVPZigpLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcywgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkU2V0dGVyKHZhbHVlKSB7XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9jaGFpL2lzc3Vlcy84NjogdGhpcyBtYWtlc1xuICAgICAgLy8gYHdoYXRldmVyLnNob3VsZCA9IHNvbWVWYWx1ZWAgYWN0dWFsbHkgc2V0IGBzb21lVmFsdWVgLCB3aGljaCBpc1xuICAgICAgLy8gZXNwZWNpYWxseSB1c2VmdWwgZm9yIGBnbG9iYWwuc2hvdWxkID0gcmVxdWlyZSgnY2hhaScpLnNob3VsZCgpYC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgd2UgaGF2ZSB0byB1c2UgW1tEZWZpbmVQcm9wZXJ0eV1dIGluc3RlYWQgb2YgW1tQdXRdXVxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIHdlIHdvdWxkIHRyaWdnZXIgdGhpcyB2ZXJ5IHNldHRlciFcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2hvdWxkJywge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtb2RpZnkgT2JqZWN0LnByb3RvdHlwZSB0byBoYXZlIGBzaG91bGRgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdzaG91bGQnLCB7XG4gICAgICBzZXQ6IHNob3VsZFNldHRlclxuICAgICAgLCBnZXQ6IHNob3VsZEdldHRlclxuICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHZhciBzaG91bGQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAgICpcbiAgICAgKiBUaHJvdyBhIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBmYWlsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnc2hvdWxkLmZhaWwoKSc7XG4gICAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgIH0sIHNob3VsZC5mYWlsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBlcXVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8uZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAudGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSB0aHJvd1xuICAgICAqIEBhbGlhcyBUaHJvd1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5leGlzdFxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogICAgIHZhciBmb28gPSAnaGknO1xuICAgICAqXG4gICAgICogICAgIHNob3VsZC5leGlzdChmb28sICdmb28gZXhpc3RzJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBleGlzdFxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXhpc3Q7XG4gICAgfVxuXG4gICAgLy8gbmVnYXRpb25cbiAgICBzaG91bGQubm90ID0ge31cblxuICAgIC8qKlxuICAgICAqICMjIyAubm90LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LmVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC5lcXVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLm5vdC5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC50aHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC50aHJvdyhmbiwgRXJyb3IsICdmdW5jdGlvbiBkb2VzIG5vdCB0aHJvdycpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LnRocm93XG4gICAgICogQGFsaWFzIG5vdC5UaHJvd1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLm5vdC5leGlzdFxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogICAgIHZhciBiYXIgPSBudWxsO1xuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QuZXhpc3QoYmFyLCAnYmFyIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QuZXhpc3RcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXhpc3Q7XG4gICAgfVxuXG4gICAgc2hvdWxkWyd0aHJvdyddID0gc2hvdWxkWydUaHJvdyddO1xuICAgIHNob3VsZC5ub3RbJ3Rocm93J10gPSBzaG91bGQubm90WydUaHJvdyddO1xuXG4gICAgcmV0dXJuIHNob3VsZDtcbiAgfTtcblxuICBjaGFpLnNob3VsZCA9IGxvYWRTaG91bGQ7XG4gIGNoYWkuU2hvdWxkID0gbG9hZFNob3VsZDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRDaGFpbmluZ01ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qIVxuICogTW9kdWxlIHZhcmlhYmxlc1xuICovXG5cbi8vIENoZWNrIHdoZXRoZXIgYF9fcHJvdG9fX2AgaXMgc3VwcG9ydGVkXG52YXIgaGFzUHJvdG9TdXBwb3J0ID0gJ19fcHJvdG9fXycgaW4gT2JqZWN0O1xuXG4vLyBXaXRob3V0IGBfX3Byb3RvX19gIHN1cHBvcnQsIHRoaXMgbW9kdWxlIHdpbGwgbmVlZCB0byBhZGQgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uLlxuLy8gSG93ZXZlciwgc29tZSBGdW5jdGlvbi5wcm90b3R5cGUgbWV0aG9kcyBjYW5ub3QgYmUgb3ZlcndyaXR0ZW4sXG4vLyBhbmQgdGhlcmUgc2VlbXMgbm8gZWFzeSBjcm9zcy1wbGF0Zm9ybSB3YXkgdG8gZGV0ZWN0IHRoZW0gKEBzZWUgY2hhaWpzL2NoYWkvaXNzdWVzLzY5KS5cbnZhciBleGNsdWRlTmFtZXMgPSAvXig/Omxlbmd0aHxuYW1lfGFyZ3VtZW50c3xjYWxsZXIpJC87XG5cbi8vIENhY2hlIGBGdW5jdGlvbmAgcHJvcGVydGllc1xudmFyIGNhbGwgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsXG4gICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8qKlxuICogIyMjIGFkZENoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byBhbiBvYmplY3QsIHN1Y2ggdGhhdCB0aGUgbWV0aG9kIGNhbiBhbHNvIGJlIGNoYWluZWQuXG4gKlxuICogICAgIHV0aWxzLmFkZENoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gKlxuICogVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSB1c2VkIGFzIGJvdGggYSBtZXRob2QgYXNzZXJ0aW9uLCBleGVjdXRpbmcgYm90aCBgbWV0aG9kYCBhbmRcbiAqIGBjaGFpbmluZ0JlaGF2aW9yYCwgb3IgYXMgYSBsYW5ndWFnZSBjaGFpbiwgd2hpY2ggb25seSBleGVjdXRlcyBgY2hhaW5pbmdCZWhhdmlvcmAuXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vLmVxdWFsKCdmb28nKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgYG5hbWVgLCB3aGVuIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZENoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICBpZiAodHlwZW9mIGNoYWluaW5nQmVoYXZpb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICB9XG5cbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0ge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAsIGNoYWluaW5nQmVoYXZpb3I6IGNoYWluaW5nQmVoYXZpb3JcbiAgfTtcblxuICAvLyBzYXZlIHRoZSBtZXRob2RzIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBsYXRlciwgaWYgd2UgbmVlZCB0by5cbiAgaWYgKCFjdHguX19tZXRob2RzKSB7XG4gICAgY3R4Ll9fbWV0aG9kcyA9IHt9O1xuICB9XG4gIGN0eC5fX21ldGhvZHNbbmFtZV0gPSBjaGFpbmFibGVCZWhhdmlvcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KCkge1xuICAgICAgICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICAgICAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgYXNzZXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2UgYF9fcHJvdG9fX2AgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChoYXNQcm90b1N1cHBvcnQpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGFzc2VydC5fX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGBjYWxsYCBhbmQgYGFwcGx5YCBtZXRob2RzIGZyb20gYEZ1bmN0aW9uYFxuICAgICAgICAgIHByb3RvdHlwZS5jYWxsID0gY2FsbDtcbiAgICAgICAgICBwcm90b3R5cGUuYXBwbHkgPSBhcHBseTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHJlZGVmaW5lIGFsbCBwcm9wZXJ0aWVzIChzbG93ISlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGFzc2VydGVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdHgpO1xuICAgICAgICAgIGFzc2VydGVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoYXNzZXJ0ZXJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVOYW1lcy50ZXN0KGFzc2VydGVyTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIGFzc2VydGVyTmFtZSk7XG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhc3NlcnQsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBhc3NlcnQpO1xuICAgICAgICByZXR1cm4gYXNzZXJ0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZE1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAuYWRkTWV0aG9kIChjdHgsIG5hbWUsIG1ldGhvZClcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICBjdHhbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9sZF9zc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIGlmIChvbGRfc3NmaSAmJiBjb25maWcuaW5jbHVkZVN0YWNrID09PSBmYWxzZSlcbiAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBjdHhbbmFtZV0pO1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZFByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMjIyBhZGRQcm9wZXJ0eSAoY3R4LCBuYW1lLCBnZXR0ZXIpXG4gKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5pbnN0YW5jZW9mKEZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5mb287XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBhZGRQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIG9sZF9zc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgICAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGFkZFByb3BlcnR5KTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZXhwZWN0VHlwZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIGV4cGVjdFR5cGVzKG9iaiwgdHlwZXMpXG4gKlxuICogRW5zdXJlcyB0aGF0IHRoZSBvYmplY3QgYmVpbmcgdGVzdGVkIGFnYWluc3QgaXMgb2YgYSB2YWxpZCB0eXBlLlxuICpcbiAqICAgICB1dGlscy5leHBlY3RUeXBlcyh0aGlzLCBbJ2FycmF5JywgJ29iamVjdCcsICdzdHJpbmcnXSk7XG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqIGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtBcnJheX0gdHlwZSBBIGxpc3Qgb2YgYWxsb3dlZCB0eXBlcyBmb3IgdGhpcyBhc3NlcnRpb25cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGV4cGVjdFR5cGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBBc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCB0eXBlcykge1xuICB2YXIgb2JqID0gZmxhZyhvYmosICdvYmplY3QnKTtcbiAgdHlwZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9Mb3dlckNhc2UoKTsgfSk7XG4gIHR5cGVzLnNvcnQoKTtcblxuICAvLyBUcmFuc2Zvcm1zIFsnbG9yZW0nLCAnaXBzdW0nXSBpbnRvICdhIGxpcnVtLCBvciBhbiBpcHN1bSdcbiAgdmFyIHN0ciA9IHR5cGVzLm1hcChmdW5jdGlvbiAodCwgaW5kZXgpIHtcbiAgICB2YXIgYXJ0ID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHQuY2hhckF0KDApKSA/ICdhbicgOiAnYSc7XG4gICAgdmFyIG9yID0gdHlwZXMubGVuZ3RoID4gMSAmJiBpbmRleCA9PT0gdHlwZXMubGVuZ3RoIC0gMSA/ICdvciAnIDogJyc7XG4gICAgcmV0dXJuIG9yICsgYXJ0ICsgJyAnICsgdDtcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoIXR5cGVzLnNvbWUoZnVuY3Rpb24gKGV4cGVjdGVkKSB7IHJldHVybiB0eXBlKG9iaikgPT09IGV4cGVjdGVkOyB9KSkge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihcbiAgICAgICdvYmplY3QgdGVzdGVkIG11c3QgYmUgJyArIHN0ciArICcsIGJ1dCAnICsgdHlwZShvYmopICsgJyBnaXZlbidcbiAgICApO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgZmxhZyhvYmplY3QsIGtleSwgW3ZhbHVlXSlcbiAqXG4gKiBHZXQgb3Igc2V0IGEgZmxhZyB2YWx1ZSBvbiBhbiBvYmplY3QuIElmIGFcbiAqIHZhbHVlIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0LCBlbHNlIGl0IHdpbGxcbiAqIHJldHVybiB0aGUgY3VycmVudGx5IHNldCB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKlxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycsICdiYXInKTsgLy8gc2V0dGVyXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJyk7IC8vIGdldHRlciwgcmV0dXJucyBgYmFyYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBmbGFnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgdmFyIGZsYWdzID0gb2JqLl9fZmxhZ3MgfHwgKG9iai5fX2ZsYWdzID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZmxhZ3Nba2V5XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmbGFnc1trZXldO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0QWN0dWFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMgZ2V0QWN0dWFsKG9iamVjdCwgW2FjdHVhbF0pXG4gKlxuICogUmV0dXJucyB0aGUgYGFjdHVhbGAgdmFsdWUgZm9yIGFuIEFzc2VydGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0QWN0dWFsXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHJldHVybiBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWzRdIDogb2JqLl9vYmo7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRFbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gbWVzc2FnZSBjb21wb3NpdGlvbiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKVxuICAsIGdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJylcbiAgLCBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0JylcbiAgLCBvYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKG9iamVjdCwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSlcbiAqXG4gKiBDb25zdHJ1Y3QgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZmxhZ3NcbiAqIGFuZCB0ZW1wbGF0ZSB0YWdzLiBUZW1wbGF0ZSB0YWdzIHdpbGwgcmV0dXJuXG4gKiBhIHN0cmluZ2lmaWVkIGluc3BlY3Rpb24gb2YgdGhlIG9iamVjdCByZWZlcmVuY2VkLlxuICpcbiAqIE1lc3NhZ2UgdGVtcGxhdGUgdGFnczpcbiAqIC0gYCN7dGhpc31gIGN1cnJlbnQgYXNzZXJ0ZWQgb2JqZWN0XG4gKiAtIGAje2FjdH1gIGFjdHVhbCB2YWx1ZVxuICogLSBgI3tleHB9YCBleHBlY3RlZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIHZhbCA9IGZsYWcob2JqLCAnb2JqZWN0JylcbiAgICAsIGV4cGVjdGVkID0gYXJnc1szXVxuICAgICwgYWN0dWFsID0gZ2V0QWN0dWFsKG9iaiwgYXJncylcbiAgICAsIG1zZyA9IG5lZ2F0ZSA/IGFyZ3NbMl0gOiBhcmdzWzFdXG4gICAgLCBmbGFnTXNnID0gZmxhZyhvYmosICdtZXNzYWdlJyk7XG5cbiAgaWYodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSBtc2cgPSBtc2coKTtcbiAgbXNnID0gbXNnIHx8ICcnO1xuICBtc2cgPSBtc2dcbiAgICAucmVwbGFjZSgvI1xce3RoaXNcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheSh2YWwpOyB9KVxuICAgIC5yZXBsYWNlKC8jXFx7YWN0XFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkoYWN0dWFsKTsgfSlcbiAgICAucmVwbGFjZSgvI1xce2V4cFxcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KGV4cGVjdGVkKTsgfSk7XG5cbiAgcmV0dXJuIGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyArIG1zZyA6IG1zZztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXROYW1lIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMgZ2V0TmFtZShmdW5jKVxuICpcbiAqIEdldHMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiwgaW4gYSBjcm9zcy1icm93c2VyIHdheS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uICh1c3VhbGx5IGEgY29uc3RydWN0b3IpXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXROYW1lXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAoZnVuYy5uYW1lKSByZXR1cm4gZnVuYy5uYW1lO1xuXG4gIHZhciBtYXRjaCA9IC9eXFxzP2Z1bmN0aW9uIChbXihdKilcXCgvLmV4ZWMoZnVuYyk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSA/IG1hdGNoWzFdIDogXCJcIjtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQYXRoSW5mbyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGhhc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9oYXNQcm9wZXJ0eScpO1xuXG4vKipcbiAqICMjIyAuZ2V0UGF0aEluZm8ocGF0aCwgb2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgaW5mbyBpbiBhblxuICogb2JqZWN0IGdpdmVuIGEgc3RyaW5nIHBhdGguXG4gKlxuICogVGhlIHBhdGggaW5mbyBjb25zaXN0cyBvZiBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICogcGFyZW50IC0gVGhlIHBhcmVudCBvYmplY3Qgb2YgdGhlIHByb3BlcnR5IHJlZmVyZW5jZWQgYnkgYHBhdGhgXG4gKiAqIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmluYWwgcHJvcGVydHksIGEgbnVtYmVyIGlmIGl0IHdhcyBhbiBhcnJheSBpbmRleGVyXG4gKiAqIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqICogZXhpc3RzIC0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzIG9yIG5vdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBpbmZvXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQYXRoSW5mb1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBhdGhJbmZvKHBhdGgsIG9iaikge1xuICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKHBhdGgpLFxuICAgICAgbGFzdCA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMV07XG5cbiAgdmFyIGluZm8gPSB7XG4gICAgcGFyZW50OiBwYXJzZWQubGVuZ3RoID4gMSA/IF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmosIHBhcnNlZC5sZW5ndGggLSAxKSA6IG9iaixcbiAgICBuYW1lOiBsYXN0LnAgfHwgbGFzdC5pLFxuICAgIHZhbHVlOiBfZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKVxuICB9O1xuICBpbmZvLmV4aXN0cyA9IGhhc1Byb3BlcnR5KGluZm8ubmFtZSwgaW5mby5wYXJlbnQpO1xuXG4gIHJldHVybiBpbmZvO1xufTtcblxuXG4vKiFcbiAqICMjIHBhcnNlUGF0aChwYXRoKVxuICpcbiAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIHBhcnNlIHN0cmluZyBvYmplY3RcbiAqIHBhdGhzLiBVc2UgaW4gY29uanVuY3Rpb24gd2l0aCBgX2dldFBhdGhWYWx1ZWAuXG4gKlxuICogICAgICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKCdteW9iamVjdC5wcm9wZXJ0eS5zdWJwcm9wJyk7XG4gKlxuICogIyMjIFBhdGhzOlxuICpcbiAqICogQ2FuIGJlIGFzIG5lYXIgaW5maW5pdGVseSBkZWVwIGFuZCBuZXN0ZWRcbiAqICogQXJyYXlzIGFyZSBhbHNvIHZhbGlkIHVzaW5nIHRoZSBmb3JtYWwgYG15b2JqZWN0LmRvY3VtZW50WzNdLnByb3BlcnR5YC5cbiAqICogTGl0ZXJhbCBkb3RzIGFuZCBicmFja2V0cyAobm90IGRlbGltaXRlcikgbXVzdCBiZSBiYWNrc2xhc2gtZXNjYXBlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybnMge09iamVjdH0gcGFyc2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIHN0ciA9IHBhdGgucmVwbGFjZSgvKFteXFxcXF0pXFxbL2csICckMS5bJylcbiAgICAsIHBhcnRzID0gc3RyLm1hdGNoKC8oXFxcXFxcLnxbXi5dKz8pKy9nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmUgPSAvXlxcWyhcXGQrKVxcXSQvXG4gICAgICAsIG1BcnIgPSByZS5leGVjKHZhbHVlKTtcbiAgICBpZiAobUFycikgcmV0dXJuIHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIGVsc2UgcmV0dXJuIHsgcDogdmFsdWUucmVwbGFjZSgvXFxcXChbLlxcW1xcXV0pL2csICckMScpIH07XG4gIH0pO1xufVxuXG5cbi8qIVxuICogIyMgX2dldFBhdGhWYWx1ZShwYXJzZWQsIG9iailcbiAqXG4gKiBIZWxwZXIgY29tcGFuaW9uIGZ1bmN0aW9uIGZvciBgLnBhcnNlUGF0aGAgdGhhdCByZXR1cm5zXG4gKiB0aGUgdmFsdWUgbG9jYXRlZCBhdCB0aGUgcGFyc2VkIGFkZHJlc3MuXG4gKlxuICogICAgICB2YXIgdmFsdWUgPSBnZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWQgZGVmaW5pdGlvbiBmcm9tIGBwYXJzZVBhdGhgLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9iamVjdCB0byBzZWFyY2ggYWdhaW5zdFxuICogQHJldHVybnMge09iamVjdHxVbmRlZmluZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UGF0aFZhbHVlIChwYXJzZWQsIG9iaiwgaW5kZXgpIHtcbiAgdmFyIHRtcCA9IG9ialxuICAgICwgcmVzO1xuXG4gIGluZGV4ID0gKGluZGV4ID09PSB1bmRlZmluZWQgPyBwYXJzZWQubGVuZ3RoIDogaW5kZXgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaW5kZXg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAodG1wKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LnApXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LnBdO1xuICAgICAgZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LmkpXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LmldO1xuICAgICAgaWYgKGkgPT0gKGwgLSAxKSkgcmVzID0gdG1wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQYXRoVmFsdWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xvZ2ljYWxwYXJhZG94L2ZpbHRyXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgZ2V0UGF0aEluZm8gPSByZXF1aXJlKCcuL2dldFBhdGhJbmZvJyk7XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUocGF0aCwgb2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuc3RyJywgb2JqKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLmF0dFsyXScsIG9iaik7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AyLmFyclswXS5uZXN0ZWQnLCBvYmopOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGgsIG9iaikge1xuICB2YXIgaW5mbyA9IGdldFBhdGhJbmZvKHBhdGgsIG9iaik7XG4gIHJldHVybiBpbmZvLnZhbHVlO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCwgZW51bWVyYWJsZSBvciBub3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIHdoaWxlIChwcm90byAhPT0gbnVsbCkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5mb3JFYWNoKGFkZFByb3BlcnR5KTtcbiAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGhhc1Byb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qKlxuICogIyMjIC5oYXNQcm9wZXJ0eShvYmplY3QsIG5hbWUpXG4gKlxuICogVGhpcyBhbGxvd3MgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzXG4gKiBuYW1lZCBwcm9wZXJ0eSBvciBudW1lcmljIGFycmF5IGluZGV4LlxuICpcbiAqIEJhc2ljYWxseSBkb2VzIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBgaW5gXG4gKiBvcGVyYXRvciBidXQgd29ya3MgcHJvcGVybHkgd2l0aCBuYXRpdmVzXG4gKiBhbmQgbnVsbC91bmRlZmluZWQgdmFsdWVzLlxuICpcbiAqICAgICB2YXIgb2JqID0ge1xuICogICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICB9XG4gKlxuICogVGhlIGZvbGxvd2luZyB3b3VsZCBiZSB0aGUgcmVzdWx0cy5cbiAqXG4gKiAgICAgaGFzUHJvcGVydHkoJ3N0cicsIG9iaik7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkoJ2NvbnN0cnVjdG9yJywgb2JqKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eSgnYmFyJywgb2JqKTsgIC8vIGZhbHNlXG4gKlxuICogICAgIGhhc1Byb3BlcnR5KCdsZW5ndGgnLCBvYmouc3RyKTsgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KDEsIG9iai5zdHIpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KDUsIG9iai5zdHIpOyAgLy8gZmFsc2VcbiAqXG4gKiAgICAgaGFzUHJvcGVydHkoJ2xlbmd0aCcsIG9iai5hcnIpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KDIsIG9iai5hcnIpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KDMsIG9iai5hcnIpOyAgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge09ianVlY3R9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2hldGhlciBpdCBleGlzdHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldFBhdGhJbmZvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBsaXRlcmFscyA9IHtcbiAgICAnbnVtYmVyJzogTnVtYmVyXG4gICwgJ3N0cmluZyc6IFN0cmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eShuYW1lLCBvYmopIHtcbiAgdmFyIG90ID0gdHlwZShvYmopO1xuXG4gIC8vIEJhZCBPYmplY3QsIG9idmlvdXNseSBubyBwcm9wcyBhdCBhbGxcbiAgaWYob3QgPT09ICdudWxsJyB8fCBvdCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRoZSBgaW5gIG9wZXJhdG9yIGRvZXMgbm90IHdvcmsgd2l0aCBjZXJ0YWluIGxpdGVyYWxzXG4gIC8vIGJveCB0aGVzZSBiZWZvcmUgdGhlIGNoZWNrXG4gIGlmKGxpdGVyYWxzW290XSAmJiB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICBvYmogPSBuZXcgbGl0ZXJhbHNbb3RdKG9iaik7XG5cbiAgcmV0dXJuIG5hbWUgaW4gb2JqO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1haW4gZXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyohXG4gKiB0ZXN0IHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcblxuLyohXG4gKiB0eXBlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG4vKiFcbiAqIGV4cGVjdFR5cGVzIHV0aWxpdHlcbiAqL1xuZXhwb3J0cy5leHBlY3RUeXBlcyA9IHJlcXVpcmUoJy4vZXhwZWN0VHlwZXMnKTtcblxuLyohXG4gKiBtZXNzYWdlIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldE1lc3NhZ2UgPSByZXF1aXJlKCcuL2dldE1lc3NhZ2UnKTtcblxuLyohXG4gKiBhY3R1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKTtcblxuLyohXG4gKiBJbnNwZWN0IHV0aWxcbiAqL1xuXG5leHBvcnRzLmluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcblxuLyohXG4gKiBPYmplY3QgRGlzcGxheSB1dGlsXG4gKi9cblxuZXhwb3J0cy5vYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qIVxuICogRmxhZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5mbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qIVxuICogRmxhZyB0cmFuc2ZlcnJpbmcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKiFcbiAqIERlZXAgZXF1YWwgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZXFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKTtcblxuLyohXG4gKiBEZWVwIHBhdGggdmFsdWVcbiAqL1xuXG5leHBvcnRzLmdldFBhdGhWYWx1ZSA9IHJlcXVpcmUoJy4vZ2V0UGF0aFZhbHVlJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIGluZm9cbiAqL1xuXG5leHBvcnRzLmdldFBhdGhJbmZvID0gcmVxdWlyZSgnLi9nZXRQYXRoSW5mbycpO1xuXG4vKiFcbiAqIENoZWNrIGlmIGEgcHJvcGVydHkgZXhpc3RzXG4gKi9cblxuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vaGFzUHJvcGVydHknKTtcblxuLyohXG4gKiBGdW5jdGlvbiBuYW1lXG4gKi9cblxuZXhwb3J0cy5nZXROYW1lID0gcmVxdWlyZSgnLi9nZXROYW1lJyk7XG5cbi8qIVxuICogYWRkIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5hZGRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vYWRkUHJvcGVydHknKTtcblxuLyohXG4gKiBhZGQgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRNZXRob2QgPSByZXF1aXJlKCcuL2FkZE1ldGhvZCcpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL292ZXJ3cml0ZVByb3BlcnR5Jyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIE1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNZXRob2QnKTtcblxuLyohXG4gKiBBZGQgYSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL2FkZENoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIE92ZXJ3cml0ZSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCcpO1xuIiwiLy8gVGhpcyBpcyAoYWxtb3N0KSBkaXJlY3RseSBmcm9tIE5vZGUuanMgdXRpbHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9ibG9iL2Y4YzMzNWQwY2FmNDdmMTZkMzE0MTNmODlhYTI4ZWRhMzg3OGUzYWEvbGliL3V0aWwuanNcblxudmFyIGdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcbnZhciBnZXRQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRQcm9wZXJ0aWVzJyk7XG52YXIgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zcGVjdDtcblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93SGlkZGVuIEZsYWcgdGhhdCBzaG93cyBoaWRkZW4gKG5vdCBlbnVtZXJhYmxlKVxuICogICAgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIERlcHRoIGluIHdoaWNoIHRvIGRlc2NlbmQgaW4gb2JqZWN0LiBEZWZhdWx0IGlzIDIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9ycyBGbGFnIHRvIHR1cm4gb24gQU5TSSBlc2NhcGUgY29kZXMgdG8gY29sb3IgdGhlXG4gKiAgICBvdXRwdXQuIERlZmF1bHQgaXMgZmFsc2UgKG5vIGNvbG9yaW5nKS5cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGluc3BlY3RcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBzaG93SGlkZGVuOiBzaG93SGlkZGVuLFxuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYSBET00gZWxlbWVudC5cbnZhciBpc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3Qubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBJZiB0aGlzIGlzIGEgRE9NIGVsZW1lbnQsIHRyeSB0byBnZXQgdGhlIG91dGVyIEhUTUwuXG4gIGlmIChpc0RPTUVsZW1lbnQodmFsdWUpKSB7XG4gICAgaWYgKCdvdXRlckhUTUwnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUub3V0ZXJIVE1MO1xuICAgICAgLy8gVGhpcyB2YWx1ZSBkb2VzIG5vdCBoYXZlIGFuIG91dGVySFRNTCBhdHRyaWJ1dGUsXG4gICAgICAvLyAgIGl0IGNvdWxkIHN0aWxsIGJlIGFuIFhNTCBlbGVtZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gc2VyaWFsaXplIGl0XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZG9jdW1lbnQueG1sVmVyc2lvbikge1xuICAgICAgICAgIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICByZXR1cm4geG1sU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlyZWZveCAxMS0gZG8gbm90IHN1cHBvcnQgb3V0ZXJIVE1MXG4gICAgICAgICAgLy8gICBJdCBkb2VzLCBob3dldmVyLCBzdXBwb3J0IGlubmVySFRNTFxuICAgICAgICAgIC8vICAgVXNlIHRoZSBmb2xsb3dpbmcgdG8gcmVuZGVyIHRoZSBlbGVtZW50XG4gICAgICAgICAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ18nKTtcblxuICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgICAgICAgLnJlcGxhY2UoJz48JywgJz4nICsgdmFsdWUuaW5uZXJIVE1MICsgJzwnKTtcbiAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgbm9uLW5hdGl2ZSBET00gaW1wbGVtZW50YXRpb24sXG4gICAgICAgIC8vICAgY29udGludWUgd2l0aCB0aGUgbm9ybWFsIGZsb3c6XG4gICAgICAgIC8vICAgcHJpbnRpbmcgdGhlIGVsZW1lbnQgYXMgaWYgaXQgaXMgYW4gb2JqZWN0LlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIHZpc2libGVLZXlzID0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXModmFsdWUpO1xuICB2YXIga2V5cyA9IGN0eC5zaG93SGlkZGVuID8gZ2V0UHJvcGVydGllcyh2YWx1ZSkgOiB2aXNpYmxlS2V5cztcblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIC8vIEluIElFLCBlcnJvcnMgaGF2ZSBhIHNpbmdsZSBgc3RhY2tgIHByb3BlcnR5LCBvciBpZiB0aGV5IGFyZSB2YW5pbGxhIGBFcnJvcmAsXG4gIC8vIGEgYHN0YWNrYCBwbHVzIGBkZXNjcmlwdGlvbmAgcHJvcGVydHk7IGlnbm9yZSB0aG9zZSBmb3IgY29uc2lzdGVuY3kuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAoaXNFcnJvcih2YWx1ZSkgJiYgKFxuICAgICAgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdzdGFjaycpIHx8XG4gICAgICAoa2V5cy5sZW5ndGggPT09IDIgJiYga2V5c1swXSA9PT0gJ2Rlc2NyaXB0aW9uJyAmJiBrZXlzWzFdID09PSAnc3RhY2snKVxuICAgICApKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICB2YXIgbmFtZVN1ZmZpeCA9IG5hbWUgPyAnOiAnICsgbmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKHZhbHVlID09PSAwICYmICgxL3ZhbHVlKSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnLTAnLCAnbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgfVxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0cjtcbiAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXyhrZXkpKSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlzaWJsZUtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcikgfHxcbiAgICAgICAgICh0eXBlb2YgYXIgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGFyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiB0eXBlb2YgcmUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qKlxuICogIyMjIC5vYmpEaXNwbGF5IChvYmplY3QpXG4gKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgbWF0Y2hlc1xuICogY3JpdGVyaWEgdG8gYmUgaW5zcGVjdGVkIGluLWxpbmUgZm9yIGVycm9yXG4gKiBtZXNzYWdlcyBvciBzaG91bGQgYmUgdHJ1bmNhdGVkLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGphdmFzY3JpcHQgb2JqZWN0IHRvIGluc3BlY3RcbiAqIEBuYW1lIG9iakRpc3BsYXlcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSBpbnNwZWN0KG9iailcbiAgICAsIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcblxuICBpZiAoY29uZmlnLnRydW5jYXRlVGhyZXNob2xkICYmIHN0ci5sZW5ndGggPj0gY29uZmlnLnRydW5jYXRlVGhyZXNob2xkKSB7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgIHJldHVybiAhb2JqLm5hbWUgfHwgb2JqLm5hbWUgPT09ICcnXG4gICAgICAgID8gJ1tGdW5jdGlvbl0nXG4gICAgICAgIDogJ1tGdW5jdGlvbjogJyArIG9iai5uYW1lICsgJ10nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuICdbIEFycmF5KCcgKyBvYmoubGVuZ3RoICsgJykgXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICwga3N0ciA9IGtleXMubGVuZ3RoID4gMlxuICAgICAgICAgID8ga2V5cy5zcGxpY2UoMCwgMikuam9pbignLCAnKSArICcsIC4uLidcbiAgICAgICAgICA6IGtleXMuam9pbignLCAnKTtcbiAgICAgIHJldHVybiAneyBPYmplY3QgKCcgKyBrc3RyICsgJykgfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgY2hhaW5hYmxlIG1ldGhvZFxuICogYW5kIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgcHJldmlvdXMgZnVuY3Rpb24gb3JcbiAqIHByb3BlcnR5LiAgTXVzdCByZXR1cm4gZnVuY3Rpb25zIHRvIGJlIHVzZWQgZm9yXG4gKiBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnbGVuZ3RoJyxcbiAqICAgICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICAsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICApO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aCgzKTtcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDMpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCAvIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgLyBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHByb3BlcnR5XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0gY3R4Ll9fbWV0aG9kc1tuYW1lXTtcblxuICB2YXIgX2NoYWluaW5nQmVoYXZpb3IgPSBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yO1xuICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBjaGFpbmluZ0JlaGF2aW9yKF9jaGFpbmluZ0JlaGF2aW9yKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIF9tZXRob2QgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2Q7XG4gIGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9tZXRob2QpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZU1ldGhvZCAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBtZXRob2QgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgZnVuY3Rpb24uIE11c3QgcmV0dXJuIGZ1bmN0aW9uXG4gKiB0byBiZSB1c2VkIGZvciBuYW1lLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZXF1YWwnLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLnZhbHVlKS50by5lcXVhbChzdHIpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uZXF1YWwoJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIG1ldGhvZCBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCkge1xuICB2YXIgX21ldGhvZCA9IGN0eFtuYW1lXVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuICBpZiAoX21ldGhvZCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX21ldGhvZClcbiAgICBfc3VwZXIgPSBfbWV0aG9kO1xuXG4gIGN0eFtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9zdXBlcikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZVByb3BlcnR5IChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIHByb3BlcnR5IGdldHRlciBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyB2YWx1ZS4gTXVzdCByZXR1cm4gZnVuY3Rpb24gdG8gdXNlIGFzIGdldHRlci5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnb2snLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICogICAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBGb28pIHtcbiAqICAgICAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqLm5hbWUpLnRvLmVxdWFsKCdiYXInKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZVByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLm9rO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHdob3NlIHByb3BlcnR5IGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgb3ZlcndyaXRlUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgdmFyIF9nZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgbmFtZSlcbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGlmIChfZ2V0ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfZ2V0LmdldClcbiAgICBfc3VwZXIgPSBfZ2V0LmdldFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlcihfc3VwZXIpLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdGVzdCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyoqXG4gKiAjIHRlc3Qob2JqZWN0LCBleHByZXNzaW9uKVxuICpcbiAqIFRlc3QgYW5kIG9iamVjdCBmb3IgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRlc3RcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIGV4cHIgPSBhcmdzWzBdO1xuICByZXR1cm4gbmVnYXRlID8gIWV4cHIgOiBleHByO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRyYW5zZmVyRmxhZ3MgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIHRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGFuZCBgbWVzc2FnZWApXG4gKiB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJpdG9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG87IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRyYW5zZmVyRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsKSB7XG4gIHZhciBmbGFncyA9IGFzc2VydGlvbi5fX2ZsYWdzIHx8IChhc3NlcnRpb24uX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIGlmICghb2JqZWN0Ll9fZmxhZ3MpIHtcbiAgICBvYmplY3QuX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpbmNsdWRlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGluY2x1ZGVBbGwgOiB0cnVlO1xuXG4gIGZvciAodmFyIGZsYWcgaW4gZmxhZ3MpIHtcbiAgICBpZiAoaW5jbHVkZUFsbCB8fFxuICAgICAgICAoZmxhZyAhPT0gJ29iamVjdCcgJiYgZmxhZyAhPT0gJ3NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2VxbCcpO1xuIiwiLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogQnVmZmVyLmlzQnVmZmVyIGJyb3dzZXIgc2hpbVxuICovXG5cbnZhciBCdWZmZXI7XG50cnkgeyBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7IH1cbmNhdGNoKGV4KSB7XG4gIEJ1ZmZlciA9IHt9O1xuICBCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBFcXVhbDtcblxuLyoqXG4gKiBBc3NlcnQgc3VwZXItc3RyaWN0IChlZ2FsKSBlcXVhbGl0eSBiZXR3ZWVuXG4gKiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1vaXNlZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiLCBtKSB7XG4gIGlmIChzYW1lVmFsdWUoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICgnZGF0ZScgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gZGF0ZUVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKCdyZWdleHAnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIHJlZ2V4cEVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhKSkge1xuICAgIHJldHVybiBidWZmZXJFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgnYXJndW1lbnRzJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKTtcbiAgfSBlbHNlIGlmICghdHlwZUVxdWFsKGEsIGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKCgnb2JqZWN0JyAhPT0gdHlwZShhKSAmJiAnb2JqZWN0JyAhPT0gdHlwZShiKSlcbiAgJiYgKCdhcnJheScgIT09IHR5cGUoYSkgJiYgJ2FycmF5JyAhPT0gdHlwZShiKSkpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlKGEsIGIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3RFcXVhbChhLCBiLCBtKTtcbiAgfVxufVxuXG4vKiFcbiAqIFN0cmljdCAoZWdhbCkgZXF1YWxpdHkgdGVzdC4gRW5zdXJlcyB0aGF0IE5hTiBhbHdheXNcbiAqIGVxdWFscyBOYU4gYW5kIGAtMGAgZG9lcyBub3QgZXF1YWwgYCswYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIHNhbWVWYWx1ZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0aGUgdHlwZXMgb2YgdHdvIGdpdmVuIG9iamVjdHMgYW5kXG4gKiByZXR1cm4gaWYgdGhleSBhcmUgZXF1YWwuIE5vdGUgdGhhdCBhbiBBcnJheVxuICogaGFzIGEgdHlwZSBvZiBgYXJyYXlgIChub3QgYG9iamVjdGApIGFuZCBhcmd1bWVudHNcbiAqIGhhdmUgYSB0eXBlIG9mIGBhcmd1bWVudHNgIChub3QgYGFycmF5YC9gb2JqZWN0YCkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gdHlwZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIHR5cGUoYSkgPT09IHR5cGUoYik7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gRGF0ZSBvYmplY3RzIGJ5IGFzc2VydGluZyB0aGF0XG4gKiB0aGUgdGltZSB2YWx1ZXMgYXJlIGVxdWFsIHVzaW5nIGBzYXZlVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gYVxuICogQHBhcmFtIHtEYXRlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBkYXRlRXF1YWwoYSwgYikge1xuICBpZiAoJ2RhdGUnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzYW1lVmFsdWUoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byByZWd1bGFyIGV4cHJlc3Npb25zIGJ5IGNvbnZlcnRpbmcgdGhlbVxuICogdG8gc3RyaW5nIGFuZCBjaGVja2luZyBmb3IgYHNhbWVWYWx1ZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IGFcbiAqIEBwYXJhbSB7UmVnRXhwfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChhLCBiKSB7XG4gIGlmICgncmVnZXhwJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbn1cblxuLyohXG4gKiBBc3NlcnQgZGVlcCBlcXVhbGl0eSBvZiB0d28gYGFyZ3VtZW50c2Agb2JqZWN0cy5cbiAqIFVuZm9ydHVuYXRlbHksIHRoZXNlIG11c3QgYmUgc2xpY2VkIHRvIGFycmF5c1xuICogcHJpb3IgdG8gdGVzdCB0byBlbnN1cmUgbm8gYmFkIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2l6ZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBhcmd1bWVudHNFcXVhbChhLCBiLCBtKSB7XG4gIGlmICgnYXJndW1lbnRzJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICBhID0gW10uc2xpY2UuY2FsbChhKTtcbiAgYiA9IFtdLnNsaWNlLmNhbGwoYik7XG4gIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgbSk7XG59XG5cbi8qIVxuICogR2V0IGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHJldHVybiB7QXJyYXl9IHByb3BlcnR5IG5hbWVzXG4gKi9cblxuZnVuY3Rpb24gZW51bWVyYWJsZShhKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGEpIHJlcy5wdXNoKGtleSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qIVxuICogU2ltcGxlIGVxdWFsaXR5IGZvciBmbGF0IGl0ZXJhYmxlIG9iamVjdHNcbiAqIHN1Y2ggYXMgQXJyYXlzIG9yIE5vZGUuanMgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBhXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSAgYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgaSA9IDA7XG4gIHZhciBtYXRjaCA9IHRydWU7XG5cbiAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qIVxuICogRXh0ZW5zaW9uIHRvIGBpdGVyYWJsZUVxdWFsYCBzcGVjaWZpY2FsbHlcbiAqIGZvciBOb2RlLmpzIEJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGJ1ZmZlckVxdWFsKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwoYSwgYik7XG59XG5cbi8qIVxuICogQmxvY2sgZm9yIGBvYmplY3RFcXVhbGAgZW5zdXJpbmcgbm9uLWV4aXN0aW5nXG4gKiB2YWx1ZXMgZG9uJ3QgZ2V0IGluLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXNWYWx1ZShhKSB7XG4gIHJldHVybiBhICE9PSBudWxsICYmIGEgIT09IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIG9iamVjdHMuXG4gKiBPbmNlIGJhc2ljIHNhbWVuZXNzIGhhcyBiZWVuIGVzdGFibGlzaGVkIGl0IHdpbGxcbiAqIGRlZmVyIHRvIGBkZWVwRXF1YWxgIGZvciBlYWNoIGVudW1lcmFibGUga2V5XG4gKiBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKCFpc1ZhbHVlKGEpIHx8ICFpc1ZhbHVlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpO1xuICBpZiAobSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKG1baV1bMF0gPT09IGEgJiYgbVtpXVsxXSA9PT0gYilcbiAgICAgIHx8ICAobVtpXVswXSA9PT0gYiAmJiBtW2ldWzFdID09PSBhKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbSA9IFtdO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBlbnVtZXJhYmxlKGEpO1xuICAgIHZhciBrYiA9IGVudW1lcmFibGUoYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG5cbiAgaWYgKCFpdGVyYWJsZUVxdWFsKGthLCBrYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtLnB1c2goWyBhLCBiIF0pO1xuXG4gIHZhciBrZXk7XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3R5cGUnKTtcbiIsIi8qIVxuICogdHlwZS1kZXRlY3RcbiAqIENvcHlyaWdodChjKSAyMDEzIGpha2UgbHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ2V0VHlwZTtcblxuLyohXG4gKiBEZXRlY3RhYmxlIGphdmFzY3JpcHQgbmF0aXZlc1xuICovXG5cbnZhciBuYXRpdmVzID0ge1xuICAgICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheSdcbiAgLCAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ2V4cCdcbiAgLCAnW29iamVjdCBGdW5jdGlvbl0nOiAnZnVuY3Rpb24nXG4gICwgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnXG4gICwgJ1tvYmplY3QgRGF0ZV0nOiAnZGF0ZSdcbn07XG5cbi8qKlxuICogIyMjIHR5cGVPZiAob2JqKVxuICpcbiAqIFVzZSBzZXZlcmFsIGRpZmZlcmVudCB0ZWNobmlxdWVzIHRvIGRldGVybWluZVxuICogdGhlIHR5cGUgb2Ygb2JqZWN0IGJlaW5nIHRlc3RlZC5cbiAqXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFR5cGUgKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gIGlmIChuYXRpdmVzW3N0cl0pIHJldHVybiBuYXRpdmVzW3N0cl07XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAob2JqID09PSBPYmplY3Qob2JqKSkgcmV0dXJuICdvYmplY3QnO1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn1cblxuZXhwb3J0cy5MaWJyYXJ5ID0gTGlicmFyeTtcblxuLyoqXG4gKiAjIyMgTGlicmFyeVxuICpcbiAqIENyZWF0ZSBhIHJlcG9zaXRvcnkgZm9yIGN1c3RvbSB0eXBlIGRldGVjdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGxpYiA9IG5ldyB0eXBlLkxpYnJhcnk7XG4gKiBgYGBcbiAqXG4gKi9cblxuZnVuY3Rpb24gTGlicmFyeSAoKSB7XG4gIHRoaXMudGVzdHMgPSB7fTtcbn1cblxuLyoqXG4gKiAjIyMjIC5vZiAob2JqKVxuICpcbiAqIEV4cG9zZSByZXBsYWNlbWVudCBgdHlwZW9mYCBkZXRlY3Rpb24gdG8gdGhlIGxpYnJhcnkuXG4gKlxuICogYGBganNcbiAqIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKCdoZWxsbyB3b3JsZCcpKSB7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLm9mID0gZ2V0VHlwZTtcblxuLyoqXG4gKiAjIyMjIC5kZWZpbmUgKHR5cGUsIHRlc3QpXG4gKlxuICogQWRkIGEgdGVzdCB0byBmb3IgdGhlIGAudGVzdCgpYCBhc3NlcnRpb24uXG4gKlxuICogQ2FuIGJlIGRlZmluZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2ludCcsIC9eWzAtOV0rJC8pO1xuICogYGBgXG4gKlxuICogLi4uIG9yIGFzIGEgZnVuY3Rpb246XG4gKlxuICogYGBganNcbiAqIGxpYi5kZWZpbmUoJ2JsbicsIGZ1bmN0aW9uIChvYmopIHtcbiAqICAgaWYgKCdib29sZWFuJyA9PT0gbGliLm9mKG9iaikpIHJldHVybiB0cnVlO1xuICogICB2YXIgYmxucyA9IFsgJ3llcycsICdubycsICd0cnVlJywgJ2ZhbHNlJywgMSwgMCBdO1xuICogICBpZiAoJ3N0cmluZycgPT09IGxpYi5vZihvYmopKSBvYmogPSBvYmoudG9Mb3dlckNhc2UoKTtcbiAqICAgcmV0dXJuICEhIH5ibG5zLmluZGV4T2Yob2JqKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7UmVnRXhwfEZ1bmN0aW9ufSB0ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICh0eXBlLCB0ZXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50ZXN0c1t0eXBlXTtcbiAgdGhpcy50ZXN0c1t0eXBlXSA9IHRlc3Q7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAjIyMjIC50ZXN0IChvYmosIHRlc3QpXG4gKlxuICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUuIFdpbGwgZmlyc3RcbiAqIGNoZWNrIG5hdGl2ZXMsIGFuZCBpZiB0aGF0IGRvZXMgbm90IHBhc3MgaXQgd2lsbFxuICogdXNlIHRoZSB1c2VyIGRlZmluZWQgY3VzdG9tIHRlc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBhc3NlcnQobGliLnRlc3QoJzEnLCAnaW50JykpO1xuICogYXNzZXJ0KGxpYi50ZXN0KCd5ZXMnLCAnYmxuJykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSBnZXRUeXBlKG9iaikpIHJldHVybiB0cnVlO1xuICB2YXIgdGVzdCA9IHRoaXMudGVzdHNbdHlwZV07XG5cbiAgaWYgKHRlc3QgJiYgJ3JlZ2V4cCcgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdC50ZXN0KG9iaik7XG4gIH0gZWxzZSBpZiAodGVzdCAmJiAnZnVuY3Rpb24nID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3Qob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ1R5cGUgdGVzdCBcIicgKyB0eXBlICsgJ1wiIG5vdCBkZWZpbmVkIG9yIGludmFsaWQuJyk7XG4gIH1cbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohXG4gKiB0eXBlLWRldGVjdFxuICogQ29weXJpZ2h0KGMpIDIwMTMgamFrZSBsdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRUeXBlO1xuXG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2Ugc2V2ZXJhbCBkaWZmZXJlbnQgdGVjaG5pcXVlcyB0byBkZXRlcm1pbmVcbiAqIHRoZSB0eXBlIG9mIG9iamVjdCBiZWluZyB0ZXN0ZWQuXG4gKlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xudmFyIG9iamVjdFR5cGVSZWdleHAgPSAvXlxcW29iamVjdCAoLiopXFxdJC87XG5cbmZ1bmN0aW9uIGdldFR5cGUob2JqKSB7XG4gIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2gob2JqZWN0VHlwZVJlZ2V4cClbMV0udG9Mb3dlckNhc2UoKTtcbiAgLy8gTGV0IFwibmV3IFN0cmluZygnJylcIiByZXR1cm4gJ29iamVjdCdcbiAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiAncHJvbWlzZSc7XG4gIC8vIFBoYW50b21KUyBoYXMgdHlwZSBcIkRPTVdpbmRvd1wiIGZvciBudWxsXG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIC8vIFBoYW50b21KUyBoYXMgdHlwZSBcIkRPTVdpbmRvd1wiIGZvciB1bmRlZmluZWRcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnRzLkxpYnJhcnkgPSBMaWJyYXJ5O1xuXG4vKipcbiAqICMjIyBMaWJyYXJ5XG4gKlxuICogQ3JlYXRlIGEgcmVwb3NpdG9yeSBmb3IgY3VzdG9tIHR5cGUgZGV0ZWN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGliID0gbmV3IHR5cGUuTGlicmFyeTtcbiAqIGBgYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBMaWJyYXJ5KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlicmFyeSkpIHJldHVybiBuZXcgTGlicmFyeSgpO1xuICB0aGlzLnRlc3RzID0ge307XG59XG5cbi8qKlxuICogIyMjIyAub2YgKG9iailcbiAqXG4gKiBFeHBvc2UgcmVwbGFjZW1lbnQgYHR5cGVvZmAgZGV0ZWN0aW9uIHRvIHRoZSBsaWJyYXJ5LlxuICpcbiAqIGBgYGpzXG4gKiBpZiAoJ3N0cmluZycgPT09IGxpYi5vZignaGVsbG8gd29ybGQnKSkge1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5vZiA9IGdldFR5cGU7XG5cbi8qKlxuICogIyMjIyAuZGVmaW5lICh0eXBlLCB0ZXN0KVxuICpcbiAqIEFkZCBhIHRlc3QgdG8gZm9yIHRoZSBgLnRlc3QoKWAgYXNzZXJ0aW9uLlxuICpcbiAqIENhbiBiZSBkZWZpbmVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdpbnQnLCAvXlswLTldKyQvKTtcbiAqIGBgYFxuICpcbiAqIC4uLiBvciBhcyBhIGZ1bmN0aW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdibG4nLCBmdW5jdGlvbiAob2JqKSB7XG4gKiAgIGlmICgnYm9vbGVhbicgPT09IGxpYi5vZihvYmopKSByZXR1cm4gdHJ1ZTtcbiAqICAgdmFyIGJsbnMgPSBbICd5ZXMnLCAnbm8nLCAndHJ1ZScsICdmYWxzZScsIDEsIDAgXTtcbiAqICAgaWYgKCdzdHJpbmcnID09PSBsaWIub2Yob2JqKSkgb2JqID0gb2JqLnRvTG93ZXJDYXNlKCk7XG4gKiAgIHJldHVybiAhISB+Ymxucy5pbmRleE9mKG9iaik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbn0gdGVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbih0eXBlLCB0ZXN0KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50ZXN0c1t0eXBlXTtcbiAgdGhpcy50ZXN0c1t0eXBlXSA9IHRlc3Q7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiAjIyMjIC50ZXN0IChvYmosIHRlc3QpXG4gKlxuICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIG9mIHR5cGUuIFdpbGwgZmlyc3RcbiAqIGNoZWNrIG5hdGl2ZXMsIGFuZCBpZiB0aGF0IGRvZXMgbm90IHBhc3MgaXQgd2lsbFxuICogdXNlIHRoZSB1c2VyIGRlZmluZWQgY3VzdG9tIHRlc3RzLlxuICpcbiAqIGBgYGpzXG4gKiBhc3NlcnQobGliLnRlc3QoJzEnLCAnaW50JykpO1xuICogYXNzZXJ0KGxpYi50ZXN0KCd5ZXMnLCAnYmxuJykpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpYnJhcnkucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihvYmosIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IGdldFR5cGUob2JqKSkgcmV0dXJuIHRydWU7XG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0c1t0eXBlXTtcblxuICBpZiAodGVzdCAmJiAncmVnZXhwJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0LnRlc3Qob2JqKTtcbiAgfSBlbHNlIGlmICh0ZXN0ICYmICdmdW5jdGlvbicgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdChvYmopO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVHlwZSB0ZXN0IFwiJyArIHR5cGUgKyAnXCIgbm90IGRlZmluZWQgb3IgaW52YWxpZC4nKTtcbiAgfVxufTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB4YXBpRXJyb3JMZXZlbHMgPSBPYmplY3QuZnJlZXplKHtcbiAgTUFZX1ZJT0xBVElPTjogICAgJ01BWV9WSU9MQVRJT04nLFxuICBNVVNUX1ZJT0xBVElPTjogICAnTVVTVF9WSU9MQVRJT04nLFxuICBTSE9VTERfVklPTEFUSU9OOiAnU0hPVUxEX1ZJT0xBVElPTidcbn0pO1xuXG5jb25zdCB4YXBpVmFsaWRhdGlvbkVycm9ycyA9IE9iamVjdC5mcmVlemUoe1xuICBBQ1RJVklUSUVTX01VU1RfTk9UX0JFX05VTExfTUFQX09CSkVDVFM6ICAgICAgICAgICdBY3Rpdml0aWVzIG11c3QgYmUgbm9uLW51bGwgbWFwIG9iamVjdHMnLFxuICBBQ1RPUl9NVVNUX0JFX1BST1ZJREVEOiAgICAgICAgICAgICAgICAgICAgICAgICAgICdBY3RvciBtdXN0IGJlIHByb3ZpZGVkLicsXG4gIEFHRU5UX0lGSV9QUk9QRVJUSUVTX01VU1RfQkVfU1BFQ0lGSUVEOiAgICAgICAgICAgJ0V4YWN0bHkgb25lIEludmVyc2UgRnVuY3Rpb25hbCBJZGVudGlmaWVyIHByb3BlcnR5IG11c3QgYmUgc3BlY2lmaWVkIGZvciBhbiBcImFnZW50XCIuJyxcbiAgQUdFTlRfTVVTVF9CRV9OT05fTlVMTF9NQVBfT0JKRUNUOiAgICAgICAgICAgICAgICAnXCJhZ2VudFwiIG11c3QgYmUgYSBub24tbnVsbCBtYXAgb2JqZWN0JyxcbiAgQUdFTlRfTVVTVF9OT1RfSEFWRV9HUk9VUF9DSEFSQUNURVJJU1RJQ1M6ICAgICAgICAnSW52YWxpZCBvYmplY3Qgd2l0aCBjaGFyYWN0ZXJpc3RpY3Mgb2YgYSBHcm91cCB3aGVuIGFuIEFnZW50IHdhcyBleHBlY3RlZC4nLFxuICBBVFRBQ0hNRU5UU19NVVNUX0JFX05PVF9OVUxMX0FSUkFZOiAgICAgICAgICAgICAgICdcImF0dGFjaG1lbnRzXCIgbXVzdCBiZSBhIG5vbi1udWxsIEFycmF5LicsXG4gIEFUVEFDSE1FTlRTX01VU1RfTk9UX0JFX05VTExfTUFQX09CSkVDVFM6ICAgICAgICAgJ1wiYXR0YWNobWVudFwiIGluc3RhbmNlcyBtdXN0IGJlIG5vbi1udWxsIG1hcCBvYmplY3RzLicsXG4gIEFVVEhPUklUWV9NVVNUX0JFX05PTl9OVUxMX01BUF9PQkpFQ1Q6ICAgICAgICAgICAgJ0lmIHByZXNlbnQsIHRoZSBcImF1dGhvcml0eVwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tbnVsbCBtYXAgb2JqZWN0LicsXG4gIENPTlRFWFRfQUNUSVZJVElFU19NVVNUX0JFX0FSUkFZX09SX0FDVElWSVRZX09CSjogJ0NvbnRleHQgQWN0aXZpdGllcyBwcm9wZXJ0eSB2YWx1ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBBY3Rpdml0eSBPYmplY3RzIG9yIGEgc2luZ2xlIEFjdGl2aXR5IE9iamVjdC4nLFxuICBDT05URVhUX0FDVElWSVRJRVNfTVVTVF9CRV9OT05fTlVMTF9NQVBfT0JKRUNUOiAgICdUaGUgQ29udGV4dCBBY3Rpdml0aWVzIGluc3RhbmNlcyBtdXN0IGJlIGEgbm9uLW51bGwgbWFwIG9iamVjdC4nLFxuICBDT05URVhUX0FDVElWSVRJRVNfTVVTVF9OT1RfQkVfTlVMTDogICAgICAgICAgICAgICdcIkNvbnRleHQgQWN0aXZpdGllc1wiIHByb3BlcnR5IHZhbHVlcyBtdXN0IG5vdCBiZSBudWxsLicsXG4gIENPTlRFWFRfQUNUSVZJVElFU19TSE9VTERfQkVfQU5fQVJSQVk6ICAgICAgICAgICAgJ0NvbnRleHQgQWN0aXZpdGllcyBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkIHByZWZlciB0byBiZSBhbiBhcnJheSBvZiBBY3Rpdml0aWVzIHJhdGhlciB0aGFuIGEgc2luZ2xlIEFjdGl2aXR5IG9iamVjdC4nLFxuICBDT05URVhUX01VU1RfQkVfTk9OX05VTF9NQVBfT0JKRUNUOiAgICAgICAgICAgICAgICdJZiBwcmVzZW50LCB0aGUgXCJjb250ZXh0XCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbi1udWxsIG1hcCBvYmplY3QuJyxcbiAgQ09SUkVDVF9SRVNQT05TRVNfUEFUVEVSTl9NVVNUX0JFX0FSUkFZOiAgICAgICAgICAnSWYgcHJlc2VudCwgdGhlIFwiY29ycmVjdFJlc3BvbnNlc1BhdHRlcm5cIiB2YWx1ZSBtdXN0IGJlIGFuIEFycmF5IG9mIHN0cmluZ3MuJyxcbiAgQ09SUkVDVF9SRVNQT05TRVNfUEFUVEVSTl9NVVNUX0JFX1NUUklOR1M6ICAgICAgICAnXCJjb3JyZWN0UmVzcG9uc2VzUGF0dGVyblwiIGl0ZW1zIG11c3QgYmUgc3RyaW5ncy4nLFxuICBEQVRFX01VU1RfQkVfVkFMSUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGlzIHByb3BlcnR5cyBzdHJpbmcgdmFsdWUgbXVzdCBiZSBjb25mb3JtYW50IHRvIElTTyA4NjAxIGZvciBEYXRlIFRpbWVzLicsXG4gIERBVEVfU0hPVUxEX0lOQ0xVREVfWk9ORV9JTkZPUk1BVElPTjogICAgICAgICAgICAgJ0lTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmdzIHVzZWQgaW4gdGhlIHhBUEkgc2hvdWxkIGluY2x1ZGUgdGltZSB6b25lIGluZm9ybWF0aW9uLicsXG4gIERFRklOSVRJT05TX01VU1RfQkVfT0JKRUNUUzogICAgICAgICAgICAgICAgICAgICAgJ1wiZGVmaW5pdGlvbnNcIiwgd2hlbiBwcmVzZW50LCBtdXN0IGJlIG1hcCBvYmplY3RzJyxcbiAgRElTUExBWV9TSE9VTERfQkVfUFJPVklERUQ6ICAgICAgICAgICAgICAgICAgICAgICAnXCJkaXNwbGF5XCIgcHJvcGVydHkgc2hvdWxkIGJlIHByb3ZpZGVkLicsXG4gIERVUkFUSU9OX01VU1RfQkVfVkFMSUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0lmIHByZXNlbnQsIHRoZSBcImR1cmF0aW9uXCIgcHJvcGVydHkgdmFsdWUgbXVzdCBiZSBhbiBJU08gODYwMSBkdXJhdGlvbicsXG4gIEVYVEVOU0lPTlNfTVVTVF9OT1RfQkVfTlVMTDogICAgICAgICAgICAgICAgICAgICAgJ0lmIHByZXNlbnQsIHRoZSBleHRlbnNpb25zIHByb3BlcnR5IG11c3QgYmUgYSBub24tbnVsbCBtYXAgb2JqZWN0LicsXG4gIEdST1VQX0FVVEhPUklUWV9BR0VOVF9NRU1CRVJTX01VU1RfQkVfVFdPOiAgICAgICAgJ0lmIHVzZWQgYXMgYSBHcm91cCwgdGhlIFwiYXV0aG9yaXR5XCIgcHJvcGVydHkgbXVzdCBjb250YWluIGEgXCJtZW1iZXJcIiBwcm9wZXJ0eSB0aGF0IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgZXhhY3RseSB0d28gQWdlbnQgb2JqZWN0cy4nLFxuICBHUk9VUF9JRklfUFJPUEVSVElFU19NVVNUX0JFX1NQRUNJRklFRDogICAgICAgICAgICdFeGFjdGx5IG9uZSBJbnZlcnNlIEZ1bmN0aW9uYWwgSWRlbnRpZmllciBwcm9wZXJ0eSBtdXN0IGJlIHNwZWNpZmllZCBmb3IgYSBcImdyb3VwXCIuJyxcbiAgR1JPVVBfTUVNQkVSX01VU1RfQkVfQVJSQVk6ICAgICAgICAgICAgICAgICAgICAgICAnSWYgcHJlc2VudCwgdGhlIG1lbWJlciBwcm9wZXJ0eSBvZiBhIEdyb3VwIG11c3QgYmUgYW4gQXJyYXknLFxuICBHUk9VUF9NVVNUX0JFX05PTl9OVUxMX01BUF9PQkpFQ1Q6ICAgICAgICAgICAgICAgICdcImdyb3VwXCIgbXVzdCBiZSBhIG5vbi1udWxsIG1hcCBvYmplY3QnLFxuICBJRF9NVVNUX0JFX1VOSVFVRTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcImlkXCIgcHJvcGVydGllcyBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gZWFjaCBpbnRlcmFjdGlvbiBjb21wb25lbnQgYXJyYXknLFxuICBJRF9NVVNUX0JFX1ZBTElEX1VVSURfUkVGOiAgICAgICAgICAgICAgICAgICAgICAgICdcImlkXCIgcHJvcGVydHkgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIFVVSUQgc3RyaW5nIGZvciBzdGF0ZW1lbnQgcmVmZXJlbmNlIG9iamVjdHMuJyxcbiAgSURfTVVTVF9CRV9WQUxJRDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSWQgd2FzIG5vdCBhIHZhbGlkIFVVSUQnLFxuICBJRF9TSE9VTERfTk9UX0NPTlRBSU5fV0hJVEVTUEFDRVM6ICAgICAgICAgICAgICAgICdcImlkXCIgcHJvcGVydGllcyBvbiBpbnRlcmFjdGlvbiBjb21wb25lbnRzIHNob3VsZCBub3QgY29udGFpbiB3aGl0ZXNwYWNlJyxcbiAgSURTX1NIT1VMRF9CRV9HRU5FUkFURURfQllfTFJTOiAgICAgICAgICAgICAgICAgICAnSWRzIHNob3VsZCBiZSBnZW5lcmF0ZWQgYnkgdGhlIEFjdGl2aXR5IFByb3ZpZGVyLCBhbmQgbXVzdCBiZSBnZW5lcmF0ZWQgYnkgdGhlIExSUycsXG4gIElGSV9NVVNUX0JFX01CT1hfVVJJOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wibWJveFwiIHByb3BlcnR5IHdhcyByZXF1aXJlZCB0byBiZSBhIG1haWx0byBVUkkgc3RyaW5nIGJ1dCB3YXMgbm90IGEgc3RyaW5nIGF0IGFsbC4nLFxuICBJRklfTVVTVF9CRV9WQUxJRF9NQk9YX0ZPUk1BVDogICAgICAgICAgICAgICAgICAgICdcIm1ib3hcIiBwcm9wZXJ0eSB3YXMgcmVxdWlyZWQgdG8gYmUgYSBtYWlsdG8gVVJJIHN0cmluZyBidXQgZGlkIG5vdCBtYXRjaCB0aGUgbWFpbHRvIGZvcm1hdC4nLFxuICBJTlRFUkFDVElPTl9BQ1RJVklUWV9TSE9VTERfSEFWRTogICAgICAgICAgICAgICAgICdJbnRlcmFjdGlvbiBBY3Rpdml0eSBEZWZpbml0aW9ucyBzaG91bGQgaGF2ZSBhIHR5cGUgcHJvcGVydHkgb2YnLFxuICBJTlRFUkFDVElPTl9DT01QT05FTlRfTVVTVF9OT1RfQkVfTlVMTDogICAgICAgICAgICdUaGlzIGludGVyYWN0aW9uIGNvbXBvbmVudCBjb2xsZWN0aW9uIG1lbWJlciBtdXN0IGJlIGEgbm9uLW51bGwgbWFwIG9iamVjdCcsXG4gIElOVEVSQUNUSU9OX0NPTVBPTkVOVF9TSE9VTERfQkVfQVJSQVk6ICAgICAgICAgICAgJ1RoaXMgaW50ZXJhY3Rpb24gY29tcG9uZW50IGNvbGxlY3Rpb24gcHJvcGVydHkgc2hvdWxkIGJlIGFuIGFycmF5LicsXG4gIElOVEVSQUNUSU9OX1RZUEVfTVVTVF9CRV9DTUk6ICAgICAgICAgICAgICAgICAgICAgJ0lmIHByZXNlbnQsIHRoZSBcImludGVyYWN0aW9uVHlwZVwiIHZhbHVlIG11c3QgYmUgYSBDTUkgaW50ZXJhY3Rpb24gdHlwZSBvcHRpb24uJyxcbiAgSU5URVJBQ1RJT05fVFlQRV9NVVNUX0JFX1ZBTElEOiAgICAgICAgICAgICAgICAgICAnVGhpcyBpbnRlcmFjdGlvbiBjb21wb25lbnQgY29sbGVjdGlvbiBwcm9wZXJ0eSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcmVzZW50IGludGVyYWN0aW9uVHlwZSBvZjogJyxcbiAgSU5WQUxJRF9KU09OOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBKU09OLiBUaGUgc3RhdGVtZW50IGNvdWxkIG5vdCBiZSBwYXJzZWQuJyxcbiAgTEFOR1VBR0VfTUFQX0tFWV9JTlZBTElEOiAgICAgICAgICAgICAgICAgICAgICAgICAna2V5LCBMYW5ndWFnZSBkb2VzIG5vdCBjb25mb3JtIHRvIFJGQyA1NjQ2JyxcbiAgTEFOR1VBR0VfTUFQX0tFWV9NVVNUX0JFX1NUUklORzogICAgICAgICAgICAgICAgICAna2V5OiBMYW5ndWFnZSBNYXAgdmFsdWUgc2hvdWxkIGJlIGEgU3RyaW5nLCBidXQgd2FzIG5vdCcsXG4gIExBTkdVQUdFX01BUFNfTVVTVF9OT1RfQkVfTlVMTDogICAgICAgICAgICAgICAgICAgJ0xhbmd1YWdlIE1hcHMsIHdoZW4gcHJlc2VudCwgbXVzdCBiZSBub24tbnVsbCBtYXAgb2JqZWN0cycsXG4gIExBTkdVQUdFX01VU1RfQkVfU1RSSU5HOiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBsYW5ndWFnZSBwcm9wZXJ0eSBtdXN0IGJlIGVuY29kZWQgYXMgYW4gUkZDIDU2NDYgY29tcGxpYW50IHN0cmluZywgYnV0IHdhcyBub3QuJyxcbiAgTEVOR1RIX01VU1RfQkVfSU5URUdFUjogICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJsZW5ndGhcIiBwcm9wZXJ0eSBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYW4gaW50ZWdlciB2YWx1ZScsXG4gIE1BWF9NVVNUX0JFX0dSRUFURVJfVEhBTl9NSU46ICAgICAgICAgICAgICAgICAgICAgJ0lmIGJvdGggXCJtYXhcIiBhbmQgXCJtaW5cIiBhcmUgcHJlc2VudCwgdGhlIG1heCBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG1pbicsXG4gIE1FTUJFUl9NVVNUX0JFX1BST1ZJREVEX0ZPUl9BTk9OWU1PVVNfR1JPVVBTOiAgICAgJ1wibWVtYmVyXCIgcHJvcGVydHkgbXVzdCBiZSBwcm92aWRlZCBmb3IgQW5vbnltb3VzIEdyb3Vwcy4nLFxuICBNVVNUX0JFX0JPT0xFQU5fUFJFU0VOVDogICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eSB3YXMgcmVxdWlyZWQgdG8gYmUgYSBCb29sZWFuIGJ1dCB3YXMgYWJzZW50LicsXG4gIE1VU1RfQkVfQk9PTEVBTjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5LCBpZiBwcmVzZW50LCBtdXN0IGJlIGEgQm9vbGVhbi4nLFxuICBNVVNUX0JFX0lSSV9TVFJJTkc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eSwgaWYgcHJlc2VudCwgc2hvdWxkIGJlIGEgSVJJLWxpa2UgYWJzb2x1dGUgVVJJIHBlciBSRkMgMzk4Ny4nLFxuICBNVVNUX0JFX05VTUJFUl9QUkVTRU5UOiAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eSB3YXMgcmVxdWlyZWQgdG8gYmUgYSBOdW1iZXIgYnV0IHdhcyBhYnNlbnQuJyxcbiAgTVVTVF9CRV9OVU1CRVI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHksIGlmIHByZXNlbnQsIG11c3QgYmUgYSBOdW1iZXIuJyxcbiAgTVVTVF9CRV9QUkVTRU5UOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHkgd2FzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nIGJ1dCB3YXMgYWJzZW50LicsXG4gIE1VU1RfQkVfU1RSSU5HOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5LCBpZiBwcmVzZW50LCBtdXN0IGJlIGEgc3RyaW5nLicsXG4gIE1VU1RfQkVfVVJJX1BSRVNFTlQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5IHdhcyByZXF1aXJlZCB0byBiZSBhIFVSSSBzdHJpbmcgYnV0IHdhcyBhYnNlbnQuJyxcbiAgTVVTVF9CRV9VUklfU1RSSU5HOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHksIGlmIHByZXNlbnQsIG11c3QgYmUgYSBVUkkgc3RyaW5nLicsXG4gIE9CSkVDVF9NVVNUX0JFX0RFRklORUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wib2JqZWN0XCIgcHJvcGVydHkgbXVzdCBiZSBwcm92aWRlZC4nLFxuICBPQkpFQ1RfTVVTVF9CRV9OT05fTlVMTF9NQVBfT0JKRUNUOiAgICAgICAgICAgICAgICdcIm9iamVjdFwiIHByb3BlcnR5IG11c3QgYmUgYSBub24tbnVsbCBtYXAgb2JqZWN0LicsXG4gIE9CSkVDVF9UWVBFX01VU1RfQkVfU1RBVEVNRU5UX1JFRjogICAgICAgICAgICAgICAgJ1wib2JqZWN0VHlwZVwiIHByb3BlcnR5IHZhbHVlIG11c3QgYmUgXCJTdGF0ZW1lbnRSZWZcIiBmb3Igc3RhdGVtZW50IHJlZmVyZW5jZSBvYmplY3RzLicsXG4gIE9CSkVDVF9UWVBFX01VU1RfQkVfVkFMSURfT1BUSU9OOiAgICAgICAgICAgICAgICAgJ29iamVjdFxcJ3MgXCJvYmplY3RUeXBlXCIgZGlkIG5vdCBtYXRjaCBhIHZhbGlkIG9wdGlvbicsXG4gIFJBV19NVVNUX0JFX0dSRUFURVJfVEhBTl9NSU46ICAgICAgICAgICAgICAgICAgICAgJ0lmIGJvdGggXCJyYXdcIiBhbmQgXCJtaW5cIiBhcmUgcHJlc2VudCwgdGhlIHJhdyBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG1pbicsXG4gIFJBV19NVVNUX0JFX0xFU1NfVEhBTl9NQVg6ICAgICAgICAgICAgICAgICAgICAgICAgJ0lmIGJvdGggXCJyYXdcIiBhbmQgXCJtYXhcIiBhcmUgcHJlc2VudCwgdGhlIHJhdyBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmUgbGVzcyB0aGFuIG1heCcsXG4gIFJFR0lTVFJBVElPTl9NVVNUX0JFX1VVSURfU1RSSU5HOiAgICAgICAgICAgICAgICAgJ0lmIHByZXNlbnQsIHRoZSByZWdpc3RyYXRpb24gcHJvcGVydHkgbXVzdCBiZSBhIFVVSUQgc3RyaW5nLicsXG4gIFJFU1VMVF9NVVNUX0JFX01BUF9PQkpFQ1Q6ICAgICAgICAgICAgICAgICAgICAgICAgJ0lmIHByZXNlbnQsIHRoZSByZXN1bHQgbXVzdCBiZSBhIG1hcCBvYmplY3QnLFxuICBSRVZJU0lPTl9NVVNUX0JFX0FHRU5UX09SX0dST1VQOiAgICAgICAgICAgICAgICAgICdUaGUgcmV2aXNpb24gcHJvcGVydHkgbXVzdCBub3QgYmUgdXNlZCBpZiB0aGUgU3RhdGVtZW50XFwncyBPYmplY3QgaXMgYW4gQWdlbnQgb3IgR3JvdXAuJyxcbiAgU0NBTEVEX01VU1RfQkVfQkVUV0VFTl8wXzE6ICAgICAgICAgICAgICAgICAgICAgICAnSWYgcHJlc2VudCwgdGhlIHNjYWxlZCBwcm9wZXJ0eSB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMScsXG4gIFNIQTJfTVVTVF9CRV9QUk9WSURFRF9PTl9BVFRBQ0hNRU5UX09CSkVDVFM6ICAgICAgJ1wic2hhMlwiIHByb3BlcnR5IG11c3QgYmUgcHJvdmlkZWQgb24gYXR0YWNobWVudCBvYmplY3RzJyxcbiAgU0hBMl9NVVNUX0NPTlRBSU5fQkFTRV82NF9TVFJJTkc6ICAgICAgICAgICAgICAgICAnXCJzaGEyXCIgcHJvcGVydHkgbXVzdCBjb250YWluIGEgc3RyaW5nIHdpdGggYmFzZTY0IGNvbnRlbnRzJyxcbiAgU1RBVEVNRU5UX0FSR1VNRU5UX0lTX05PVF9WQUxJRDogICAgICAgICAgICAgICAgICAnU3RhdGVtZW50IGFyZ3VtZW50IHByb3ZpZGVkIHdhcyBub3QgYSB2YWxpZCBvYmplY3Qgb3IgYSB2YWxpZCBKU09OIHN0cmluZy4nLFxuICBTVEFURU1FTlRfQVJHVU1FTlRfTVVTVF9CRV9QUk9WSURFRDogICAgICAgICAgICAgICdObyBzdGF0ZW1lbnQgYXJndW1lbnQgcHJvdmlkZWQuJyxcbiAgU1RBVEVNRU5UX01VU1RfQkVfUEFSU0VEX0NPUlJFQ1RMWTogICAgICAgICAgICAgICAnTnVsbCBvciBub24tb2JqZWN0IHN0YXRlbWVudCB2YWx1ZSBwYXJzZWQgZnJvbSBwcm92aWRlZCBzdGF0bWVudCBKU09OLicsXG4gIFNUQVRFTUVOVF9NVVNUX05PVF9CRV9OVUxMOiAgICAgICAgICAgICAgICAgICAgICAgJ051bGwgc3RhdGVtZW50IGFyZ3VtZW50IHByb3ZpZGVkLicsXG4gIFNUQVRFTUVOVF9SRUZfTVVTVF9OT1RfQkVfTlVMTF9NQVBfT0JKRUNUUzogICAgICAgJ1N0YXRlbWVudFJlZiBpbnN0YW5jZXMgbXVzdCBiZSBub24tbnVsbCBtYXAgb2JqZWN0cycsXG4gIFNVQl9TVEFURU1FTlRfTVVTVF9OT1RfQ09OVEFJTl9TVUJfU1RBVEVNRU5UOiAgICAgJ0EgU3ViU3RhdGVtZW50IG11c3Qgbm90IGNvbnRhaW4gYSBTdWJTdGF0ZW1lbnQnLFxuICBVTkVYUEVDVEVEOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIHByb3BlcnR5IG5vdCBwZXJtaXR0ZWQnLFxuICBWRVJCX01VU1RfQkVfUFJPVklERUQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdWZXJiIG11c3QgYmUgcHJvdmlkZWQnLFxuICBWRVJCX01VU1RfTk9UX0JFX05VTEw6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdWZXJiIHByb3BlcnR5IHZhbHVlIG11c3QgYSBub24tbnVsbCBtYXAgb2JqZWN0LicsXG4gIFZFUlNJT05fTVVTVF9DT01QTFlfU0VNQU5USUNfVkVSU0lPTklORzogICAgICAgICAgJ1widmVyc2lvblwiIG11c3QgYmUgYSBub24tbnVsbCBzdHJpbmcgdGhhdCBjb21wbGllcyB3aXRoIFNlbWFudGljIFZlcnNpb25pbmcgMS4wLjAnXG59KTtcblxuZXhwb3J0IHt4YXBpRXJyb3JMZXZlbHN9O1xuZXhwb3J0IHt4YXBpVmFsaWRhdGlvbkVycm9yc307XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHhhcGlHZW5lcmFsID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEZJUlNUX1JFUE9SVF9WRVJTVElPTiAgICAgICAgICAgICA6ICcxLjAuMCcsXG4gIEdST1VQX0FVVEhPUklUWV9BR0VOVF9NRU1CRVJTICAgICA6IDIsXG4gIElOVEVSQUNUSU9OX0RFRklOSVRJT05fVFlQRSAgICAgICA6ICdodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvYWN0aXZpdGllcy9jbWkuaW50ZXJhY3Rpb24nLFxuICBNQVhfU0NBTEVEX1ZBTFVFICAgICAgICAgICAgICAgICAgOiAxLFxuICBNSU5fU0NBTEVEX1ZBTFVFICAgICAgICAgICAgICAgICAgOiAwLFxuICBOT19JTkRFWF9GT1VORCAgICAgICAgICAgICAgICAgICAgOiAtMSxcbiAgTlVNRVJfT0ZfU1BFQ0lGSUVEX0lGSV9QUk9QRVJUSUVTIDogMVxufSk7XG5cbmV4cG9ydCB7eGFwaUdlbmVyYWx9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3QgaW50ZXJhY3Rpb25UeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBDSE9JQ0U6ICAgICAgICdjaG9pY2UnLFxuICBGSUxMX0lOOiAgICAgICdmaWxsLWluJyxcbiAgTElLRVJUOiAgICAgICAnbGlrZXJ0JyxcbiAgTE9OR19GSUxMX0lOOiAnbG9uZy1maWxsLWluJyxcbiAgTUFUQ0hJTkc6ICAgICAnbWF0Y2hpbmcnLFxuICBOVU1FUklDOiAgICAgICdudW1lcmljJyxcbiAgT1RIRVI6ICAgICAgICAnb3RoZXInLFxuICBQRVJGT1JNQU5DRTogICdwZXJmb3JtYW5jZScsXG4gIFNFUVVFTkNJTkc6ICAgJ3NlcXVlbmNpbmcnLFxuICBUUlVFX0ZBTFNFOiAgICd0cnVlLWZhbHNlJ1xufSk7XG5cbmV4cG9ydCBjb25zdCB4YXBpVmFsaWRhdGlvbkludGVyYWN0aW9uVHlwZXMgPSBPYmplY3QuZnJlZXplKFtcbiAgaW50ZXJhY3Rpb25UeXBlcy5DSE9JQ0UsXG4gIGludGVyYWN0aW9uVHlwZXMuRklMTF9JTixcbiAgaW50ZXJhY3Rpb25UeXBlcy5MSUtFUlQsXG4gIGludGVyYWN0aW9uVHlwZXMuTE9OR19GSUxMX0lOLFxuICBpbnRlcmFjdGlvblR5cGVzLk1BVENISU5HLFxuICBpbnRlcmFjdGlvblR5cGVzLk5VTUVSSUMsXG4gIGludGVyYWN0aW9uVHlwZXMuT1RIRVIsXG4gIGludGVyYWN0aW9uVHlwZXMuUEVSRk9STUFOQ0UsXG4gIGludGVyYWN0aW9uVHlwZXMuU0VRVUVOQ0lORyxcbiAgaW50ZXJhY3Rpb25UeXBlcy5UUlVFX0ZBTFNFXG5dKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5mcmVlemUoe1xuICBBQ0NPVU5UOiAgICAgICAgICAgICAgICAgICAnYWNjb3VudCcsXG4gIEFDVElWSVRZOiAgICAgICAgICAgICAgICAgICdhY3Rpdml0eScsXG4gIEFDVE9SOiAgICAgICAgICAgICAgICAgICAgICdhY3RvcicsXG4gIEFHRU5UOiAgICAgICAgICAgICAgICAgICAgICdhZ2VudCcsXG4gIEFUVEFDSE1FTlQ6ICAgICAgICAgICAgICAgICdhdHRhY2htZW50JyxcbiAgQVRUQUNITUVOVFM6ICAgICAgICAgICAgICAgJ2F0dGFjaG1lbnRzJyxcbiAgQVVUSE9SSVRZOiAgICAgICAgICAgICAgICAgJ2F1dGhvcml0eScsXG4gIENBVEVHT1JZOiAgICAgICAgICAgICAgICAgICdjYXRlZ29yeScsXG4gIENIT0lDRTogICAgICAgICAgICAgICAgICAgICdjaG9pY2UnLFxuICBDSE9JQ0VTOiAgICAgICAgICAgICAgICAgICAnY2hvaWNlcycsXG4gIENPTVBMRVRJT046ICAgICAgICAgICAgICAgICdjb21wbGV0aW9uJyxcbiAgQ09OVEVOVF9UWVBFOiAgICAgICAgICAgICAgJ2NvbnRlbnRUeXBlJyxcbiAgQ09OVEVYVF9BQ1RJVklUSUVTOiAgICAgICAgJ2NvbnRleHRBY3Rpdml0aWVzJyxcbiAgQ09OVEVYVDogICAgICAgICAgICAgICAgICAgJ2NvbnRleHQnLFxuICBDT1JSRUNUX1JFU1BPTlNFU19QQVRURVJOOiAnY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4nLFxuICBEQVRFX1RJTUU6ICAgICAgICAgICAgICAgICAnZGF0ZVRpbWUnLFxuICBERUZJTklUSU9OOiAgICAgICAgICAgICAgICAnZGVmaW5pdGlvbicsXG4gIERFU0NSSVBUSU9OOiAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbicsXG4gIERJU1BMQVk6ICAgICAgICAgICAgICAgICAgICdkaXNwbGF5JyxcbiAgRFVSQVRJT046ICAgICAgICAgICAgICAgICAgJ2R1cmF0aW9uJyxcbiAgRVhURU5TSU9OUzogICAgICAgICAgICAgICAgJ2V4dGVuc2lvbnMnLFxuICBGSUxFX1VSTDogICAgICAgICAgICAgICAgICAnZmlsZVVybCcsXG4gIEdST1VQOiAgICAgICAgICAgICAgICAgICAgICdncm91cCcsXG4gIEdST1VQSU5HOiAgICAgICAgICAgICAgICAgICdncm91cGluZycsXG4gIEhPTUVfUEFHRTogICAgICAgICAgICAgICAgICdob21lUGFnZScsXG4gIElEOiAgICAgICAgICAgICAgICAgICAgICAgICdpZCcsXG4gIElOU1RSVUNUT1I6ICAgICAgICAgICAgICAgICdpbnN0cnVjdG9yJyxcbiAgSU5URVJBQ1RJT05fQ09NUE9ORU5UUzogICAgJ2ludGVyYWN0aW9uQ29tcG9uZW50cycsXG4gIElOVEVSQUNUSU9OX1RZUEU6ICAgICAgICAgICdpbnRlcmFjdGlvblR5cGUnLFxuICBMQU5HVUFHRV9NQVA6ICAgICAgICAgICAgICAnbGFuZ3VhZ2VNYXAnLFxuICBMQU5HVUFHRTogICAgICAgICAgICAgICAgICAnbGFuZ3VhZ2UnLFxuICBMRU5HVEg6ICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJyxcbiAgTElLRVJUOiAgICAgICAgICAgICAgICAgICAgJ2xpa2VydCcsXG4gIE1BVENISU5HOiAgICAgICAgICAgICAgICAgICdtYXRjaGluZycsXG4gIE1BWDogICAgICAgICAgICAgICAgICAgICAgICdtYXgnLFxuICBNQk9YX1NIQV8xX1NVTTogICAgICAgICAgICAnbWJveF9zaGExc3VtJyxcbiAgTUJPWDogICAgICAgICAgICAgICAgICAgICAgJ21ib3gnLFxuICBNRU1CRVI6ICAgICAgICAgICAgICAgICAgICAnbWVtYmVyJyxcbiAgTUlOOiAgICAgICAgICAgICAgICAgICAgICAgJ21pbicsXG4gIE1PUkVfSU5GTzogICAgICAgICAgICAgICAgICdtb3JlSW5mbycsXG4gIE5BTUU6ICAgICAgICAgICAgICAgICAgICAgICduYW1lJyxcbiAgT0JKRUNUX1RZUEU6ICAgICAgICAgICAgICAgJ29iamVjdFR5cGUnLFxuICBPQkpFQ1Q6ICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcbiAgT1BFTl9JRDogICAgICAgICAgICAgICAgICAgJ29wZW5JRCcsXG4gIE9USEVSOiAgICAgICAgICAgICAgICAgICAgICdvdGhlcicsXG4gIFBBUkVOVDogICAgICAgICAgICAgICAgICAgICdwYXJlbnQnLFxuICBQRVJGT1JNQU5DRTogICAgICAgICAgICAgICAncGVyZm9ybWFuY2UnLFxuICBQTEFURk9STTogICAgICAgICAgICAgICAgICAncGxhdGZvcm0nLFxuICBSQVc6ICAgICAgICAgICAgICAgICAgICAgICAncmF3JyxcbiAgUkVHSVNUUkFUSU9OOiAgICAgICAgICAgICAgJ3JlZ2lzdHJhdGlvbicsXG4gIFJFU1BPTlNFOiAgICAgICAgICAgICAgICAgICdyZXNwb25zZScsXG4gIFJFU1VMVDogICAgICAgICAgICAgICAgICAgICdyZXN1bHQnLFxuICBSRVZJU0lPTjogICAgICAgICAgICAgICAgICAncmV2aXNpb24nLFxuICBTQ0FMRTogICAgICAgICAgICAgICAgICAgICAnc2NhbGUnLFxuICBTQ0FMRUQ6ICAgICAgICAgICAgICAgICAgICAnc2NhbGVkJyxcbiAgU0NPUkU6ICAgICAgICAgICAgICAgICAgICAgJ3Njb3JlJyxcbiAgU0VRVUVOQ0lORzogICAgICAgICAgICAgICAgJ3NlcXVlbmNpbmcnLFxuICBTSEEyOiAgICAgICAgICAgICAgICAgICAgICAnc2hhMicsXG4gIFNPVVJDRTogICAgICAgICAgICAgICAgICAgICdzb3VyY2UnLFxuICBTVEFURU1FTlRfUkVGOiAgICAgICAgICAgICAnc3RhdGVtZW50UmVmJyxcbiAgU1RBVEVNRU5UOiAgICAgICAgICAgICAgICAgJ3N0YXRlbWVudCcsXG4gIFNURVBTOiAgICAgICAgICAgICAgICAgICAgICdzdGVwcycsXG4gIFNUT1JFRDogICAgICAgICAgICAgICAgICAgICdzdG9yZWQnLFxuICBTVUJfQ09OVEVYVDogICAgICAgICAgICAgICAnc3ViQ29udGV4dCcsXG4gIFNVQ0NFU1M6ICAgICAgICAgICAgICAgICAgICdzdWNjZXNzJyxcbiAgVEFSR0VUOiAgICAgICAgICAgICAgICAgICAgJ3RhcmdldCcsXG4gIFRFQU06ICAgICAgICAgICAgICAgICAgICAgICd0ZWFtJyxcbiAgVElNRVNUQU1QOiAgICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCcsXG4gIFRZUEU6ICAgICAgICAgICAgICAgICAgICAgICd0eXBlJyxcbiAgVVNBR0VfVFlQRTogICAgICAgICAgICAgICAgJ3VzYWdlVHlwZScsXG4gIFZFUkI6ICAgICAgICAgICAgICAgICAgICAgICd2ZXJiJyxcbiAgVkVSU0lPTjogICAgICAgICAgICAgICAgICAgJ3ZlcnNpb24nXG59KTtcblxuY29uc3Qgb2JqZWN0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgR1JPVVA6ICAgICAgICAgJ0dyb3VwJyxcbiAgQUdFTlQ6ICAgICAgICAgJ0FnZW50JyxcbiAgQUNUSVZJVFk6ICAgICAgJ0FjdGl2aXR5JyxcbiAgU1RBVEVNRU5UX1JFRjogJ1N0YXRlbWVudFJlZicsXG4gIFNVQl9TVEFURU1FTlQ6ICdTdWJTdGF0ZW1lbnQnXG59KTtcblxuY29uc3QgeGFwaVZhbGlkYXRpb25JZmlQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmZyZWV6ZShbXG4gIHByb3BlcnRpZXMuQUNDT1VOVCxcbiAgcHJvcGVydGllcy5NQk9YX1NIQV8xX1NVTSxcbiAgcHJvcGVydGllcy5NQk9YLFxuICBwcm9wZXJ0aWVzLk9QRU5fSURcbl0pO1xuXG5jb25zdCB4QXBpVmFsaWRPYmplY3RUeXBlcyA9IE9iamVjdC5mcmVlemUoW1xuICBvYmplY3RUeXBlcy5HUk9VUCxcbiAgb2JqZWN0VHlwZXMuQUdFTlQsXG4gIG9iamVjdFR5cGVzLkFDVElWSVRZLFxuICBvYmplY3RUeXBlcy5TVEFURU1FTlRfUkVGLFxuICBvYmplY3RUeXBlcy5TVUJfU1RBVEVNRU5UXG5dKTtcblxuZXhwb3J0IHtwcm9wZXJ0aWVzfTtcbmV4cG9ydCB7b2JqZWN0VHlwZXN9O1xuZXhwb3J0IHt4YXBpVmFsaWRhdGlvbklmaVByb3BlcnR5TmFtZXN9O1xuZXhwb3J0IHt4QXBpVmFsaWRPYmplY3RUeXBlc307XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHhhcGlWYWxpZGF0aW9uUmVnZXggPSBPYmplY3QuZnJlZXplKHtcbiAgVVVJRDogICAgICAgICAgICAgICAgL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kL2ksXG4gIElTT184NjAxX0RVUkFUSU9OOiAgIC9eUCgoXFxkKyhbXFwuLF1cXGQrKT9ZKT8oXFxkKyhbXFwuLF1cXGQrKT9NKT8oXFxkKyhbXFwuLF1cXGQrKT9XKT8oXFxkKyhbXFwuLF1cXGQrKT9EKT8pPyhUKFxcZCsoW1xcLixdXFxkKyk/SCk/KFxcZCsoW1xcLixdXFxkKyk/TSk/KFxcZCsoW1xcLixdXFxkKyk/Uyk/KT8kLyxcbiAgSVNPXzg2MDFfREFURV9USU1FOiAgL14oXFxkezR9fFsrXFwtXVxcZHs2fSkoPzotKFxcZHsyfSkoPzotKFxcZHsyfSkpPyk/KD86VChcXGR7Mn0pOihcXGR7Mn0pKD86OihcXGR7Mn0pKD86XFwuKFxcZHszfSkpPyk/KD86KFopfChbK1xcLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLyxcbiAgTUFJTFRPX1VSSTogICAgICAgICAgL15tYWlsdG86LyxcbiAgQ09OVEFJTlNfV0hJVEVTUEFDRTogL1xccy9nLFxuICBTRU1WRVJfMV9QXzBfUF8wOiAgICAvXigoXFxkKylcXC4oXFxkKylcXC4oXFxkKykpKD86LShbXFxkQS1aYS16XFwtXSspKT8kLyxcbiAgQkFTRV82NDogICAgICAgICAgICAgL14oPzpbQS1aYS16MC05XFwrXFwvXXs0fSkqKD86W0EtWmEtejAtOVxcK1xcL117Mn09PXxbQS1aYS16MC05XFwrXFwvXXszfT18W0EtWmEtejAtOVxcK1xcL117NH0pJC8sXG4gIElSSTogICAgICAgICAgICAgICAgIC9eW2Etel0oPzpbXFwtYS16MC05XFwrXFwuXSkqOig/OlxcL1xcLyg/Oig/OiVbMC05YS1mXVswLTlhLWZdfFtcXC1hLXowLTlcXC5fflxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcdTEwMDAwLVxcdTFGRkZEXFx1MjAwMDAtXFx1MkZGRkRcXHUzMDAwMC1cXHUzRkZGRFxcdTQwMDAwLVxcdTRGRkZEXFx1NTAwMDAtXFx1NUZGRkRcXHU2MDAwMC1cXHU2RkZGRFxcdTcwMDAwLVxcdTdGRkZEXFx1ODAwMDAtXFx1OEZGRkRcXHU5MDAwMC1cXHU5RkZGRFxcdUEwMDAwLVxcdUFGRkZEXFx1QjAwMDAtXFx1QkZGRkRcXHVDMDAwMC1cXHVDRkZGRFxcdUQwMDAwLVxcdURGRkZEXFx1RTEwMDAtXFx1RUZGRkQhXFwkJidcXChcXClcXCpcXCssOz06XSkqQCk/KD86XFxbKD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/OlswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSkoPzpcXC4oPzpbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pKXszfSl8OjooPzpbMC05YS1mXXsxLDR9Oil7NX0oPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86WzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKSg/OlxcLig/OlswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSkpezN9KXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzpbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pKD86XFwuKD86WzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKSl7M30pfCg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M30oPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86WzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKSg/OlxcLig/OlswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSkpezN9KXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9KD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/OlswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSkoPzpcXC4oPzpbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pKXszfSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06KD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/OlswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSkoPzpcXC4oPzpbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pKXszfSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzpbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pKD86XFwuKD86WzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKSl7M30pfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfHZbMC05YS1mXStbXFwtYS16MC05XFwuX34hXFwkJidcXChcXClcXCpcXCssOz06XSspXFxdfCg/OlswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSkoPzpcXC4oPzpbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pKXszfXwoPzolWzAtOWEtZl1bMC05YS1mXXxbXFwtYS16MC05XFwuX35cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHUxMDAwMC1cXHUxRkZGRFxcdTIwMDAwLVxcdTJGRkZEXFx1MzAwMDAtXFx1M0ZGRkRcXHU0MDAwMC1cXHU0RkZGRFxcdTUwMDAwLVxcdTVGRkZEXFx1NjAwMDAtXFx1NkZGRkRcXHU3MDAwMC1cXHU3RkZGRFxcdTgwMDAwLVxcdThGRkZEXFx1OTAwMDAtXFx1OUZGRkRcXHVBMDAwMC1cXHVBRkZGRFxcdUIwMDAwLVxcdUJGRkZEXFx1QzAwMDAtXFx1Q0ZGRkRcXHVEMDAwMC1cXHVERkZGRFxcdUUxMDAwLVxcdUVGRkZEIVxcJCYnXFwoXFwpXFwqXFwrLDs9QF0pKikoPzo6WzAtOV0qKT8oPzpcXC8oPzooPzolWzAtOWEtZl1bMC05YS1mXXxbXFwtYS16MC05XFwuX35cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHUxMDAwMC1cXHUxRkZGRFxcdTIwMDAwLVxcdTJGRkZEXFx1MzAwMDAtXFx1M0ZGRkRcXHU0MDAwMC1cXHU0RkZGRFxcdTUwMDAwLVxcdTVGRkZEXFx1NjAwMDAtXFx1NkZGRkRcXHU3MDAwMC1cXHU3RkZGRFxcdTgwMDAwLVxcdThGRkZEXFx1OTAwMDAtXFx1OUZGRkRcXHVBMDAwMC1cXHVBRkZGRFxcdUIwMDAwLVxcdUJGRkZEXFx1QzAwMDAtXFx1Q0ZGRkRcXHVEMDAwMC1cXHVERkZGRFxcdUUxMDAwLVxcdUVGRkZEIVxcJCYnXFwoXFwpXFwqXFwrLDs9OkBdKSkqKSp8XFwvKD86KD86KD86KD86JVswLTlhLWZdWzAtOWEtZl18W1xcLWEtejAtOVxcLl9+XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXFx1MTAwMDAtXFx1MUZGRkRcXHUyMDAwMC1cXHUyRkZGRFxcdTMwMDAwLVxcdTNGRkZEXFx1NDAwMDAtXFx1NEZGRkRcXHU1MDAwMC1cXHU1RkZGRFxcdTYwMDAwLVxcdTZGRkZEXFx1NzAwMDAtXFx1N0ZGRkRcXHU4MDAwMC1cXHU4RkZGRFxcdTkwMDAwLVxcdTlGRkZEXFx1QTAwMDAtXFx1QUZGRkRcXHVCMDAwMC1cXHVCRkZGRFxcdUMwMDAwLVxcdUNGRkZEXFx1RDAwMDAtXFx1REZGRkRcXHVFMTAwMC1cXHVFRkZGRCFcXCQmJ1xcKFxcKVxcKlxcKyw7PTpAXSkpKykoPzpcXC8oPzooPzolWzAtOWEtZl1bMC05YS1mXXxbXFwtYS16MC05XFwuX35cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHUxMDAwMC1cXHUxRkZGRFxcdTIwMDAwLVxcdTJGRkZEXFx1MzAwMDAtXFx1M0ZGRkRcXHU0MDAwMC1cXHU0RkZGRFxcdTUwMDAwLVxcdTVGRkZEXFx1NjAwMDAtXFx1NkZGRkRcXHU3MDAwMC1cXHU3RkZGRFxcdTgwMDAwLVxcdThGRkZEXFx1OTAwMDAtXFx1OUZGRkRcXHVBMDAwMC1cXHVBRkZGRFxcdUIwMDAwLVxcdUJGRkZEXFx1QzAwMDAtXFx1Q0ZGRkRcXHVEMDAwMC1cXHVERkZGRFxcdUUxMDAwLVxcdUVGRkZEIVxcJCYnXFwoXFwpXFwqXFwrLDs9OkBdKSkqKSopP3woPzooPzooPzolWzAtOWEtZl1bMC05YS1mXXxbXFwtYS16MC05XFwuX35cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHUxMDAwMC1cXHUxRkZGRFxcdTIwMDAwLVxcdTJGRkZEXFx1MzAwMDAtXFx1M0ZGRkRcXHU0MDAwMC1cXHU0RkZGRFxcdTUwMDAwLVxcdTVGRkZEXFx1NjAwMDAtXFx1NkZGRkRcXHU3MDAwMC1cXHU3RkZGRFxcdTgwMDAwLVxcdThGRkZEXFx1OTAwMDAtXFx1OUZGRkRcXHVBMDAwMC1cXHVBRkZGRFxcdUIwMDAwLVxcdUJGRkZEXFx1QzAwMDAtXFx1Q0ZGRkRcXHVEMDAwMC1cXHVERkZGRFxcdUUxMDAwLVxcdUVGRkZEIVxcJCYnXFwoXFwpXFwqXFwrLDs9OkBdKSkrKSg/OlxcLyg/Oig/OiVbMC05YS1mXVswLTlhLWZdfFtcXC1hLXowLTlcXC5fflxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcdTEwMDAwLVxcdTFGRkZEXFx1MjAwMDAtXFx1MkZGRkRcXHUzMDAwMC1cXHUzRkZGRFxcdTQwMDAwLVxcdTRGRkZEXFx1NTAwMDAtXFx1NUZGRkRcXHU2MDAwMC1cXHU2RkZGRFxcdTcwMDAwLVxcdTdGRkZEXFx1ODAwMDAtXFx1OEZGRkRcXHU5MDAwMC1cXHU5RkZGRFxcdUEwMDAwLVxcdUFGRkZEXFx1QjAwMDAtXFx1QkZGRkRcXHVDMDAwMC1cXHVDRkZGRFxcdUQwMDAwLVxcdURGRkZEXFx1RTEwMDAtXFx1RUZGRkQhXFwkJidcXChcXClcXCpcXCssOz06QF0pKSopKnwoPyEoPzolWzAtOWEtZl1bMC05YS1mXXxbXFwtYS16MC05XFwuX35cXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZcXHUxMDAwMC1cXHUxRkZGRFxcdTIwMDAwLVxcdTJGRkZEXFx1MzAwMDAtXFx1M0ZGRkRcXHU0MDAwMC1cXHU0RkZGRFxcdTUwMDAwLVxcdTVGRkZEXFx1NjAwMDAtXFx1NkZGRkRcXHU3MDAwMC1cXHU3RkZGRFxcdTgwMDAwLVxcdThGRkZEXFx1OTAwMDAtXFx1OUZGRkRcXHVBMDAwMC1cXHVBRkZGRFxcdUIwMDAwLVxcdUJGRkZEXFx1QzAwMDAtXFx1Q0ZGRkRcXHVEMDAwMC1cXHVERkZGRFxcdUUxMDAwLVxcdUVGRkZEIVxcJCYnXFwoXFwpXFwqXFwrLDs9OkBdKSkpKD86XFw/KD86KD86JVswLTlhLWZdWzAtOWEtZl18W1xcLWEtejAtOVxcLl9+XFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXFx1MTAwMDAtXFx1MUZGRkRcXHUyMDAwMC1cXHUyRkZGRFxcdTMwMDAwLVxcdTNGRkZEXFx1NDAwMDAtXFx1NEZGRkRcXHU1MDAwMC1cXHU1RkZGRFxcdTYwMDAwLVxcdTZGRkZEXFx1NzAwMDAtXFx1N0ZGRkRcXHU4MDAwMC1cXHU4RkZGRFxcdTkwMDAwLVxcdTlGRkZEXFx1QTAwMDAtXFx1QUZGRkRcXHVCMDAwMC1cXHVCRkZGRFxcdUMwMDAwLVxcdUNGRkZEXFx1RDAwMDAtXFx1REZGRkRcXHVFMTAwMC1cXHVFRkZGRCFcXCQmJ1xcKFxcKVxcKlxcKyw7PTpAXSl8W1xcdUUwMDAtXFx1RjhGRlxcdUYwMDAwLVxcdUZGRkZEfFxcdTEwMDAwMC1cXHUxMEZGRkRcXC9cXD9dKSopPyg/OlxcIyg/Oig/OiVbMC05YS1mXVswLTlhLWZdfFtcXC1hLXowLTlcXC5fflxcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRlxcdTEwMDAwLVxcdTFGRkZEXFx1MjAwMDAtXFx1MkZGRkRcXHUzMDAwMC1cXHUzRkZGRFxcdTQwMDAwLVxcdTRGRkZEXFx1NTAwMDAtXFx1NUZGRkRcXHU2MDAwMC1cXHU2RkZGRFxcdTcwMDAwLVxcdTdGRkZEXFx1ODAwMDAtXFx1OEZGRkRcXHU5MDAwMC1cXHU5RkZGRFxcdUEwMDAwLVxcdUFGRkZEXFx1QjAwMDAtXFx1QkZGRkRcXHVDMDAwMC1cXHVDRkZGRFxcdUQwMDAwLVxcdURGRkZEXFx1RTEwMDAtXFx1RUZGRkQhXFwkJidcXChcXClcXCpcXCssOz06QF0pfFtcXC9cXD9dKSopPyQvaSxcbiAgQkNQXzQ3OiAgICAgICAgICAgICAgL14oPzooZW4tR0Itb2VkfGktKD86YW1pfGJubnxkZWZhdWx0fGVub2NoaWFufGhha3xrbGluZ29ufGx1eHxtaW5nb3xuYXZham98cHdufHRhb3x0YXl8dHN1KXxzZ24tKD86QkUtRlJ8QkUtTkx8Q0gtREUpKXwoYXJ0LWxvamJhbnxjZWwtZ2F1bGlzaHxuby0oPzpib2t8bnluKXx6aC0oPzpndW95dXxoYWtrYXxtaW58bWluLW5hbnx4aWFuZykpKSR8Xih4KD86LVswLTlhLXpdezEsOH0pKykkfF4oPzooKD86W2Etel17MiwzfSg/Oig/Oi1bYS16XXszfSl7MSwzfSk/KXxbYS16XXs0fXxbYS16XXs1LDh9KSg/Oi0oW2Etel17NH0pKT8oPzotKFthLXpdezJ9fFswLTldezN9KSk/KCg/Oi0oPzpbYS16MC05XXs1LDh9fFswLTldW2EtejAtOV17M30pKSopPygoPzotWzAtOWEtd3ktel0oPzotW2EtejAtOV17Miw4fSl7MSx9KSopPygteCg/Oi1bMC05YS16XXsxLDh9KSspPykkL2lcbn0pO1xuXG5jb25zdCBkYXRlRm9ybWF0UmVnZXhQb3NpdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgWUVBUjogICAgICAgICAgICAgMSxcbiAgTU9OVEg6ICAgICAgICAgICAgMixcbiAgREFZOiAgICAgICAgICAgICAgMyxcbiAgSE9VUjogICAgICAgICAgICAgNCxcbiAgTUlOVVRFOiAgICAgICAgICAgNSxcbiAgU0VDT05EOiAgICAgICAgICAgNixcbiAgTVNFQ09ORDogICAgICAgICAgNyxcbiAgWk9ORTogICAgICAgICAgICAgOCxcbiAgUkVMQVRJVkVfVElNRTogICAgOSxcbiAgVElNRV9aT05FX0hPVVI6ICAgMTAsXG4gIFRJTUVfWk9ORV9NSU5VVEU6IDExXG59KTtcblxuZXhwb3J0IHt4YXBpVmFsaWRhdGlvblJlZ2V4fTtcbmV4cG9ydCB7ZGF0ZUZvcm1hdFJlZ2V4UG9zaXRpb25zfTtcbiIsIiAndXNlIHN0cmljdCc7XG4gaW1wb3J0IHtwcm9wZXJ0aWVzfSBmcm9tICcuLi9jb25zdGFudHMvcHJvcGVydGllcyc7XG5cbiBjb25zdCB4YXBpV2hpdGVMaXN0UHJvcGVydGllcyA9IE9iamVjdC5mcmVlemUoe1xuICAgSUZJOiBbXG4gICAgIHByb3BlcnRpZXMuSE9NRV9QQUdFLFxuICAgICBwcm9wZXJ0aWVzLk5BTUVcbiAgIF0sXG4gICBVUkk6IFtcbiAgICAgcHJvcGVydGllcy5JRCxcbiAgICAgcHJvcGVydGllcy5ESVNQTEFZXG4gICBdLFxuICAgQ09NUE9ORU5UX0FSUkFZOiBbXG4gICAgIHByb3BlcnRpZXMuSUQsXG4gICAgIHByb3BlcnRpZXMuREVTQ1JJUFRJT05cbiAgIF0sXG4gICBBQ1RJVklUWV9ERUZJTklUSU9OOiBbXG4gICAgIHByb3BlcnRpZXMuTkFNRSxcbiAgICAgcHJvcGVydGllcy5ERVNDUklQVElPTixcbiAgICAgcHJvcGVydGllcy5UWVBFLFxuICAgICBwcm9wZXJ0aWVzLk1PUkVfSU5GTyxcbiAgICAgcHJvcGVydGllcy5FWFRFTlNJT05TLFxuICAgICBwcm9wZXJ0aWVzLklOVEVSQUNUSU9OX1RZUEUsXG4gICAgIHByb3BlcnRpZXMuQ09SUkVDVF9SRVNQT05TRVNfUEFUVEVSTixcbiAgICAgcHJvcGVydGllcy5DSE9JQ0VTLFxuICAgICBwcm9wZXJ0aWVzLlNDQUxFLFxuICAgICBwcm9wZXJ0aWVzLlNPVVJDRSxcbiAgICAgcHJvcGVydGllcy5UQVJHRVQsXG4gICAgIHByb3BlcnRpZXMuU1RFUFNcbiAgIF0sXG4gICBBQ1RJVklUWTogW1xuICAgICBwcm9wZXJ0aWVzLk9CSkVDVF9UWVBFLFxuICAgICBwcm9wZXJ0aWVzLklELFxuICAgICBwcm9wZXJ0aWVzLkRFRklOSVRJT05cbiAgIF0sXG4gICBTVEFURU1FTlRfUkVGOiBbXG4gICAgIHByb3BlcnRpZXMuSUQsXG4gICAgIHByb3BlcnRpZXMuT0JKRUNUX1RZUEVcbiAgIF0sXG4gICBTQ09SRTogW1xuICAgICBwcm9wZXJ0aWVzLlNDQUxFRCxcbiAgICAgcHJvcGVydGllcy5SQVcsXG4gICAgIHByb3BlcnRpZXMuTUlOLFxuICAgICBwcm9wZXJ0aWVzLk1BWFxuICAgXSxcbiAgIFJFU1VMVDogW1xuICAgICBwcm9wZXJ0aWVzLlNDT1JFLFxuICAgICBwcm9wZXJ0aWVzLlNVQ0NFU1MsXG4gICAgIHByb3BlcnRpZXMuQ09NUExFVElPTixcbiAgICAgcHJvcGVydGllcy5SRVNQT05TRSxcbiAgICAgcHJvcGVydGllcy5EVVJBVElPTixcbiAgICAgcHJvcGVydGllcy5FWFRFTlNJT05TXG4gICBdLFxuICAgQVRUQUNITUVOVDogW1xuICAgICBwcm9wZXJ0aWVzLlVTQUdFX1RZUEUsXG4gICAgIHByb3BlcnRpZXMuRElTUExBWSxcbiAgICAgcHJvcGVydGllcy5ERVNDUklQVElPTixcbiAgICAgcHJvcGVydGllcy5DT05URU5UX1RZUEUsXG4gICAgIHByb3BlcnRpZXMuTEVOR1RILFxuICAgICBwcm9wZXJ0aWVzLlNIQTIsXG4gICAgIHByb3BlcnRpZXMuRklMRV9VUkxcbiAgIF0sXG4gIEFHRU5UOiBbXG4gICAgcHJvcGVydGllcy5PQkpFQ1RfVFlQRSxcbiAgICBwcm9wZXJ0aWVzLk5BTUUsXG4gICAgcHJvcGVydGllcy5BQ0NPVU5ULFxuICAgIHByb3BlcnRpZXMuTUJPWF9TSEFfMV9TVU0sXG4gICAgcHJvcGVydGllcy5NQk9YLFxuICAgIHByb3BlcnRpZXMuT1BFTl9JRFxuICBdLFxuICBHUk9VUDogW1xuICAgIHByb3BlcnRpZXMuT0JKRUNUX1RZUEUsXG4gICAgcHJvcGVydGllcy5OQU1FLFxuICAgIHByb3BlcnRpZXMuTUVNQkVSLFxuICAgIHByb3BlcnRpZXMuQUNDT1VOVCxcbiAgICBwcm9wZXJ0aWVzLk1CT1hfU0hBXzFfU1VNLFxuICAgIHByb3BlcnRpZXMuTUJPWCxcbiAgICBwcm9wZXJ0aWVzLk9QRU5fSURcbiAgXSxcbiAgQ09OVEVYVF9BQ1RJVklUSUVTOiBbXG4gICAgcHJvcGVydGllcy5QQVJFTlQsXG4gICAgcHJvcGVydGllcy5HUk9VUElORyxcbiAgICBwcm9wZXJ0aWVzLkNBVEVHT1JZLFxuICAgIHByb3BlcnRpZXMuT1RIRVJcbiAgXSxcbiAgU1RBVEVNRU5UOiBbXG4gICAgcHJvcGVydGllcy5JRCxcbiAgICBwcm9wZXJ0aWVzLkFDVE9SLFxuICAgIHByb3BlcnRpZXMuVkVSQixcbiAgICBwcm9wZXJ0aWVzLk9CSkVDVCxcbiAgICBwcm9wZXJ0aWVzLlJFU1VMVCxcbiAgICBwcm9wZXJ0aWVzLkNPTlRFWFQsXG4gICAgcHJvcGVydGllcy5USU1FU1RBTVAsXG4gICAgcHJvcGVydGllcy5TVE9SRUQsXG4gICAgcHJvcGVydGllcy5BVVRIT1JJVFksXG4gICAgcHJvcGVydGllcy5WRVJTSU9OLFxuICAgIHByb3BlcnRpZXMuQVRUQUNITUVOVFNcbiAgXSxcbiAgU1VCX1NUQVRFTUVOVDogW1xuICAgIHByb3BlcnRpZXMuQUNUT1IsXG4gICAgcHJvcGVydGllcy5WRVJCLFxuICAgIHByb3BlcnRpZXMuT0JKRUNULFxuICAgIHByb3BlcnRpZXMuUkVTVUxULFxuICAgIHByb3BlcnRpZXMuQ09OVEVYVCxcbiAgICBwcm9wZXJ0aWVzLlRJTUVTVEFNUCxcbiAgICBwcm9wZXJ0aWVzLkFUVEFDSE1FTlRTLFxuICAgIHByb3BlcnRpZXMuT0JKRUNUX1RZUEVcbiAgXSxcbiAgRVhURU5TSU9OUzogW1xuICAgIHByb3BlcnRpZXMuUkVHSVNUUkFUSU9OLFxuICAgIHByb3BlcnRpZXMuSU5TVFJVQ1RPUixcbiAgICBwcm9wZXJ0aWVzLlRFQU0sXG4gICAgcHJvcGVydGllcy5DT05URVhUX0FDVElWSVRJRVMsXG4gICAgcHJvcGVydGllcy5SRVZJU0lPTixcbiAgICBwcm9wZXJ0aWVzLlBMQVRGT1JNLFxuICAgIHByb3BlcnRpZXMuTEFOR1VBR0UsXG4gICAgcHJvcGVydGllcy5TVEFURU1FTlQsXG4gICAgcHJvcGVydGllcy5FWFRFTlNJT05TXG4gIF1cbn0pO1xuXG4gZXhwb3J0IHt4YXBpV2hpdGVMaXN0UHJvcGVydGllc307XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0XG4gIElTX1NUUklORyAgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgSVNfQVJSQVkgICA9ICdbb2JqZWN0IEFycmF5XScsXG4gIElTX0JPT0xFQU4gPSAnW29iamVjdCBCb29sZWFuXScsXG4gIElTX05VTUJFUiAgPSAnW29iamVjdCBOdW1iZXJdJ1xuO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHhhcGlWYWxpZGF0aW9uVXRpbHM7XG5cbnhhcGlWYWxpZGF0aW9uVXRpbHMgPSB7XG4gIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IElTX1NUUklORztcbiAgfSxcblxuICBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfSxcblxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IElTX0FSUkFZO1xuICB9LFxuXG4gIGlzQm9vbGVhbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSBJU19CT09MRUFOO1xuICB9LFxuXG4gIGlzTnVtYmVyKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IElTX05VTUJFUjtcbiAgfSxcblxuICBpc0RlZmluZWQob2JqKSB7XG4gICAgcmV0dXJuIChvYmogIT09IG51bGwgfHwgb2JqICE9PSB1bmRlZmluZWQpO1xuICB9LFxuXG4gIGlzTm9uTnVsbE1hcE9iamVjdCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRGVmaW5lZCh0YXJnZXQpICYmIHRoaXMuaXNPYmplY3QodGFyZ2V0KSAmJiAhdGhpcy5pc0FycmF5KHRhcmdldCk7XG4gIH0sXG5cbiAgaXNWYWxpZExhbmd1YWdlVGFnKHRhcmdldCwgdmFsaWRMYW5ndWFnZVJlZ2V4KSB7XG4gICAgLy8gVE9ETyAtIHVzZSBtb3JlIHByZWNpc2UgNTY0NiBoYW5kbGluZywgcmF0aGVyIHRoYW4gdGhpcyBzaW1wbGlmaWVkIEJDUCA0NyByZWdleCwgd2hpY2ggY29tYmluZXMgUkZDIDU2NDYgYW5kIFJGQyA0NjQ3LlxuICAgIC8vIHJldHVybiB0aGlzLmlzRGVmaW5lZCh0YXJnZXQpICYmIHRoaXMuaXNTdHJpbmcodGFyZ2V0KSAmJiB4YXBpVmFsaWRhdGlvblJlZ2V4LkJDUF80Ny50ZXN0KHRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZpbmVkKHRhcmdldCkgJiYgdGhpcy5pc1N0cmluZyh0YXJnZXQpICYmIHZhbGlkTGFuZ3VhZ2VSZWdleC50ZXN0KHRhcmdldCk7XG4gIH0sXG5cbiAgYWRkUHJvcFRvVHJhY2UodHJhY2UsIGFkZGVuZHVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZpbmVkKGFkZGVuZHVtKSA/IGAke3RyYWNlfS4ke2FkZGVuZHVtfWAgOiB0cmFjZTtcbiAgfSxcblxuICBhZGRMb29rdXBUb1RyYWNlKHRyYWNlLCBrZXkpIHtcbiAgICByZXR1cm4gKCF0aGlzLmlzRGVmaW5lZChrZXkpKSA/IHRyYWNlIDogKHRoaXMuaXNOdW1iZXIoa2V5KSA/IGAke3RyYWNlfVske2tleX1dYCA6IGAke3RyYWNlfVtcIiR7a2V5fVwiXWApO1xuICB9LFxuXG4gIGxvY2FsVHJhY2VUb1N0cmluZyh0cmFjZSwgYWRkZW5kdW0pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRQcm9wVG9UcmFjZSh0cmFjZSwgYWRkZW5kdW0pO1xuICB9LFxuXG4gIGlzR3JvdXAoYWN0b3JPckdyb3VwLCBncm91cFR5cGUpIHtcbiAgICAvLyByZXR1cm4gKGFjdG9yT3JHcm91cC5tZW1iZXIgIT09IG51bGwgJiYgYWN0b3JPckdyb3VwLm1lbWJlciAhPT0gdW5kZWZpbmVkKSB8fCBhY3Rvck9yR3JvdXAub2JqZWN0VHlwZSA9PT0gb2JqZWN0VHlwZXMuR1JPVVA7XG4gICAgcmV0dXJuIChhY3Rvck9yR3JvdXAubWVtYmVyICE9PSBudWxsICYmIGFjdG9yT3JHcm91cC5tZW1iZXIgIT09IHVuZGVmaW5lZCkgfHwgYWN0b3JPckdyb3VwLm9iamVjdFR5cGUgPT09IGdyb3VwVHlwZTtcbiAgfVxufTtcblxuZXhwb3J0IHt4YXBpVmFsaWRhdGlvblV0aWxzfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtwcm9wZXJ0aWVzLCBvYmplY3RUeXBlcywgeGFwaVZhbGlkYXRpb25JZmlQcm9wZXJ0eU5hbWVzLCB4QXBpVmFsaWRPYmplY3RUeXBlc30gZnJvbSAnLi9jb25zdGFudHMvcHJvcGVydGllcyc7XG5pbXBvcnQge3hhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzfSBmcm9tICcuL2NvbnN0YW50cy93aGl0ZWxpc3RzJztcbmltcG9ydCB7eGFwaUVycm9yTGV2ZWxzLCB4YXBpVmFsaWRhdGlvbkVycm9yc30gZnJvbSAnLi9jb25zdGFudHMvZXJyb3JzJztcbmltcG9ydCB7eGFwaVZhbGlkYXRpb25JbnRlcmFjdGlvblR5cGVzfSBmcm9tICcuL2NvbnN0YW50cy9pbnRlcmFjdGlvbi10eXBlcyc7XG5pbXBvcnQge3hhcGlWYWxpZGF0aW9uUmVnZXgsIGRhdGVGb3JtYXRSZWdleFBvc2l0aW9uc30gZnJvbSAnLi9jb25zdGFudHMvcmVnZXgnO1xuaW1wb3J0IHt4YXBpR2VuZXJhbH0gZnJvbSAnLi9jb25zdGFudHMvZ2VuZXJhbCc7XG5pbXBvcnQge3hhcGlWYWxpZGF0aW9uVXRpbHN9IGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuXG5mdW5jdGlvbiBtYWtlVjFSZXBvcnQoaW5zdGFuY2UsIGVycm9ycykge1xuICB2YXIgdmVyc2lvbjtcblxuICBpbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gIGVycm9ycyAgID0gZXJyb3JzICAgfHwgbnVsbDtcbiAgdmVyc2lvbiAgPSB4YXBpR2VuZXJhbC5GSVJTVF9SRVBPUlRfVkVSU1RJT047XG4gIHJldHVybiB7aW5zdGFuY2UsIGVycm9ycywgdmVyc2lvbn07XG59XG5cbmZ1bmN0aW9uIG1ha2VWMVNpbmdsZUVycm9yUmVwb3J0KGluc3RhbmNlLCBlcnJvcikge1xuICByZXR1cm4gbWFrZVYxUmVwb3J0KGluc3RhbmNlLCBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdW5kZWZpbmVkID8gW10gOiBbZXJyb3JdKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBYnNlbmNlT2ZOb25XaGl0ZWxpc3RlZFByb3BlcnRpZXModGFyZ2V0LCBhbGxvd2VkUHJvcGVydGllcywgdHJhY2UsIGVycm9ycykge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2UsIHByb3BlcnR5TmFtZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgJyc7XG5cbiAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIGFsbG93ZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHlOYW1lKSA9PT0geGFwaUdlbmVyYWwuTk9fSU5ERVhfRk9VTkQpIHtcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnR5TmFtZSksXG4gICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlVORVhQRUNURUQsXG4gICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5SXNTdHJpbmcocGFyZW50LCBwcm9wZXJ0eU5hbWUsIHRyYWNlLCBlcnJvcnMsIGlzUmVxdWlyZWQsIHZpb2xhdGlvblR5cGUpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlLCBwcm9wVmFsdWUsIGxvY2FsVmlvbGF0aW9uVHlwZTtcblxuICBsb2NhbEVycm9ycyAgICAgICAgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgICAgICAgICA9IHRyYWNlICB8fCAnJztcbiAgcHJvcFZhbHVlICAgICAgICAgID0gcGFyZW50W3Byb3BlcnR5TmFtZV0sXG4gIGxvY2FsVmlvbGF0aW9uVHlwZSA9IHZpb2xhdGlvblR5cGUgfHwgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OO1xuXG4gIGlmIChwcm9wVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNTdHJpbmcocHJvcFZhbHVlKSkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnR5TmFtZSksXG4gICAgICAgIG1lc3NhZ2U6IGAke3Byb3BlcnR5TmFtZX0gJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5NVVNUX0JFX1NUUklOR31gLFxuICAgICAgICBsZXZlbDogICBsb2NhbFZpb2xhdGlvblR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0eU5hbWUpLFxuICAgICAgbWVzc2FnZTogYCR7cHJvcGVydHlOYW1lfSAke3hhcGlWYWxpZGF0aW9uRXJyb3JzLk1VU1RfQkVfUFJFU0VOVH1gLFxuICAgICAgbGV2ZWw6ICAgbG9jYWxWaW9sYXRpb25UeXBlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlJc1VyaSh0YXJnZXQsIHByb3BlcnR5TmFtZSwgdHJhY2UsIGVycm9ycywgaXNSZXF1aXJlZCkge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2UsIHByb3BWYWx1ZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgJyc7XG4gIHByb3BWYWx1ZSAgID0gdGFyZ2V0W3Byb3BlcnR5TmFtZV07XG5cbiAgaWYgKHByb3BWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCAheGFwaVZhbGlkYXRpb25VdGlscy5pc1N0cmluZyhwcm9wVmFsdWUpKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydHlOYW1lKSxcbiAgICAgICAgbWVzc2FnZTogYCR7cHJvcGVydHlOYW1lfSAke3hhcGlWYWxpZGF0aW9uRXJyb3JzLk1VU1RfQkVfVVJJX1NUUklOR31gLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIXhhcGlWYWxpZGF0aW9uUmVnZXguSVJJLnRlc3QocHJvcFZhbHVlKSkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydHlOYW1lKSxcbiAgICAgICAgbWVzc2FnZTogYCR7cHJvcGVydHlOYW1lfSAke3hhcGlWYWxpZGF0aW9uRXJyb3JzLk1VU1RfQkVfSVJJX1NUUklOR31gLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuU0hPVUxEX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnR5TmFtZSksXG4gICAgICBtZXNzYWdlOiBgJHtwcm9wZXJ0eU5hbWV9ICR7eGFwaVZhbGlkYXRpb25FcnJvcnMuTVVTVF9CRV9VUklfUFJFU0VOVH1gLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5SXNVcmwodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHRyYWNlLCBlcnJvcnMsIGlzUmVxdWlyZWQpIHtcbiAgLy8gVE9ETyAtIGNoZWNrIHdoZXRoZXIgYSBmb3JtYWwgVVJMIGZvcm1hdCBkZWZpbml0aW9uIGlzIHJlY29tbWVuZGVkL2VuZm9yY2VkIGZvciB4QVBJXG4gIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5SXNTdHJpbmcodGFyZ2V0LCBwcm9wZXJ0eU5hbWUsIHRyYWNlLCBlcnJvcnMsIGlzUmVxdWlyZWQpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5SXNCb29sZWFuKHBhcmVudCwgcHJvcGVydHlOYW1lLCB0cmFjZSwgZXJyb3JzLCBpc1JlcXVpcmVkKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZSwgcHJvcFZhbHVlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCAnJztcbiAgcHJvcFZhbHVlICAgPSBwYXJlbnRbcHJvcGVydHlOYW1lXTtcblxuICBpZiAocHJvcFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8ICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzQm9vbGVhbihwcm9wVmFsdWUpKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydHlOYW1lKSxcbiAgICAgICAgbWVzc2FnZTogYCR7cHJvcGVydHlOYW1lfSAke3hhcGlWYWxpZGF0aW9uRXJyb3JzLk1VU1RfQkVfQk9PTEVBTn1gLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0eU5hbWUpLFxuICAgICAgbWVzc2FnZTogYCR7cHJvcGVydHlOYW1lfSAke3hhcGlWYWxpZGF0aW9uRXJyb3JzLk1VU1RfQkVfQk9PTEVBTl9QUkVTRU5UfWAsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlJc051bWJlcihwYXJlbnQsIHByb3BlcnR5TmFtZSwgdHJhY2UsIGVycm9ycywgaXNSZXF1aXJlZCkge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2UsIHByb3BWYWx1ZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgJyc7XG4gIHByb3BWYWx1ZSAgID0gcGFyZW50W3Byb3BlcnR5TmFtZV07XG5cbiAgICBpZiAocHJvcFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNOdW1iZXIocHJvcFZhbHVlKSkge1xuICAgICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0eU5hbWUpLFxuICAgICAgICAgIG1lc3NhZ2U6IGAke3Byb3BlcnR5TmFtZX0gJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5NVVNUX0JFX05VTUJFUn1gLFxuICAgICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0eU5hbWUpLFxuICAgICAgICBtZXNzYWdlOiBgJHtwcm9wZXJ0eU5hbWV9ICR7eGFwaVZhbGlkYXRpb25FcnJvcnMuTVVTVF9CRV9OVU1CRVJfUFJFU0VOVH1gLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSUZJUHJvcGVydGllcyh0YXJnZXQsIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlLCBhY2NvdW50VHJhY2U7XG5cbiAgbG9jYWxFcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgID0gdHJhY2UgIHx8ICcnO1xuXG4gIGlmICh0YXJnZXQubWJveCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5tYm94ICE9PSBudWxsKSB7XG4gICAgaWYgKCF4YXBpVmFsaWRhdGlvblV0aWxzLmlzU3RyaW5nKHRhcmdldC5tYm94KSkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLk1CT1gpLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5JRklfTVVTVF9CRV9NQk9YX1VSSSxcbiAgICAgICAgbGV2ZWw6IHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgheGFwaVZhbGlkYXRpb25SZWdleC5NQUlMVE9fVVJJLnRlc3QodGFyZ2V0Lm1ib3gpKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5NQk9YKSxcbiAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuSUZJX01VU1RfQkVfVkFMSURfTUJPWF9GT1JNQVQsXG4gICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eUlzU3RyaW5nKHRhcmdldCwgcHJvcGVydGllcy5NQk9YX1NIQV8xX1NVTSwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlKTtcbiAgdmFsaWRhdGVQcm9wZXJ0eUlzVXJpKHRhcmdldCwgcHJvcGVydGllcy5PUEVOX0lELCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgLyppc1JlcXVpcmVkKi9mYWxzZSk7XG5cbiAgaWYgKHRhcmdldC5hY2NvdW50ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LmFjY291bnQgIT09IG51bGwpIHtcbiAgICBhY2NvdW50VHJhY2UgPSB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuQUNDT1VOVCk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0eUlzVXJpKHRhcmdldC5hY2NvdW50LCBwcm9wZXJ0aWVzLkhPTUVfUEFHRSxhY2NvdW50VHJhY2UsIGxvY2FsRXJyb3JzLCAvKmlzUmVxdWlyZWQqL3RydWUpO1xuICAgIHZhbGlkYXRlUHJvcGVydHlJc1N0cmluZyh0YXJnZXQuYWNjb3VudCwgcHJvcGVydGllcy5OQU1FLCBhY2NvdW50VHJhY2UsIGxvY2FsRXJyb3JzLCAvKmlzUmVxdWlyZWQqL3RydWUpO1xuICAgIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKHRhcmdldC5hY2NvdW50LCB4YXBpV2hpdGVMaXN0UHJvcGVydGllcy5JRkksIGFjY291bnRUcmFjZSwgbG9jYWxFcnJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiBnZXRJRklzKHRhcmdldCkge1xuICB2YXIgaWZpcztcblxuICBpZiAodGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7cmV0dXJuIFtdO31cblxuICBpZmlzID0geGFwaVZhbGlkYXRpb25JZmlQcm9wZXJ0eU5hbWVzLmZpbHRlcigobmFtZSkgPT4ge1xuICAgIGlmICh0YXJnZXRbbmFtZV0gIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRbbmFtZV0gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7a2V5OiBuYW1lLCB2YWx1ZTogdGFyZ2V0W25hbWVdfTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZmlzO1xufVxuXG5mdW5jdGlvbiBnZXRJRklDb3VudCh0YXJnZXQpIHtcbiAgcmV0dXJuIGdldElGSXModGFyZ2V0KS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXh0ZW5zaW9ucyhleHRlbnNpb25zLCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXSxcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgcHJvcGVydGllcy5FWFRFTlNJT05TO1xuXG4gIGlmIChleHRlbnNpb25zID09PSB1bmRlZmluZWQpIHtyZXR1cm4gbG9jYWxFcnJvcnM7fVxuXG4gIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc05vbk51bGxNYXBPYmplY3QoZXh0ZW5zaW9ucykpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIGxvY2FsVHJhY2UsXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5FWFRFTlNJT05TX01VU1RfTk9UX0JFX05VTEwsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuICAvLyBUT0RPIC0gZG91YmxlLWNoZWNrIHdoYXQgZnVydGhlciBlbmZvcmNlYWJsZSBjb25zdHJhaW50cyBleGlzdCBvbiBleHRlbnNpb24gb2JqZWN0IHByb3BlcnRpZXNcbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxhbmd1YWdlTWFwKGxhbmd1YWdlTWFwLCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZSwgcHJvcE5hbWUsIG1hcHBlZFZhbHVlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLkxBTkdVQUdFX01BUDtcblxuICBpZiAobGFuZ3VhZ2VNYXAgPT09IHVuZGVmaW5lZCkge3JldHVybiBsb2NhbEVycm9yczt9XG5cbiAgaWYgKCF4YXBpVmFsaWRhdGlvblV0aWxzLmlzTm9uTnVsbE1hcE9iamVjdChsYW5ndWFnZU1hcCkpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5MQU5HVUFHRV9NQVBTX01VU1RfTk9UX0JFX05VTEwsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcblxuICAgIHJldHVybiBsb2NhbEVycm9ycztcbiAgfVxuXG4gIGZvciAocHJvcE5hbWUgaW4gbGFuZ3VhZ2VNYXApIHtcblxuICAgIGlmIChsYW5ndWFnZU1hcC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc1ZhbGlkTGFuZ3VhZ2VUYWcocHJvcE5hbWUsIHhhcGlWYWxpZGF0aW9uUmVnZXguQkNQXzQ3KSkge1xuICAgICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BOYW1lKSxcbiAgICAgICAgICBtZXNzYWdlOiBgJHtwcm9wTmFtZX0gJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5MQU5HVUFHRV9NQVBfS0VZX0lOVkFMSUR9YCxcbiAgICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG1hcHBlZFZhbHVlID0gbGFuZ3VhZ2VNYXBbcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobWFwcGVkVmFsdWUgPT09IG51bGwgfHwgbWFwcGVkVmFsdWUgPT09IHVuZGVmaW5lZCB8fCAheGFwaVZhbGlkYXRpb25VdGlscy5pc1N0cmluZyhtYXBwZWRWYWx1ZSkpIHtcbiAgICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRMb29rdXBUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BOYW1lKSxcbiAgICAgICAgICBtZXNzYWdlOiBgJHtwcm9wTmFtZX0gJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5MQU5HVUFHRV9NQVBfS0VZX01VU1RfQkVfU1RSSU5HfWAsXG4gICAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWZXJiKHZlcmIsIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLlZFUkI7XG5cbiAgaWYgKHZlcmIgPT09IHVuZGVmaW5lZCkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5WRVJCX01VU1RfQkVfUFJPVklERUQsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcblxuICAgIHJldHVybiBsb2NhbEVycm9ycztcbiAgfVxuXG4gIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc05vbk51bGxNYXBPYmplY3QodmVyYikpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuVkVSQl9NVVNUX05PVF9CRV9OVUxMLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BlcnR5SXNVcmkodmVyYiwgcHJvcGVydGllcy5JRCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL3RydWUpO1xuXG4gIGlmICh2ZXJiLmRpc3BsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkRJU1BMQVkpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuRElTUExBWV9TSE9VTERfQkVfUFJPVklERUQsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuU0hPVUxEX1ZJT0xBVElPTlxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlTGFuZ3VhZ2VNYXAodmVyYi5kaXNwbGF5LCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuRElTUExBWSksIGxvY2FsRXJyb3JzKTtcbiAgfVxuXG4gIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKHZlcmIsIHhhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzLlVSSSwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbnRlcmFjdGlvbkNvbXBvbmVudEFycmF5KGNvbXBvbmVudHMsIGludGVyYWN0aW9uVHlwZSwgYWxsb3dlZEludGVyYWN0aW9uVHlwZXMsIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlLCBpc0FsbG93ZWRDb21wb25lbnRUeXBlLCBpZHMsIHBlckNvbXBvbmVudFRyYWNlO1xuXG4gIGxvY2FsRXJyb3JzICAgICAgICAgICAgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgICAgICAgICAgICAgPSB0cmFjZSAgfHwgcHJvcGVydGllcy5JTlRFUkFDVElPTl9DT01QT05FTlRTO1xuICBpc0FsbG93ZWRDb21wb25lbnRUeXBlID0gYWxsb3dlZEludGVyYWN0aW9uVHlwZXMuaW5kZXhPZihpbnRlcmFjdGlvblR5cGUpICE9PSB4YXBpR2VuZXJhbC5OT19JTkRFWF9GT1VORDtcbiAgaWRzICAgICAgICAgICAgICAgICAgICA9IFtdO1xuXG4gIGlmIChpc0FsbG93ZWRDb21wb25lbnRUeXBlICYmIGNvbXBvbmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChjb21wb25lbnRzID09PSBudWxsIHx8ICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzQXJyYXkoY29tcG9uZW50cykpIHtcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICBsb2NhbFRyYWNlLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5JTlRFUkFDVElPTl9DT01QT05FTlRfU0hPVUxEX0JFX0FSUkFZLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuU0hPVUxEX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMuZm9yRWFjaCgoaW50ZXJhY3Rpb25Db21wb25lbnQsIGkpID0+IHtcbiAgICAgICAgcGVyQ29tcG9uZW50VHJhY2UgPSB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZExvb2t1cFRvVHJhY2UobG9jYWxUcmFjZSwgaSk7XG5cbiAgICAgICAgaWYgKCF4YXBpVmFsaWRhdGlvblV0aWxzLmlzTm9uTnVsbE1hcE9iamVjdChpbnRlcmFjdGlvbkNvbXBvbmVudCkpIHtcbiAgICAgICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIHRyYWNlOiAgIHBlckNvbXBvbmVudFRyYWNlLFxuICAgICAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuSU5URVJBQ1RJT05fQ09NUE9ORU5UX01VU1RfTk9UX0JFX05VTEwsXG4gICAgICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZVByb3BlcnR5SXNTdHJpbmcoaW50ZXJhY3Rpb25Db21wb25lbnQsIHByb3BlcnRpZXMuSUQsIHBlckNvbXBvbmVudFRyYWNlLCBsb2NhbEVycm9ycywgLyppc1JlcXVpcmVkKi90cnVlLCB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT04pO1xuICAgICAgICAgIGlmIChpZHMuaW5kZXhPZihpbnRlcmFjdGlvbkNvbXBvbmVudC5pZCkgIT09IHhhcGlHZW5lcmFsLk5PX0lOREVYX0ZPVU5EKSB7XG4gICAgICAgICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShwZXJDb21wb25lbnRUcmFjZSwgcHJvcGVydGllcy5JRCksXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLklEX01VU1RfQkVfVU5JUVVFLFxuICAgICAgICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZHMucHVzaChpbnRlcmFjdGlvbkNvbXBvbmVudC5pZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludGVyYWN0aW9uQ29tcG9uZW50LmlkICYmIHhhcGlWYWxpZGF0aW9uUmVnZXguQ09OVEFJTlNfV0hJVEVTUEFDRS50ZXN0KGludGVyYWN0aW9uQ29tcG9uZW50LmlkKSkge1xuICAgICAgICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UocGVyQ29tcG9uZW50VHJhY2UsIHByb3BlcnRpZXMuSUQpLFxuICAgICAgICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5JRF9TSE9VTERfTk9UX0NPTlRBSU5fV0hJVEVTUEFDRVMsXG4gICAgICAgICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5TSE9VTERfVklPTEFUSU9OXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWxpZGF0ZUxhbmd1YWdlTWFwKGludGVyYWN0aW9uQ29tcG9uZW50LmRlc2NyaXB0aW9uLCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKHBlckNvbXBvbmVudFRyYWNlLCBwcm9wZXJ0aWVzLkRFU0NSSVBUSU9OKSwgbG9jYWxFcnJvcnMpO1xuICAgICAgICAgIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKGludGVyYWN0aW9uQ29tcG9uZW50LCB4YXBpV2hpdGVMaXN0UHJvcGVydGllcy5DT01QT05FTlRfQVJSQVksIHBlckNvbXBvbmVudFRyYWNlLCBsb2NhbEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuICB9IGVsc2UgaWYgKGludGVyYWN0aW9uVHlwZSAmJiBjb21wb25lbnRzKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICBsb2NhbFRyYWNlLFxuICAgICAgbWVzc2FnZTogYCR7eGFwaVZhbGlkYXRpb25FcnJvcnMuSU5URVJBQ1RJT05fVFlQRV9NVVNUX0JFX1ZBTElEfSAke2ludGVyYWN0aW9uVHlwZX1gLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLlNIT1VMRF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBY3Rpdml0eURlZmludGlvbihkZWZpbml0aW9uLCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZSwgY29ycmVjdFJlc3BvbnNlc1BhdHRlcm5UcmFjZTtcblxuICBsb2NhbEVycm9ycyAgICAgICAgICAgICAgICAgID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICAgICAgICAgICAgICAgICAgID0gdHJhY2UgIHx8IHByb3BlcnRpZXMuREVGSU5JVElPTjtcbiAgY29ycmVjdFJlc3BvbnNlc1BhdHRlcm5UcmFjZSA9IHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5DT1JSRUNUX1JFU1BPTlNFU19QQVRURVJOKTtcblxuICBpZiAoIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNOb25OdWxsTWFwT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuREVGSU5JVElPTlNfTVVTVF9CRV9PQkpFQ1RTLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICB2YWxpZGF0ZUxhbmd1YWdlTWFwKGRlZmluaXRpb24ubmFtZSwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLk5BTUUpLCBsb2NhbEVycm9ycyk7XG4gIHZhbGlkYXRlTGFuZ3VhZ2VNYXAoZGVmaW5pdGlvbi5kZXNjcmlwdGlvbiwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkRFU0NSSVBUSU9OKSwgbG9jYWxFcnJvcnMpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHlJc1VyaShkZWZpbml0aW9uLCBwcm9wZXJ0aWVzLlRZUEUsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzLCAgLyppc1JlcXVpcmVkKi9mYWxzZSk7XG4gIHZhbGlkYXRlUHJvcGVydHlJc1VybChkZWZpbml0aW9uLCBwcm9wZXJ0aWVzLk1PUkVfSU5GTywgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlKTtcbiAgdmFsaWRhdGVFeHRlbnNpb25zKGRlZmluaXRpb24uZXh0ZW5zaW9ucywgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkVYVEVOU0lPTlMpLCBsb2NhbEVycm9ycyk7XG5cbiAgaWYgKGRlZmluaXRpb24uaW50ZXJhY3Rpb25UeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGVmaW5pdGlvbi50eXBlICE9PSB4YXBpR2VuZXJhbC5JTlRFUkFDVElPTl9ERUZJTklUSU9OX1RZUEUpIHtcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLlRZUEUpLFxuICAgICAgICBtZXNzYWdlOiBgJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5JTlRFUkFDVElPTl9BQ1RJVklUWV9TSE9VTERfSEFWRX0gXCIke3hhcGlHZW5lcmFsLklOVEVSQUNUSU9OX0RFRklOSVRJT05fVFlQRX1cImAsXG4gICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5TSE9VTERfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoeGFwaVZhbGlkYXRpb25JbnRlcmFjdGlvblR5cGVzLmluZGV4T2YoZGVmaW5pdGlvbi5pbnRlcmFjdGlvblR5cGUpID09PSB4YXBpR2VuZXJhbC5OT19JTkRFWF9GT1VORCkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuSU5URVJBQ1RJT05fVFlQRSksXG4gICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLklOVEVSQUNUSU9OX1RZUEVfTVVTVF9CRV9DTUksXG4gICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRlZmluaXRpb24uY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc0FycmF5KGRlZmluaXRpb24uY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4pKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgY29ycmVjdFJlc3BvbnNlc1BhdHRlcm5UcmFjZSxcbiAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuQ09SUkVDVF9SRVNQT05TRVNfUEFUVEVSTl9NVVNUX0JFX0FSUkFZLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbml0aW9uLmNvcnJlY3RSZXNwb25zZXNQYXR0ZXJuLmZvckVhY2goKHJlc3BvbnNlLCBpKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdW5kZWZpbmVkIHx8ICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzU3RyaW5nKHJlc3BvbnNlKSkge1xuICAgICAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRMb29rdXBUb1RyYWNlKGNvcnJlY3RSZXNwb25zZXNQYXR0ZXJuVHJhY2UsIGkpLFxuICAgICAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuQ09SUkVDVF9SRVNQT05TRVNfUEFUVEVSTl9NVVNUX0JFX1NUUklOR1MsXG4gICAgICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVJbnRlcmFjdGlvbkNvbXBvbmVudEFycmF5KFxuICAgIGRlZmluaXRpb24uY2hvaWNlcyxcbiAgICBkZWZpbml0aW9uLmludGVyYWN0aW9uVHlwZSxcbiAgICBbcHJvcGVydGllcy5DSE9JQ0UsIHByb3BlcnRpZXMuU0VRVUVOQ0lOR10sXG4gICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkNIT0lDRVMpLFxuICAgIGxvY2FsRXJyb3JzXG4gICk7XG5cbiAgdmFsaWRhdGVJbnRlcmFjdGlvbkNvbXBvbmVudEFycmF5KFxuICAgIGRlZmluaXRpb24uc2NhbGUsXG4gICAgZGVmaW5pdGlvbi5pbnRlcmFjdGlvblR5cGUsXG4gICAgW3Byb3BlcnRpZXMuTElLRVJUXSxcbiAgICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuU0NBTEUpLFxuICAgIGxvY2FsRXJyb3JzXG4gICk7XG5cbiAgdmFsaWRhdGVJbnRlcmFjdGlvbkNvbXBvbmVudEFycmF5KFxuICAgIGRlZmluaXRpb24uc291cmNlLFxuICAgIGRlZmluaXRpb24uaW50ZXJhY3Rpb25UeXBlLFxuICAgIFtwcm9wZXJ0aWVzLk1BVENISU5HXSxcbiAgICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuU09VUkNFKSxcbiAgICBsb2NhbEVycm9yc1xuICApO1xuXG4gIHZhbGlkYXRlSW50ZXJhY3Rpb25Db21wb25lbnRBcnJheShcbiAgICBkZWZpbml0aW9uLnRhcmdldCxcbiAgICBkZWZpbml0aW9uLmludGVyYWN0aW9uVHlwZSxcbiAgICBbcHJvcGVydGllcy5NQVRDSElOR10sXG4gICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLlRBUkdFVCksXG4gICAgbG9jYWxFcnJvcnNcbiAgKTtcblxuICB2YWxpZGF0ZUludGVyYWN0aW9uQ29tcG9uZW50QXJyYXkoXG4gICAgZGVmaW5pdGlvbi5zdGVwcyxcbiAgICBkZWZpbml0aW9uLmludGVyYWN0aW9uVHlwZSxcbiAgICBbcHJvcGVydGllcy5QRVJGT1JNQU5DRV0sXG4gICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLlNURVBTKSxcbiAgICBsb2NhbEVycm9yc1xuICApO1xuXG4gIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKGRlZmluaXRpb24sIHhhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzLkFDVElWSVRZX0RFRklOSVRJT04sIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFjdGl2aXR5KGFjdGl2aXR5LCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgcHJvcGVydGllcy5BQ1RJVklUWTtcblxuICBpZiAoIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNOb25OdWxsTWFwT2JqZWN0KGFjdGl2aXR5KSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5BQ1RJVklUSUVTX01VU1RfTk9UX0JFX05VTEwsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcblxuICAgIHJldHVybiBsb2NhbEVycm9ycztcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcGVydHlJc1VyaShhY3Rpdml0eSwgcHJvcGVydGllcy5JRCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL3RydWUpO1xuXG4gIGlmIChhY3Rpdml0eS5kZWZpbml0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0ZUFjdGl2aXR5RGVmaW50aW9uKFxuICAgICAgYWN0aXZpdHkuZGVmaW5pdGlvbixcbiAgICAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5ERUZJTklUSU9OKSxcbiAgICAgIGxvY2FsRXJyb3JzXG4gICAgKTtcbiAgfVxuXG4gIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKGFjdGl2aXR5LCB4YXBpV2hpdGVMaXN0UHJvcGVydGllcy5BQ1RJVklUWSwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdGF0ZW1lbnRSZWYoc3RhdGVtZW50UmVmLCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgcHJvcGVydGllcy5TVEFURU1FTlRfUkVGO1xuXG4gIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc05vbk51bGxNYXBPYmplY3Qoc3RhdGVtZW50UmVmKSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5TVEFURU1FTlRfUkVGX01VU1RfTk9UX0JFX05VTExfTUFQX09CSkVDVFMsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuXG4gIGlmIChzdGF0ZW1lbnRSZWYub2JqZWN0VHlwZSAhPT0gb2JqZWN0VHlwZXMuU1RBVEVNRU5UX1JFRikge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLk9CSkVDVF9UWVBFKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLk9CSkVDVF9UWVBFX01VU1RfQkVfU1RBVEVNRU5UX1JFRixcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFzdGF0ZW1lbnRSZWYuaWQgfHwgIXhhcGlWYWxpZGF0aW9uUmVnZXguVVVJRC50ZXN0KHN0YXRlbWVudFJlZi5pZCkpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5JRCksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5JRF9NVVNUX0JFX1ZBTElEX1VVSURfUkVGLFxuICAgICAgbGV2ZWw6ICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKHN0YXRlbWVudFJlZiwgeGFwaVdoaXRlTGlzdFByb3BlcnRpZXMuU1RBVEVNRU5UX1JFRiwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTY29yZShzY29yZSwgdHJhY2UsIGVycm9ycykge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2U7XG5cbiAgbG9jYWxFcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgID0gdHJhY2UgIHx8IHByb3BlcnRpZXMuU0NPUkU7XG5cbiAgaWYgKHNjb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBsb2NhbEVycm9ycztcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcGVydHlJc051bWJlcihzY29yZSwgcHJvcGVydGllcy5TQ0FMRUQsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzLCAgLyppc1JlcXVpcmVkKi9mYWxzZSk7XG5cbiAgaWYgKHNjb3JlLnNjYWxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHNjb3JlLnNjYWxlZCA8IHhhcGlHZW5lcmFsLk1JTl9TQ0FMRURfVkFMVUUgfHwgc2NvcmUuc2NhbGVkID4geGFwaUdlbmVyYWwuTUFYX1NDQUxFRF9WQUxVRSkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5TQ0FMRUQpLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5TQ0FMRURfTVVTVF9CRV9CRVRXRUVOXzBfMSxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NvcmUubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnR5SXNOdW1iZXIoc2NvcmUsIHByb3BlcnRpZXMuTUlOLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgIC8qaXNSZXF1aXJlZCovZmFsc2UpO1xuXG4gICAgICBpZiAoc2NvcmUucmF3ICE9PSB1bmRlZmluZWQgJiYgc2NvcmUucmF3IDwgc2NvcmUubWluKSB7XG4gICAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5SQVcpLFxuICAgICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlJBV19NVVNUX0JFX0dSRUFURVJfVEhBTl9NSU4sXG4gICAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NvcmUubWF4ICE9PSB1bmRlZmluZWQgJiYgc2NvcmUubWF4IDwgc2NvcmUubWluKSB7XG4gICAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5NQVgpLFxuICAgICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLk1BWF9NVVNUX0JFX0dSRUFURVJfVEhBTl9NSU4sXG4gICAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHNjb3JlLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0eUlzTnVtYmVyKHNjb3JlLCBwcm9wZXJ0aWVzLk1BWCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlKTtcblxuICAgIGlmIChzY29yZS5yYXcgIT09IHVuZGVmaW5lZCAmJiBzY29yZS5yYXcgPiBzY29yZS5tYXgpIHtcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuUkFXKSxcbiAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuUkFXX01VU1RfQkVfTEVTU19USEFOX01BWCxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZVByb3BlcnR5SXNOdW1iZXIoc2NvcmUsIHByb3BlcnRpZXMuUkFXLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgIC8qaXNSZXF1aXJlZCovZmFsc2UpO1xuICB2YWxpZGF0ZUFic2VuY2VPZk5vbldoaXRlbGlzdGVkUHJvcGVydGllcyhzY29yZSwgeGFwaVdoaXRlTGlzdFByb3BlcnRpZXMuU0NPUkUsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcblxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzdWx0KHJlc3VsdCwgdHJhY2UsIGVycm9ycykge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2U7XG5cbiAgbG9jYWxFcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgID0gdHJhY2UgIHx8IHByb3BlcnRpZXMuUkVTVUxUO1xuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge3JldHVybiBsb2NhbEVycm9yczt9XG5cbiAgaWYgKCF4YXBpVmFsaWRhdGlvblV0aWxzLmlzTm9uTnVsbE1hcE9iamVjdChyZXN1bHQpKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuUkVTVUxUX01VU1RfQkVfTUFQX09CSkVDVCxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG5cbiAgdmFsaWRhdGVTY29yZShyZXN1bHQuc2NvcmUsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5TQ09SRSksIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVQcm9wZXJ0eUlzQm9vbGVhbihyZXN1bHQsIHByb3BlcnRpZXMuU1VDQ0VTUywgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlKTtcbiAgdmFsaWRhdGVQcm9wZXJ0eUlzQm9vbGVhbihyZXN1bHQsIHByb3BlcnRpZXMuQ09NUExFVElPTiwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlKTtcbiAgdmFsaWRhdGVQcm9wZXJ0eUlzU3RyaW5nKHJlc3VsdCwgcHJvcGVydGllcy5SRVNQT05TRSwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlKTtcbiAgdmFsaWRhdGVFeHRlbnNpb25zKHJlc3VsdC5leHRlbnNpb25zLCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuRVhURU5TSU9OUyksIGxvY2FsRXJyb3JzKTtcblxuICBpZiAocmVzdWx0LmR1cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKHJlc3VsdC5kdXJhdGlvbiA9PT0gbnVsbCB8fCAheGFwaVZhbGlkYXRpb25VdGlscy5pc1N0cmluZyhyZXN1bHQuZHVyYXRpb24pIHx8ICF4YXBpVmFsaWRhdGlvblJlZ2V4LklTT184NjAxX0RVUkFUSU9OLnRlc3QocmVzdWx0LmR1cmF0aW9uKSkpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5EVVJBVElPTiksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5EVVJBVElPTl9NVVNUX0JFX1ZBTElELFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG4gIH1cblxuICB2YWxpZGF0ZUFic2VuY2VPZk5vbldoaXRlbGlzdGVkUHJvcGVydGllcyhyZXN1bHQsIHhhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzLlJFU1VMVCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eUlzSVNPODYwMVN0cmluZyhwYXJlbnQsIHByb3BlcnR5TmFtZSwgdHJhY2UsIGVycm9ycykge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2UsIG1hdGNoZWQsIGRhdGV0aW1lO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLkRBVEVfVElNRTtcbiAgZGF0ZXRpbWUgICAgPSBwYXJlbnRbcHJvcGVydHlOYW1lXTtcblxuICBpZiAoZGF0ZXRpbWUgPT09IHVuZGVmaW5lZCkge3JldHVybiBsb2NhbEVycm9yczt9XG5cbiAgaWYgKGRhdGV0aW1lID09PSBudWxsIHx8ICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzU3RyaW5nKGRhdGV0aW1lKSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydHlOYW1lKSxcbiAgICAgIG1lc3NhZ2U6IGAke3Byb3BlcnR5TmFtZX0gJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5NVVNUX0JFX1NUUklOR31gLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICBtYXRjaGVkID0geGFwaVZhbGlkYXRpb25SZWdleC5JU09fODYwMV9EQVRFX1RJTUUuZXhlYyhkYXRldGltZSk7XG5cbiAgaWYgKG1hdGNoZWQpIHtcbiAgICBpZiAoIWRhdGVJbmNsdWRlc1pvbmVJbmZvcm1hdGlvbihtYXRjaGVkKSkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnR5TmFtZSksXG4gICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLkRBVEVfU0hPVUxEX0lOQ0xVREVfWk9ORV9JTkZPUk1BVElPTixcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLlNIT1VMRF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnR5TmFtZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5EQVRFX01VU1RfQkVfVkFMSUQsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLlZFUlNJT047XG5cbiAgaWYgKHZlcnNpb24gPT09IHVuZGVmaW5lZCkge3JldHVybiBsb2NhbEVycm9yczt9XG5cbiAgaWYgKHZlcnNpb24gPT09IG51bGwgfHwgIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNTdHJpbmcodmVyc2lvbikgfHwgIXhhcGlWYWxpZGF0aW9uUmVnZXguU0VNVkVSXzFfUF8wX1BfMC50ZXN0KHZlcnNpb24pKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlZFUlNJT05fTVVTVF9DT01QTFlfU0VNQU5USUNfVkVSU0lPTklORyxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF0dGFjaG1lbnRPYmplY3QoYXR0YWNobWVudCwgdHJhY2UsIGVycm9ycykge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2U7XG5cbiAgbG9jYWxFcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgID0gdHJhY2UgfHwgcHJvcGVydGllcy5BVFRBQ0hNRU5UO1xuXG4gIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc05vbk51bGxNYXBPYmplY3QoYXR0YWNobWVudCkpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuQVRUQUNITUVOVFNfTVVTVF9OT1RfQkVfTlVMTF9NQVBfT0JKRUNUUyxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG5cbiAgaWYgKGF0dGFjaG1lbnQuZGlzcGxheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkRJU1BMQVkpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuRElTUExBWV9TSE9VTERfQkVfUFJPVklERUQsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcblxuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlTGFuZ3VhZ2VNYXAoYXR0YWNobWVudC5kaXNwbGF5LCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuRElTUExBWSksIGxvY2FsRXJyb3JzKTtcbiAgfVxuXG4gIHZhbGlkYXRlTGFuZ3VhZ2VNYXAoYXR0YWNobWVudC5kZXNjcmlwdGlvbiwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkRFU0NSSVBUSU9OKSwgbG9jYWxFcnJvcnMpO1xuICB2YWxpZGF0ZVByb3BlcnR5SXNVcmkoYXR0YWNobWVudCwgcHJvcGVydGllcy5VU0FHRV9UWVBFLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgLyppc1JlcXVpcmVkKi90cnVlLCB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT04pO1xuICB2YWxpZGF0ZVByb3BlcnR5SXNVcmkoYXR0YWNobWVudCwgcHJvcGVydGllcy5GSUxFX1VSTCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsICAvKmlzUmVxdWlyZWQqL2ZhbHNlLCB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT04pO1xuXG4gIC8vIFRPRE8gLSBtb3JlIGNvbXBsZXRlIHZhbGlkYXRpb24gZm9yIEludGVybmV0IE1lZGlhIFR5cGUgdmlhIFJGQyAyMDQ2XG4gIHZhbGlkYXRlUHJvcGVydHlJc1N0cmluZyhhdHRhY2htZW50LCBwcm9wZXJ0aWVzLkNPTlRFTlRfVFlQRSwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsIC8qaXNSZXF1aXJlZCovdHJ1ZSwgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OKTtcblxuICBpZiAoYXR0YWNobWVudC5sZW5ndGggPT09IHVuZGVmaW5lZCB8fCBhdHRhY2htZW50Lmxlbmd0aCA9PT0gbnVsbCB8fCAheGFwaVZhbGlkYXRpb25VdGlscy5pc051bWJlcihhdHRhY2htZW50Lmxlbmd0aCkgfHwgKGF0dGFjaG1lbnQubGVuZ3RoICUgMSAhPT0gMCkpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuTEVOR1RIKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLkxFTkdUSF9NVVNUX0JFX0lOVEVHRVIsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhdHRhY2htZW50LnNoYTIgPT09IHVuZGVmaW5lZCkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5TSEEyKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlNIQTJfTVVTVF9CRV9QUk9WSURFRF9PTl9BVFRBQ0hNRU5UX09CSkVDVFMsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChhdHRhY2htZW50LnNoYTIgPT09IG51bGwgfHwgIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNTdHJpbmcoYXR0YWNobWVudC5zaGEyKSB8fCAheGFwaVZhbGlkYXRpb25SZWdleC5CQVNFXzY0LnRlc3QoYXR0YWNobWVudC5zaGEyKSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5TSEEyKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlNIQTJfTVVTVF9DT05UQUlOX0JBU0VfNjRfU1RSSU5HLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG4gIH1cblxuICB2YWxpZGF0ZUFic2VuY2VPZk5vbldoaXRlbGlzdGVkUHJvcGVydGllcyhhdHRhY2htZW50LCB4YXBpV2hpdGVMaXN0UHJvcGVydGllcy5BVFRBQ0hNRU5ULCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBdHRhY2htZW50cyhhdHRhY2htZW50cywgdHJhY2UsIGVycm9ycykge1xuICB2YXIgbG9jYWxFcnJvcnMsIGxvY2FsVHJhY2U7XG5cbiAgbG9jYWxFcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gIGxvY2FsVHJhY2UgID0gdHJhY2UgIHx8IHByb3BlcnRpZXMuQVRUQUNITUVOVFM7XG5cbiAgaWYgKGF0dGFjaG1lbnRzID09PSB1bmRlZmluZWQpIHtyZXR1cm4gbG9jYWxFcnJvcnM7fVxuXG4gIGlmIChhdHRhY2htZW50cyA9PT0gbnVsbCB8fCAheGFwaVZhbGlkYXRpb25VdGlscy5pc0FycmF5KGF0dGFjaG1lbnRzKSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5BVFRBQ0hNRU5UU19NVVNUX0JFX05PVF9OVUxMX0FSUkFZLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICBhdHRhY2htZW50cy5mb3JFYWNoKChhdHRhY2htZW50LCBpKSA9PiB7XG4gICAgdmFsaWRhdGVBdHRhY2htZW50T2JqZWN0KGF0dGFjaG1lbnQsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkTG9va3VwVG9UcmFjZShsb2NhbFRyYWNlLCBpKSwgbG9jYWxFcnJvcnMpO1xuICB9KTtcblxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQWdlbnQoYWdlbnQsIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlLCBpZmlDb3VudDtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgcHJvcGVydGllcy5BR0VOVDtcblxuICBpZiAoIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNOb25OdWxsTWFwT2JqZWN0KGFnZW50KSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5BR0VOVF9NVVNUX0JFX05PTl9OVUxMX01BUF9PQkpFQ1QsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICBpZmlDb3VudCA9IGdldElGSUNvdW50KGFnZW50KTtcblxuICBpZiAoaWZpQ291bnQgIT09IHhhcGlHZW5lcmFsLk5VTUVSX09GX1NQRUNJRklFRF9JRklfUFJPUEVSVElFUykge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5BR0VOVF9JRklfUFJPUEVSVElFU19NVVNUX0JFX1NQRUNJRklFRCxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGFnZW50Lm9iamVjdFR5cGUgPT09IG9iamVjdFR5cGVzLkdST1VQKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLkFHRU5UX01VU1RfTk9UX0hBVkVfR1JPVVBfQ0hBUkFDVEVSSVNUSUNTLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG4gIH1cblxuICB2YWxpZGF0ZUlGSVByb3BlcnRpZXMoYWdlbnQsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVQcm9wZXJ0eUlzU3RyaW5nKGFnZW50LCBwcm9wZXJ0aWVzLk5BTUUsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzLCAgLyppc1JlcXVpcmVkKi9mYWxzZSk7XG5cbiAgdmFsaWRhdGVBYnNlbmNlT2ZOb25XaGl0ZWxpc3RlZFByb3BlcnRpZXMoYWdlbnQsIHhhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzLkFHRU5ULCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUdyb3VwKGdyb3VwLCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZSwgbWVtYmVyVHJhY2UsIGlmaUNvdW50O1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLkdST1VQO1xuICBtZW1iZXJUcmFjZSA9IHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5NRU1CRVIpO1xuXG4gIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc05vbk51bGxNYXBPYmplY3QoZ3JvdXApKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLkdST1VQX01VU1RfQkVfTk9OX05VTExfTUFQX09CSkVDVCxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG5cbiAgaWZpQ291bnQgPSBnZXRJRklDb3VudChncm91cCk7XG5cbiAgaWYgKGlmaUNvdW50ID09PSAwKSB7XG4gICAgaWYgKGdyb3VwLm1lbWJlciA9PT0gbnVsbCB8fCBncm91cC5tZW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgIG1lbWJlclRyYWNlLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5NRU1CRVJfTVVTVF9CRV9QUk9WSURFRF9GT1JfQU5PTllNT1VTX0dST1VQUyxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaWZpQ291bnQgPiB4YXBpR2VuZXJhbC5OVU1FUl9PRl9TUEVDSUZJRURfSUZJX1BST1BFUlRJRVMpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuR1JPVVBfSUZJX1BST1BFUlRJRVNfTVVTVF9CRV9TUEVDSUZJRUQsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIHZhbGlkYXRlSUZJUHJvcGVydGllcyhncm91cCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHlJc1N0cmluZyhncm91cCwgcHJvcGVydGllcy5OQU1FLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgIC8qaXNSZXF1aXJlZCovZmFsc2UpO1xuXG4gIGlmIChncm91cC5tZW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChncm91cC5tZW1iZXIgPT09IG51bGwgfHwgIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNBcnJheShncm91cC5tZW1iZXIpKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5NRU1CRVIpLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5HUk9VUF9NRU1CRVJfTVVTVF9CRV9BUlJBWSxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAubWVtYmVyLmZvckVhY2goKG1lbWJlciwgaSkgPT4ge1xuICAgICAgICB2YWxpZGF0ZUFnZW50KG1lbWJlciwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRMb29rdXBUb1RyYWNlKG1lbWJlclRyYWNlLCBpKSwgbG9jYWxFcnJvcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVBYnNlbmNlT2ZOb25XaGl0ZWxpc3RlZFByb3BlcnRpZXMoZ3JvdXAsIHhhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzLkdST1VQLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFjdG9yKGFjdG9yLCB0cmFjZSwgZXJyb3JzKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSAgPSB0cmFjZSAgfHwgcHJvcGVydGllcy5BQ1RPUjtcblxuICBpZiAoYWN0b3IgPT09IG51bGwgfHwgYWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5BQ1RPUl9NVVNUX0JFX1BST1ZJREVELFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICBpZiAoeGFwaVZhbGlkYXRpb25VdGlscy5pc0dyb3VwKGFjdG9yLCBvYmplY3RUeXBlcy5HUk9VUCkpIHtcbiAgICB2YWxpZGF0ZUdyb3VwKGFjdG9yLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVBZ2VudChhY3RvciwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF1dGhvcml0eShhdXRob3JpdHksIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLkFVVEhPUklUWTtcblxuICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICBpZiAoIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNOb25OdWxsTWFwT2JqZWN0KGF1dGhvcml0eSkpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuQVVUSE9SSVRZX01VU1RfQkVfTk9OX05VTExfTUFQX09CSkVDVCxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG4gIGlmICh4YXBpVmFsaWRhdGlvblV0aWxzLmlzR3JvdXAoYXV0aG9yaXR5LCBvYmplY3RUeXBlcy5HUk9VUCkpIHtcbiAgICB2YWxpZGF0ZUdyb3VwKGF1dGhvcml0eSwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuICAgIGlmICghYXV0aG9yaXR5Lm1lbWJlciB8fCAhYXV0aG9yaXR5Lm1lbWJlci5sZW5ndGggfHwgYXV0aG9yaXR5Lm1lbWJlci5sZW5ndGggIT09IHhhcGlHZW5lcmFsLkdST1VQX0FVVEhPUklUWV9BR0VOVF9NRU1CRVJTKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5NRU1CRVIpLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5HUk9VUF9BVVRIT1JJVFlfQUdFTlRfTUVNQkVSU19NVVNUX0JFX1RXTyxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVBZ2VudChhdXRob3JpdHksIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcbiAgfVxuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0QWN0aXZpdHlTdWJDb250ZXh0KHN1YkNvbnRleHQsIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLlNVQl9DT05URVhUO1xuXG4gIGlmIChzdWJDb250ZXh0ID09PSB1bmRlZmluZWQpIHtyZXR1cm4gbG9jYWxFcnJvcnM7fVxuXG4gIGlmIChzdWJDb250ZXh0ID09PSBudWxsKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLkNPTlRFWFRfQUNUSVZJVElFU19NVVNUX05PVF9CRV9OVUxMLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoeGFwaVZhbGlkYXRpb25VdGlscy5pc0FycmF5KHN1YkNvbnRleHQpKSB7XG4gICAgc3ViQ29udGV4dC5mb3JFYWNoKChhY3Rpdml0eSwgaSkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3Rpdml0eShhY3Rpdml0eSwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRMb29rdXBUb1RyYWNlKGxvY2FsVHJhY2UsIGkpLCBsb2NhbEVycm9ycyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoeGFwaVZhbGlkYXRpb25VdGlscy5pc09iamVjdChzdWJDb250ZXh0KSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5DT05URVhUX0FDVElWSVRJRVNfU0hPVUxEX0JFX0FOX0FSUkFZLFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLlNIT1VMRF9WSU9MQVRJT05cbiAgICB9KTtcblxuICAgIHZhbGlkYXRlQWN0aXZpdHkoc3ViQ29udGV4dCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuICB9IGVsc2Uge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSksXG4gICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5DT05URVhUX0FDVElWSVRJRVNfTVVTVF9CRV9BUlJBWV9PUl9BQ1RJVklUWV9PQkosXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT059KTtcbiAgfVxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dEFjdGl2aXRpZXMoY29udGV4dEFjdGl2aXRpZXMsIHRyYWNlLCBlcnJvcnMpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLkNPTlRFWFRfQUNUSVZJVElFUztcblxuICBpZiAoY29udGV4dEFjdGl2aXRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBsb2NhbEVycm9ycztcbiAgfVxuXG4gIGlmICgheGFwaVZhbGlkYXRpb25VdGlscy5pc05vbk51bGxNYXBPYmplY3QoY29udGV4dEFjdGl2aXRpZXMpKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLkNPTlRFWFRfQUNUSVZJVElFU19NVVNUX0JFX05PTl9OVUxMX01BUF9PQkpFQ1QsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgICByZXR1cm4gbG9jYWxFcnJvcnM7XG4gIH1cblxuICB2YWxpZGF0ZUNvbnRleHRBY3Rpdml0eVN1YkNvbnRleHQoY29udGV4dEFjdGl2aXRpZXMucGFyZW50LCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuUEFSRU5UKSwgbG9jYWxFcnJvcnMpO1xuICB2YWxpZGF0ZUNvbnRleHRBY3Rpdml0eVN1YkNvbnRleHQoY29udGV4dEFjdGl2aXRpZXMuZ3JvdXBpbmcsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5HUk9VUElORyksIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVDb250ZXh0QWN0aXZpdHlTdWJDb250ZXh0KGNvbnRleHRBY3Rpdml0aWVzLmNhdGVnb3J5LCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuQ0FURUdPUlkpLCBsb2NhbEVycm9ycyk7XG4gIHZhbGlkYXRlQ29udGV4dEFjdGl2aXR5U3ViQ29udGV4dChjb250ZXh0QWN0aXZpdGllcy5vdGhlciwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLk9USEVSKSwgbG9jYWxFcnJvcnMpO1xuXG4gIHZhbGlkYXRlQWJzZW5jZU9mTm9uV2hpdGVsaXN0ZWRQcm9wZXJ0aWVzKGNvbnRleHRBY3Rpdml0aWVzLCB4YXBpV2hpdGVMaXN0UHJvcGVydGllcy5DT05URVhUX0FDVElWSVRJRVMsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcblxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dChjb250ZXh0LCB0cmFjZSwgZXJyb3JzLCBzdGF0ZW1lbnRPYmplY3RPYmplY3RUeXBlKSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZTtcblxuICBsb2NhbEVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgbG9jYWxUcmFjZSA9IHRyYWNlIHx8IHByb3BlcnRpZXMuQ09OVEVYVDtcblxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7cmV0dXJuIGxvY2FsRXJyb3JzO31cblxuICBpZiAoIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNOb25OdWxsTWFwT2JqZWN0KGNvbnRleHQpKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICBsb2NhbFRyYWNlLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuQ09OVEVYVF9NVVNUX0JFX05PTl9OVUxfTUFQX09CSkVDVCxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG5cbiAgaWYgKGNvbnRleHQucmVnaXN0cmF0aW9uICE9PSB1bmRlZmluZWQgJiYgKGNvbnRleHQucmVnaXN0cmF0aW9uID09PSBudWxsIHx8ICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzU3RyaW5nKGNvbnRleHQucmVnaXN0cmF0aW9uKSB8fCAheGFwaVZhbGlkYXRpb25SZWdleC5VVUlELnRlc3QoY29udGV4dC5yZWdpc3RyYXRpb24pKSkge1xuICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5SRUdJU1RSQVRJT04pLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuUkVHSVNUUkFUSU9OX01VU1RfQkVfVVVJRF9TVFJJTkcsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChbb2JqZWN0VHlwZXMuR1JPVVAsIG9iamVjdFR5cGVzLkFHRU5UXS5pbmRleE9mKHN0YXRlbWVudE9iamVjdE9iamVjdFR5cGUpICE9PSB4YXBpR2VuZXJhbC5OT19JTkRFWF9GT1VORCkge1xuICAgIGlmIChjb250ZXh0LnJldmlzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLlJFVklTSU9OKSxcbiAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuUkVWSVNJT05fTVVTVF9CRV9BR0VOVF9PUl9HUk9VUCxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5wbGF0Zm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5QTEFURk9STSksXG4gICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlBMQVRGT1JNX01VU1RfTk9UX0JFX1VTRURfV0lUSF9SRVZJU0lPTl9BR0VOVF9PUl9HUk9VUCxcbiAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZVByb3BlcnR5SXNTdHJpbmcoY29udGV4dCwgcHJvcGVydGllcy5SRVZJU0lPTiwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMsIC8qaXNSZXF1aXJlZCovZmFsc2UsIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTik7XG4gIHZhbGlkYXRlUHJvcGVydHlJc1N0cmluZyhjb250ZXh0LCBwcm9wZXJ0aWVzLlBMQVRGT1JNLCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgLyppc1JlcXVpcmVkKi9mYWxzZSwgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OKTtcblxuICBpZiAoY29udGV4dC50ZWFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlR3JvdXAoY29udGV4dC50ZWFtLCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuVEVBTSksIGxvY2FsRXJyb3JzKTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LmNvbnRleHRBY3Rpdml0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0ZUNvbnRleHRBY3Rpdml0aWVzKGNvbnRleHQuY29udGV4dEFjdGl2aXRpZXMsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5DT05URVhUX0FDVElWSVRJRVMpLCBsb2NhbEVycm9ycyk7XG4gIH1cblxuICBpZiAoY29udGV4dC5sYW5ndWFnZSAhPT0gdW5kZWZpbmVkICYmICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzVmFsaWRMYW5ndWFnZVRhZyhjb250ZXh0Lmxhbmd1YWdlLCB4YXBpVmFsaWRhdGlvblJlZ2V4LkJDUF80NykpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuTEFOR1VBR0UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuTEFOR1VBR0VfTVVTVF9CRV9TVFJJTkcsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjb250ZXh0LnN0YXRlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdGVTdGF0ZW1lbnRSZWYoY29udGV4dC5zdGF0ZW1lbnQsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5TVEFURU1FTlQpLCBsb2NhbEVycm9ycyk7XG4gIH1cblxuICBpZiAoY29udGV4dC5pbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoeGFwaVZhbGlkYXRpb25VdGlscy5pc0dyb3VwKGNvbnRleHQuaW5zdHJ1Y3Rvciwgb2JqZWN0VHlwZXMuR1JPVVApKSB7XG4gICAgICB2YWxpZGF0ZUdyb3VwKGNvbnRleHQuaW5zdHJ1Y3RvciwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLklOU1RSVUNUT1IpLCBsb2NhbEVycm9ycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlQWdlbnQoY29udGV4dC5pbnN0cnVjdG9yLCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuSU5TVFJVQ1RPUiksIGxvY2FsRXJyb3JzKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZUV4dGVuc2lvbnMoY29udGV4dC5leHRlbnNpb25zLCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuRVhURU5TSU9OUyksIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVBYnNlbmNlT2ZOb25XaGl0ZWxpc3RlZFByb3BlcnRpZXMoY29udGV4dCwgeGFwaVdoaXRlTGlzdFByb3BlcnRpZXMuRVhURU5TSU9OUyxsb2NhbFRyYWNlLGxvY2FsRXJyb3JzKTtcblxuICByZXR1cm4gbG9jYWxFcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdHJhY2UsIGVycm9ycywgaXNXaXRoaW5TdWJTdGF0ZW1lbnQpIHtcbiAgdmFyIGxvY2FsRXJyb3JzLCBsb2NhbFRyYWNlLCBvYmplY3RUeXBlO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLk9CSkVDVDtcblxuICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UpLFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuT0JKRUNUX01VU1RfQkVfREVGSU5FRCxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG5cbiAgaWYgKCF4YXBpVmFsaWRhdGlvblV0aWxzLmlzTm9uTnVsbE1hcE9iamVjdChvYmplY3QpKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLk9CSkVDVF9NVVNUX0JFX05PTl9OVUxMX01BUF9PQkpFQ1QsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcblxuICAgIHJldHVybiBsb2NhbEVycm9ycztcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcGVydHlJc1N0cmluZyhvYmplY3QsIHByb3BlcnRpZXMuT0JKRUNUX1RZUEUsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzLCAvKmlzUmVxdWlyZWQqL3RydWUsIHhhcGlFcnJvckxldmVscy5TSE9VTERfVklPTEFUSU9OKTtcblxuICBvYmplY3RUeXBlID0gb2JqZWN0Lm9iamVjdFR5cGUgfHwgb2JqZWN0VHlwZXMuQUNUSVZJVFk7XG5cbiAgc3dpdGNoIChvYmplY3RUeXBlKSB7XG4gICAgY2FzZSBvYmplY3RUeXBlcy5BQ1RJVklUWTpcbiAgICAgIHZhbGlkYXRlQWN0aXZpdHkob2JqZWN0LCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG9iamVjdFR5cGVzLkFHRU5UOlxuICAgICAgdmFsaWRhdGVBZ2VudChvYmplY3QsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugb2JqZWN0VHlwZXMuR1JPVVA6XG4gICAgICB2YWxpZGF0ZUdyb3VwKG9iamVjdCwgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvYmplY3RUeXBlcy5TVEFURU1FTlRfUkVGOlxuICAgICAgdmFsaWRhdGVTdGF0ZW1lbnRSZWYob2JqZWN0LCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG9iamVjdFR5cGVzLlNVQl9TVEFURU1FTlQ6XG4gICAgICBpZiAoaXNXaXRoaW5TdWJTdGF0ZW1lbnQpIHtcbiAgICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5PQkpFQ1RfVFlQRSksXG4gICAgICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuU1VCX1NUQVRFTUVOVF9NVVNUX05PVF9DT05UQUlOX1NVQl9TVEFURU1FTlQsXG4gICAgICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGUob2JqZWN0LCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycywgIC8qaXNTdWJTdGF0ZW1lbnQqL3RydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvY2FsRXJyb3JzLnB1c2goe1xuICAgICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLk9CSkVDVF9UWVBFKSxcbiAgICAgICAgbWVzc2FnZTogYCR7eGFwaVZhbGlkYXRpb25FcnJvcnMuT0JKRUNUX1RZUEVfTVVTVF9CRV9WQUxJRF9PUFRJT059ICR7eEFwaVZhbGlkT2JqZWN0VHlwZXMudG9TdHJpbmcoKX1gLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxvY2FsRXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZShzdGF0ZW1lbnQsIHRyYWNlLCBlcnJvcnMsIGlzU3ViU3RhdGVtZW50KSB7XG4gIHZhciBsb2NhbEVycm9ycywgbG9jYWxUcmFjZSwgc3RhdGVtZW50T2JqZWN0T2JqZWN0VHlwZSwgd2hpdGVsaXN0ZWRQcm9wZXJ0aWVzO1xuXG4gIGxvY2FsRXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICBsb2NhbFRyYWNlICA9IHRyYWNlICB8fCBwcm9wZXJ0aWVzLlNUQVRFTUVOVDtcblxuICB3aGl0ZWxpc3RlZFByb3BlcnRpZXMgPSB4YXBpV2hpdGVMaXN0UHJvcGVydGllcy5TVEFURU1FTlQ7XG5cbiAgaWYgKCF4YXBpVmFsaWRhdGlvblV0aWxzLmlzTm9uTnVsbE1hcE9iamVjdChzdGF0ZW1lbnQpKSB7XG4gICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICB0cmFjZTogICB4YXBpVmFsaWRhdGlvblV0aWxzLmxvY2FsVHJhY2VUb1N0cmluZyhsb2NhbFRyYWNlKSxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlNUQVRFTUVOVF9SRUZfTVVTVF9OT1RfQkVfTlVMTF9NQVBfT0JKRUNUUyxcbiAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGxvY2FsRXJyb3JzO1xuICB9XG5cbiAgaWYgKCFpc1N1YlN0YXRlbWVudCkge1xuICAgIGlmIChzdGF0ZW1lbnQuaWQgPT09IG51bGwgfHwgc3RhdGVtZW50LmlkID09PSB1bmRlZmluZWQgfHwgIXhhcGlWYWxpZGF0aW9uVXRpbHMuaXNTdHJpbmcoc3RhdGVtZW50LmlkKSkge1xuICAgICAgbG9jYWxFcnJvcnMucHVzaCh7XG4gICAgICAgIHRyYWNlOiAgIHhhcGlWYWxpZGF0aW9uVXRpbHMubG9jYWxUcmFjZVRvU3RyaW5nKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuSUQpLFxuICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5JRFNfU0hPVUxEX0JFX0dFTkVSQVRFRF9CWV9MUlMsXG4gICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5TSE9VTERfVklPTEFUSU9OXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCF4YXBpVmFsaWRhdGlvblJlZ2V4LlVVSUQudGVzdChzdGF0ZW1lbnQuaWQpKSB7XG4gICAgICBsb2NhbEVycm9ycy5wdXNoKHtcbiAgICAgICAgdHJhY2U6ICAgeGFwaVZhbGlkYXRpb25VdGlscy5sb2NhbFRyYWNlVG9TdHJpbmcobG9jYWxUcmFjZSwgcHJvcGVydGllcy5JRCksXG4gICAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLklEX01VU1RfQkVfVkFMSUQsXG4gICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaXRlbGlzdGVkUHJvcGVydGllcyA9IHhhcGlXaGl0ZUxpc3RQcm9wZXJ0aWVzLlNVQl9TVEFURU1FTlQ7XG4gIH1cblxuICB2YWxpZGF0ZUFjdG9yKHN0YXRlbWVudC5hY3RvciwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkFDVE9SKSwgbG9jYWxFcnJvcnMpO1xuICB2YWxpZGF0ZVZlcmIoc3RhdGVtZW50LnZlcmIsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5WRVJCKSwgbG9jYWxFcnJvcnMpO1xuICB2YWxpZGF0ZU9iamVjdChzdGF0ZW1lbnQub2JqZWN0LCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuT0JKRUNUKSwgbG9jYWxFcnJvcnMsIGlzU3ViU3RhdGVtZW50KTtcbiAgdmFsaWRhdGVSZXN1bHQoc3RhdGVtZW50LnJlc3VsdCwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLlJFU1VMVCksIGxvY2FsRXJyb3JzKTtcblxuICBzdGF0ZW1lbnRPYmplY3RPYmplY3RUeXBlID0gc3RhdGVtZW50Lm9iamVjdCAmJiBzdGF0ZW1lbnQub2JqZWN0Lm9iamVjdFR5cGUgPyBzdGF0ZW1lbnQub2JqZWN0Lm9iamVjdFR5cGUgOiBvYmplY3RUeXBlcy5BQ1RJVklUWTtcblxuICB2YWxpZGF0ZUNvbnRleHQoc3RhdGVtZW50LmNvbnRleHQsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5DT05URVhUKSwgbG9jYWxFcnJvcnMsIHN0YXRlbWVudE9iamVjdE9iamVjdFR5cGUpO1xuICB2YWxpZGF0ZVByb3BlcnR5SXNJU084NjAxU3RyaW5nKHN0YXRlbWVudCwgcHJvcGVydGllcy5USU1FU1RBTVAsIGxvY2FsVHJhY2UsIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVQcm9wZXJ0eUlzSVNPODYwMVN0cmluZyhzdGF0ZW1lbnQsIHByb3BlcnRpZXMuU1RPUkVELCBsb2NhbFRyYWNlLCBsb2NhbEVycm9ycyk7XG5cbiAgdmFsaWRhdGVBdXRob3JpdHkoc3RhdGVtZW50LmF1dGhvcml0eSwgeGFwaVZhbGlkYXRpb25VdGlscy5hZGRQcm9wVG9UcmFjZShsb2NhbFRyYWNlLCBwcm9wZXJ0aWVzLkFVVEhPUklUWSksIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVWZXJzaW9uKHN0YXRlbWVudC52ZXJzaW9uLCB4YXBpVmFsaWRhdGlvblV0aWxzLmFkZFByb3BUb1RyYWNlKGxvY2FsVHJhY2UsIHByb3BlcnRpZXMuVkVSU0lPTiksIGxvY2FsRXJyb3JzKTtcbiAgdmFsaWRhdGVBdHRhY2htZW50cyhzdGF0ZW1lbnQuYXR0YWNobWVudHMsIHhhcGlWYWxpZGF0aW9uVXRpbHMuYWRkUHJvcFRvVHJhY2UobG9jYWxUcmFjZSwgcHJvcGVydGllcy5BVFRBQ0hNRU5UUyksIGxvY2FsRXJyb3JzKTtcblxuICB2YWxpZGF0ZUFic2VuY2VPZk5vbldoaXRlbGlzdGVkUHJvcGVydGllcyhzdGF0ZW1lbnQsIHdoaXRlbGlzdGVkUHJvcGVydGllcywgbG9jYWxUcmFjZSwgbG9jYWxFcnJvcnMpO1xuXG4gIHJldHVybiBsb2NhbEVycm9ycztcbn1cblxuZnVuY3Rpb24gbWFrZVN0YXRlbWVudFJlcG9ydChzdGF0ZW1lbnQpIHtcbiAgdmFyIGxvY2FsRXJyb3JzO1xuXG4gIGxvY2FsRXJyb3JzID0gW107XG4gIHZhbGlkYXRlKHN0YXRlbWVudCwgcHJvcGVydGllcy5TVEFURU1FTlQsIGxvY2FsRXJyb3JzLCAgLyppc1JlcXVpcmVkKi9mYWxzZSk7XG5cbiAgcmV0dXJuIG1ha2VWMVJlcG9ydChzdGF0ZW1lbnQsIGxvY2FsRXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBbWJpZ3VvdXNUeXBlU3RhdGVtZW50KHN0YXRlbWVudCkge1xuICB2YXIgc3RhdGVtZW50T2JqZWN0O1xuXG4gIGlmIChzdGF0ZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBtYWtlVjFTaW5nbGVFcnJvclJlcG9ydCgvKmluc3RhbmNlKi9udWxsLCB7XG4gICAgICB0cmFjZTogICBwcm9wZXJ0aWVzLlNUQVRFTUVOVCxcbiAgICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlNUQVRFTUVOVF9BUkdVTUVOVF9NVVNUX0JFX1BST1ZJREVELFxuICAgICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gICAgfSk7XG4gIH1cblxuICBpZiAoc3RhdGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG1ha2VWMVNpbmdsZUVycm9yUmVwb3J0KC8qaW5zdGFuY2UqL251bGwsIHtcbiAgICAgIHRyYWNlOiAgIHByb3BlcnRpZXMuU1RBVEVNRU5ULFxuICAgICAgbWVzc2FnZTogeGFwaVZhbGlkYXRpb25FcnJvcnMuU1RBVEVNRU5UX01VU1RfTk9UX0JFX05VTEwsXG4gICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh4YXBpVmFsaWRhdGlvblV0aWxzLmlzU3RyaW5nKHN0YXRlbWVudCkpIHtcbiAgICB0cnkge1xuICAgICAgc3RhdGVtZW50T2JqZWN0ID0gSlNPTi5wYXJzZShzdGF0ZW1lbnQpO1xuICAgICAgaWYgKHN0YXRlbWVudE9iamVjdCA9PT0gbnVsbCB8fCAheGFwaVZhbGlkYXRpb25VdGlscy5pc09iamVjdChzdGF0ZW1lbnRPYmplY3QpIHx8IHhhcGlWYWxpZGF0aW9uVXRpbHMuaXNBcnJheShzdGF0ZW1lbnRPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBtYWtlVjFTaW5nbGVFcnJvclJlcG9ydChzdGF0ZW1lbnRPYmplY3QsIHtcbiAgICAgICAgICB0cmFjZTogICBwcm9wZXJ0aWVzLlNUQVRFTUVOVCxcbiAgICAgICAgICBtZXNzYWdlOiB4YXBpVmFsaWRhdGlvbkVycm9ycy5TVEFURU1FTlRfTVVTVF9CRV9QQVJTRURfQ09SUkVDVExZLFxuICAgICAgICAgIGxldmVsOiAgIHhhcGlFcnJvckxldmVscy5NVVNUX1ZJT0xBVElPTlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbWFrZVYxU2luZ2xlRXJyb3JSZXBvcnQoc3RhdGVtZW50T2JqZWN0LCB7XG4gICAgICAgIHRyYWNlOiAgIHByb3BlcnRpZXMuU1RBVEVNRU5ULFxuICAgICAgICBtZXNzYWdlOiBgJHt4YXBpVmFsaWRhdGlvbkVycm9ycy5JTlZBTElEX0pTT059OiAke2UubWVzc2FnZX1gLFxuICAgICAgICBsZXZlbDogICB4YXBpRXJyb3JMZXZlbHMuTVVTVF9WSU9MQVRJT05cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU3RhdGVtZW50UmVwb3J0KHN0YXRlbWVudE9iamVjdCk7XG4gIH1cblxuICBpZiAoeGFwaVZhbGlkYXRpb25VdGlscy5pc09iamVjdChzdGF0ZW1lbnQpICYmICF4YXBpVmFsaWRhdGlvblV0aWxzLmlzQXJyYXkoc3RhdGVtZW50KSkge1xuICAgIHJldHVybiBtYWtlU3RhdGVtZW50UmVwb3J0KHN0YXRlbWVudCk7XG4gIH1cblxuICByZXR1cm4gbWFrZVYxU2luZ2xlRXJyb3JSZXBvcnQoLyppbnN0YW5jZSovbnVsbCwge1xuICAgIHRyYWNlOiAgIHByb3BlcnRpZXMuU1RBVEVNRU5ULFxuICAgIG1lc3NhZ2U6IHhhcGlWYWxpZGF0aW9uRXJyb3JzLlNUQVRFTUVOVF9BUkdVTUVOVF9JU19OT1RfVkFMSUQsXG4gICAgbGV2ZWw6ICAgeGFwaUVycm9yTGV2ZWxzLk1VU1RfVklPTEFUSU9OXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkYXRlSW5jbHVkZXNab25lSW5mb3JtYXRpb24obWF0Y2hlZCkge1xuICByZXR1cm4gbWF0Y2hlZFtkYXRlRm9ybWF0UmVnZXhQb3NpdGlvbnMuWk9ORV0gfHxcbiAgICAgICAgICAobWF0Y2hlZFtkYXRlRm9ybWF0UmVnZXhQb3NpdGlvbnMuUkVMQVRJVkVfVElNRV0gJiYgbWF0Y2hlZFtkYXRlRm9ybWF0UmVnZXhQb3NpdGlvbnMuVElNRV9aT05FX0hPVVJdKTtcbn1cblxuZXhwb3J0IHZhciB2YWxpZGF0ZVN0YXRlbWVudCA9IHZhbGlkYXRlQW1iaWd1b3VzVHlwZVN0YXRlbWVudDtcbiIsImltcG9ydCB7X30gZnJvbSAndW5kZXJzY29yZSc7XG5pbXBvcnQge2V4cGVjdH0gZnJvbSAnY2hhaSc7XG5pbXBvcnQge3ZhbGlkYXRlU3RhdGVtZW50fSBmcm9tICcuLi9zcmMveGFwaVZhbGlkYXRvcic7XG5cbnZhciB4YXBpVmFsaWRhdG9yO1xuXG54YXBpVmFsaWRhdG9yID0ge3ZhbGlkYXRlU3RhdGVtZW50fTtcblxuZGVzY3JpYmUoXCJ4YXBpVmFsaWRhdG9yXCIsIGZ1bmN0aW9uKCkge1xuICBkZXNjcmliZShcIiN2YWxpZGF0ZVN0YXRlbWVudFwiLCBmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlcG9ydCwgcHJlZml4LCB0YXJnZXRMZXZlbCkge1xuICAgICAgaWYgKHJlcG9ydCA9PT0gbnVsbCB8fCByZXBvcnQgPT09IHVuZGVmaW5lZCB8fCByZXBvcnQuZXJyb3JzID09PSBudWxsIHx8IHJlcG9ydC5lcnJvcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaGFzVGFyZ2V0TGV2ZWwgPSB0YXJnZXRMZXZlbCAhPT0gbnVsbCAmJiB0YXJnZXRMZXZlbCAhPT0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIF8uYW55KHJlcG9ydC5lcnJvcnMsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICB2YXIgZm91bmRQcmVmaXggPSBlcnIudHJhY2UuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuICAgICAgICByZXR1cm4gaGFzVGFyZ2V0TGV2ZWwgPyB0YXJnZXRMZXZlbCA9PT0gZXJyLmxldmVsICYmIGZvdW5kUHJlZml4IDogZm91bmRQcmVmaXg7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXNjcmliZShcIndoZW4gcGFzc2VkIG5vIGFyZ3VtZW50c1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KFwicmV0dXJucyBub24tbnVsbCByZXBvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLm5vdC5udWxsO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50by5iZS5hKFwiT2JqZWN0XCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiaW5jbHVkZXMgb25lIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudCgpO1xuICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycztcbiAgICAgICAgZXhwZWN0KGVycm9ycykudG8uYmUuaW5zdGFuY2VPZihBcnJheSk7XG4gICAgICAgIGV4cGVjdChlcnJvcnMpLnRvLmhhdmUubGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QoZXJyb3JzWzBdKS50by5oYXZlLnByb3BlcnR5KFwibWVzc2FnZVwiKVxuICAgICAgICAgIC50aGF0LmlzLmEoJ3N0cmluZycpXG4gICAgICAgICAgLnRoYXQuZXF1YWxzKCdObyBzdGF0ZW1lbnQgYXJndW1lbnQgcHJvdmlkZWQuJyk7XG4gICAgICAgIGV4cGVjdChlcnJvcnNbMF0pLnRvLmhhdmUucHJvcGVydHkoXCJsZXZlbFwiKVxuICAgICAgICAgIC50aGF0LmVxdWFscyhcIk1VU1RfVklPTEFUSU9OXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiaGFzIGEgbnVsbCBpbnN0YW5jZSBwcm9wZXJ0eSBpbiB0aGUgcmVwb3J0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoeGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudCgpKVxuICAgICAgICAgIC50by5oYXZlLnByb3BlcnR5KFwiaW5zdGFuY2VcIilcbiAgICAgICAgICAgIC50aGF0LmlzLm51bGw7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBwYXNzZWQgYSBudWxsIGFyZ3VtZW50XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoXCJyZXR1cm5zIG5vbi1udWxsIHJlcG9ydFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQobnVsbCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLm5vdC5udWxsO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50by5iZS5hKFwiT2JqZWN0XCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50by5oYXZlLnByb3BlcnR5KFwiZXJyb3JzXCIpXG4gICAgICAgICAgLnRoYXQuaXMuYShcIkFycmF5XCIpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50by5oYXZlLnByb3BlcnR5KFwiaW5zdGFuY2VcIik7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJpbmNsdWRlcyBvbmUgZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KG51bGwpO1xuICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycztcbiAgICAgICAgZXhwZWN0KGVycm9ycykudG8uYmUuaW5zdGFuY2VPZihBcnJheSk7XG4gICAgICAgIGV4cGVjdChlcnJvcnMpLnRvLmhhdmUubGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QoZXJyb3JzWzBdKS50by5oYXZlLnByb3BlcnR5KFwibWVzc2FnZVwiKVxuICAgICAgICAgIC50aGF0LmlzLmEoJ3N0cmluZycpXG4gICAgICAgICAgLnRoYXQuZXF1YWxzKCdOdWxsIHN0YXRlbWVudCBhcmd1bWVudCBwcm92aWRlZC4nKTtcbiAgICAgICAgZXhwZWN0KGVycm9yc1swXSkudG8uaGF2ZS5wcm9wZXJ0eShcImxldmVsXCIpXG4gICAgICAgICAgLnRoYXQuZXF1YWxzKFwiTVVTVF9WSU9MQVRJT05cIik7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJoYXMgYSBudWxsIGluc3RhbmNlIHByb3BlcnR5IGluIHRoZSByZXBvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdCh4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KG51bGwpKVxuICAgICAgICAgIC50by5oYXZlLnByb3BlcnR5KFwiaW5zdGFuY2VcIilcbiAgICAgICAgICAgIC50aGF0LmlzLm51bGw7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBwYXNzZWQgYSBqc29uIHN0cmluZyBhcmd1bWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaW5pbWFsSnNvblN0cmluZyA9IFwie1xcXCJpZFxcXCI6XFxcIndoYXRldmVyXFxcIn1cIjtcbiAgICAgIGl0KFwicmV0dXJucyBub24tbnVsbCByZXBvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KG1pbmltYWxKc29uU3RyaW5nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUubm90Lm51bGw7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLmEoXCJPYmplY3RcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJlcnJvcnNcIilcbiAgICAgICAgICAudGhhdC5pcy5hKFwiQXJyYXlcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJpbnN0YW5jZVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImhhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNlcmlhbGl6ZWQgSlNPTiBpbiB0aGUgcmVwb3J0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChtaW5pbWFsSnNvblN0cmluZyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJpbnN0YW5jZVwiKVxuICAgICAgICAgIC50aGF0LmlzLmFuKFwiT2JqZWN0XCIpXG4gICAgICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoe1wiaWRcIjpcIndoYXRldmVyXCJ9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIHBhc3NlZCBhIGpzb24gc3RyaW5nIGFyZ3VtZW50IGVuY29kaW5nIG51bGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWluaW1hbEpzb25TdHJpbmcgPSBcIm51bGxcIjtcbiAgICAgIGl0KFwicmV0dXJucyBub24tbnVsbCByZXBvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KG1pbmltYWxKc29uU3RyaW5nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUubm90Lm51bGw7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLmEoXCJPYmplY3RcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJlcnJvcnNcIilcbiAgICAgICAgICAudGhhdC5pcy5hKFwiQXJyYXlcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJpbnN0YW5jZVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImluY2x1ZGVzIG9uZSBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQobWluaW1hbEpzb25TdHJpbmcpO1xuICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycztcbiAgICAgICAgZXhwZWN0KGVycm9ycykudG8uYmUuaW5zdGFuY2VPZihBcnJheSk7XG4gICAgICAgIGV4cGVjdChlcnJvcnMpLnRvLmhhdmUubGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QoZXJyb3JzWzBdKS50by5oYXZlLnByb3BlcnR5KFwibWVzc2FnZVwiKTtcbiAgICAgICAgZXhwZWN0KGVycm9yc1swXSkudG8uaGF2ZS5wcm9wZXJ0eShcImxldmVsXCIpXG4gICAgICAgICAgLnRoYXQuZXF1YWxzKFwiTVVTVF9WSU9MQVRJT05cIik7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJoYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgd2l0aCBudWxsIHZhbHVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChtaW5pbWFsSnNvblN0cmluZyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJpbnN0YW5jZVwiKVxuICAgICAgICAgIC50aGF0LmlzLm51bGw7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBwYXNzZWQgYW4gaW52YWxpZCBqc29uIHN0cmluZyBhcmd1bWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaW5pbWFsSnNvblN0cmluZyA9IFwiZGVycFwiO1xuICAgICAgaXQoXCJyZXR1cm5zIG5vbi1udWxsIHJlcG9ydFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQobWluaW1hbEpzb25TdHJpbmcpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50by5iZS5ub3QubnVsbDtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUuYShcIk9iamVjdFwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uaGF2ZS5wcm9wZXJ0eShcImVycm9yc1wiKVxuICAgICAgICAgIC50aGF0LmlzLmEoXCJBcnJheVwiKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uaGF2ZS5wcm9wZXJ0eShcImluc3RhbmNlXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiaW5jbHVkZXMgb25lIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChtaW5pbWFsSnNvblN0cmluZyk7XG4gICAgICAgIHZhciBlcnJvcnMgPSByZXN1bHQuZXJyb3JzO1xuICAgICAgICBleHBlY3QoZXJyb3JzKS50by5iZS5pbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgICAgZXhwZWN0KGVycm9ycykudG8uaGF2ZS5sZW5ndGgoMSk7XG4gICAgICAgIGV4cGVjdChlcnJvcnNbMF0pLnRvLmhhdmUucHJvcGVydHkoXCJtZXNzYWdlXCIpO1xuICAgICAgICBleHBlY3QoZXJyb3JzWzBdKS50by5oYXZlLnByb3BlcnR5KFwibGV2ZWxcIilcbiAgICAgICAgICAudGhhdC5lcXVhbHMoXCJNVVNUX1ZJT0xBVElPTlwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImhhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSB3aXRoIG51bGwgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KG1pbmltYWxKc29uU3RyaW5nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uaGF2ZS5wcm9wZXJ0eShcImluc3RhbmNlXCIpXG4gICAgICAgICAgLnRoYXQuaXMubnVsbDtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIHBhc3NlZCBhIHN0YXRlbWVudCBvYmplY3RcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fTtcbiAgICAgIGl0KFwicmV0dXJucyBub24tbnVsbCByZXBvcnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUubm90Lm51bGw7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLmEoXCJPYmplY3RcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJlcnJvcnNcIilcbiAgICAgICAgICAudGhhdC5pcy5hKFwiQXJyYXlcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmhhdmUucHJvcGVydHkoXCJpbnN0YW5jZVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImhhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSB0aGF0IG1hdGNoZXMgdGhlIGlucHV0IG9iamVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50by5oYXZlLnByb3BlcnR5KFwiaW5zdGFuY2VcIilcbiAgICAgICAgICAudGhhdC5kZWVwLmVxdWFscyhpbnB1dFN0YXRlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBnaXZlbiBhIG51bGwgaWQgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBudWxsICxcbiAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fTtcbiAgICAgIGl0KFwiaGFzIGFuIGVycm9yIGFib3V0IHRoZSBpZCBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0LCBcInN0YXRlbWVudC5pZFwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIGdpdmVuIGFuIGludmFsaWQgVVVJRCBpZCBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiYWJjMTIzXCIsXG4gICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX07XG4gICAgICBpdChcImhhcyBhbiBlcnJvciBhYm91dCB0aGUgaWQgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdCwgXCJzdGF0ZW1lbnQuaWRcIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBnaXZlbiBhIHZhbGlkIFVVSUQgaWQgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiLFxuICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgaXQoXCJoYXMgYW4gZXJyb3IgYWJvdXQgdGhlIGlkIHByb3BlcnR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHQsIFwic3RhdGVtZW50LmlkXCIpKS50by5iZS5mYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIGdpdmVuIGEgbnVsbCBhY3RvciBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDogbnVsbCxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX07XG4gICAgICBpdChcImhhcyBhbiBlcnJvciBhYm91dCB0aGUgYWN0b3IgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdCwgXCJzdGF0ZW1lbnQuYWN0b3JcIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBnaXZlbiBhbiBlbXB0eSBub24tbnVsbCBhY3RvciBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge30sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgaXQoXCJoYXMgYW4gZXJyb3IgYWJvdXQgdGhlIGFjdG9yIHByb3BlcnR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHQsIFwic3RhdGVtZW50LmFjdG9yXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gZ2l2ZW4gYW4gb3RoZXJ3aXNlIHZhbGlkIGFjdG9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzpncm91cEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX07XG4gICAgICBpdChcInRoZSBuYW1lIHByb3BlcnR5IGlzIG9wdGlvbmFsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwidGhlIG5hbWUgcHJvcGVydHkgcHJvZHVjZXMgbm8gZXJyb3JzIHdoZW4gYSBzaW1wbGUgc3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dFN0YXRlbWVudC5hY3Rvci5uYW1lID0gXCJoZWxsb1wiO1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwidGhlIG5hbWUgcHJvcGVydHkgcHJvZHVjZXMgbm8gZXJyb3JzIHdoZW4gYSBzaW1wbGUgc3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dFN0YXRlbWVudC5hY3Rvci5uYW1lID0gMS4yMztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0LCBcInN0YXRlbWVudC5hY3Rvci5uYW1lXCIpKS50by5iZS50cnVlO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIGdpdmVuIGFuIGFjdG9yIHdpdGggYW4gb2JqZWN0VHlwZSBvZiAnR3JvdXAnXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1vcmVWYWxpZFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge29iamVjdFR5cGU6XCJHcm91cFwiLCBtZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fTtcbiAgICAgIGl0KFwidGhlIG1lbWJlciBwcm9wZXJ0eSBoYXMgbm8gZXJyb3JzIGFib3V0IGl0IHdoZW4gcHJlc2VudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQobW9yZVZhbGlkU3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdCwgXCJzdGF0ZW1lbnQuYWN0b3IubWVtYmVyXCIpKS50by5iZS5mYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkgaXMgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBpZiB0aGUgYWN0b3IgaXMgdW5pZGVudGlmaWVkLCBhbmQgcHJvZHVjZXMgYW4gZXJyb3Igd2hlbiBhYnNlbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dEludmFsaWRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHtvYmplY3RUeXBlOlwiR3JvdXBcIn0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dEludmFsaWRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0LCBcInN0YXRlbWVudC5hY3Rvci5tZW1iZXJcIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJ0aGUgbWVtYmVyIHByb3BlcnR5IGlzIG5vdCByZXF1aXJlZCB0byBiZSBwcmVzZW50IGlmIHRoZSBhY3RvciBpcyBpZGVudGlmaWVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudCh7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHtvYmplY3RUeXBlOlwiR3JvdXBcIiwgbWJveDpcIm1haWx0bzpncm91cEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX0pO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0LCBcInN0YXRlbWVudC5hY3Rvci5tZW1iZXJcIikpLnRvLmJlLmZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwidGhlIG1lbWJlciBwcm9wZXJ0eSBpcyBhbGxvd2VkIHRvIGJlIHByZXNlbnQgaWYgdGhlIGFjdG9yIGlzIGlkZW50aWZpZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIsXG4gICAgICAgICAgYWN0b3IgOiB7b2JqZWN0VHlwZTpcIkdyb3VwXCIsIG1ib3g6XCJtYWlsdG86Z3JvdXBAZXhhbXBsZS5jb21cIiwgbWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX0pO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0LCBcInN0YXRlbWVudC5hY3Rvci5tZW1iZXJcIikpLnRvLmJlLmZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gZ2l2ZW4gYW4gYWN0b3Igd2l0aCBhIG1lbWJlcnMgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fTtcbiAgICAgIGl0KFwidGhlIG1lbWJlciBwcm9wZXJ0eSBoYXMgbm8gZXJyb3JzIGFib3V0IGl0IHdoZW4gcHJlc2VudCBidXQgZW1wdHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGV4cGVjdCh4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KS5lcnJvcnMpLnRvLmJlLmVtcHR5O1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwidGhlIG1lbWJlciBwcm9wZXJ0eSBoYXMgbm8gZXJyb3JzIHdoZW4gcG9wdWxhdGVkIHdpdGggYSBzaW1wbGUgYWdlbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0U3RhdGVtZW50LmFjdG9yLm1lbWJlciA9IFt7bWJveDpcIm1haWx0bzpncm91cEBleGFtcGxlLmNvbVwifV07XG4gICAgICAgIGV4cGVjdCh4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KS5lcnJvcnMpLnRvLmJlLmVtcHR5O1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwidGhlIG1lbWJlciBwcm9wZXJ0eSByZXBvcnRzIGFuIGVycm9yIHdoZW4gcG9wdWxhdGVkIHdpdGggYSBHcm91cCBvYmplY3QgdmlhIG9iamVjdFR5cGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0U3RhdGVtZW50LmFjdG9yLm1lbWJlciA9IFt7bWJveDpcIm1haWx0bzpncm91cEBleGFtcGxlLmNvbVwiLCBvYmplY3RUeXBlOlwiR3JvdXBcIn1dO1xuICAgICAgICBleHBlY3QoeGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCkuZXJyb3JzKVxuICAgICAgICAgIC50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwidGhlIG1lbWJlciBwcm9wZXJ0eSdzIGFnZW50IHJlcG9ydHMgYW4gZXJyb3Igd2hlbiBnaXZlbiBhbiBhY2NvdW50IG1pc3NpbmcgaXRzIGhvbWVQYWdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dFN0YXRlbWVudC5hY3Rvci5tZW1iZXIgPSBbe2FjY291bnQ6e25hbWU6XCJib2JcIn19XTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpLCBcInN0YXRlbWVudC5hY3Rvci5tZW1iZXJbMF0uYWNjb3VudC5ob21lUGFnZVwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkncyBhZ2VudCByZXBvcnRzIGFuIGVycm9yIHdoZW4gZ2l2ZW4gYW4gYWNjb3VudCBtaXNzaW5nIGl0cyBuYW1lXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dFN0YXRlbWVudC5hY3Rvci5tZW1iZXIgPSBbe2FjY291bnQ6e2hvbWVQYWdlOlwiaHR0cDovL2V4YW1wbGUuY29tXCJ9fV07XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeCh4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KSwgXCJzdGF0ZW1lbnQuYWN0b3IubWVtYmVyWzBdLmFjY291bnQubmFtZVwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkncyBhZ2VudCByZXBvcnRzIGFuIGVycm9yIHdoZW4gZ2l2ZW4gYW4gYWNjb3VudCB3aXRoIGFuIGFsbC1sb3dlcmNhc2UgaG9tZXBhZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0U3RhdGVtZW50LmFjdG9yLm1lbWJlciA9IFt7YWNjb3VudDp7aG9tZXBhZ2U6XCJodHRwOi8vZXhhbXBsZS5jb21cIiwgbmFtZTpcImJvYlwifX1dO1xuICAgICAgICB2YXIgcmVwb3J0ID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXBvcnQsIFwic3RhdGVtZW50LmFjdG9yLm1lbWJlclswXS5hY2NvdW50LmhvbWVwYWdlXCIpKS50by5iZS50cnVlO1xuICAgICAgICBleHBlY3QocmVwb3J0LmVycm9ycylcbiAgICAgICAgICAudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkncyBhZ2VudCByZXBvcnRzIG5vIGVycm9yIHdoZW4gZ2l2ZW4gYSBmdWxsIGFjY291bnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0U3RhdGVtZW50LmFjdG9yLm1lbWJlciA9IFt7YWNjb3VudDp7aG9tZVBhZ2U6XCJodHRwOi8vZXhhbXBsZS5jb21cIiwgbmFtZTogXCJib2JcIn19XTtcbiAgICAgICAgZXhwZWN0KHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpLmVycm9ycylcbiAgICAgICAgICAudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkncyBhZ2VudCByZXBvcnRzIG5vIGVycm9yIHdoZW4gZ2l2ZW4gYSB2YWxpZCBtYm94XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dFN0YXRlbWVudC5hY3Rvci5tZW1iZXIgPSBbe21ib3g6XCJtYWlsdG86Ym9iQGV4YW1wbGUuY29tXCJ9XTtcbiAgICAgICAgZXhwZWN0KHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpLmVycm9ycylcbiAgICAgICAgICAudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkncyBhZ2VudCByZXBvcnRzIGFuIGVycm9yIHdoZW4gZ2l2ZW4gYW4gaW52YWxpZCBtYm94XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnB1dFN0YXRlbWVudC5hY3Rvci5tZW1iZXIgPSBbe21ib3g6XCJTT01FVEhJTkdXUk9ORzpib2JAZXhhbXBsZS5jb21cIn1dO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYWN0b3IubWVtYmVyWzBdLm1ib3hcIikpLnRvLmJlLnRydWU7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcInRoZSBtZW1iZXIgcHJvcGVydHkgcmVwb3J0cyBhbiBlcnJvciB3aGVuIHBvcHVsYXRlZCB3aXRoIGEgR3JvdXAgb2JqZWN0IHZpYSBtZW1iZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlucHV0U3RhdGVtZW50LmFjdG9yLm1lbWJlciA9IFt7bWJveDpcIm1haWx0bzpncm91cEBleGFtcGxlLmNvbVwiLCBtZW1iZXI6W119XTtcbiAgICAgICAgZXhwZWN0KHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpLmVycm9ycylcbiAgICAgICAgICAudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gZ2l2ZW4gYSBzdGF0ZW1lbnQgd2l0aG91dCBhIHZlcmIgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC52ZXJiXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gZ2l2ZW4gYSB2ZXJiIHdpdGhvdXQgYW4gaWQgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC52ZXJiLmlkXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBnaXZlbiBhIHZlcmIgd2l0aCBhIG5vbi1zdHJpbmcgaWQgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6MTIuMzQsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnZlcmIuaWRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIGdpdmVuIGEgdmVyYiB3aXRoIGEgcmVsYXRpdmUgVVJJIGlkIHByb3BlcnR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoXCJyZXBvcnRzIGFuIFNIT1VMRF9WSU9MQVRJT04gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJmcmFnbWVudFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC52ZXJiLmlkXCIsIFwiU0hPVUxEX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIGdpdmVuIGEgdmVyYiB3aXRob3V0IGEgZGlzcGxheSBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KFwicmVwb3J0cyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCJ9LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQudmVyYi5kaXNwbGF5XCIsIFwiU0hPVUxEX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIGdpdmVuIGEgdmVyYiB3aXRoIGFuIGVtcHR5IGRpc3BsYXkgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgbm8gZXJyb3JzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHt9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX07XG4gICAgICAgIGV4cGVjdCh4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KS5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBnaXZlbiBhIHZlcmIuZGlzcGxheSB3aXRoIFJGQyA1NjQ2IGtleSBhbmQgc3RyaW5nIHZhbHVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoXCJyZXBvcnRzIG5vIGVycm9yc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIGRpc3BsYXkgOiB7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19O1xuICAgICAgICBleHBlY3QoeGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCkuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gZ2l2ZW4gYSB2ZXJiLmRpc3BsYXkgd2l0aCBSRkMgNTY0NiBrZXkgYW5kIG5vbi1zdHJpbmcgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjogMS4yM319LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQudmVyYi5kaXNwbGF5W1xcXCJlbi1VU1xcXCJdXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiBnaXZlbiBhIHZlcmIuZGlzcGxheSB3aXRoIGludmFsaWQga2V5IGFuZCBzdHJpbmcgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiMTIzdG90YWxseVdyb25nXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnZlcmIuZGlzcGxheS4xMjN0b3RhbGx5V3JvbmdcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIHRoZSBvYmplY3QgcHJvcGVydHkgaXMgYWJzZW50XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoXCJyZXBvcnRzIGEgTVVTVF9WSU9MQVRJT04gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19fTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQub2JqZWN0XCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiB0aGUgb2JqZWN0IHByb3BlcnR5IGlzIG51bGxcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYSBNVVNUX1ZJT0xBVElPTiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIGRpc3BsYXkgOiB7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDogbnVsbH07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gdGhlIG9iamVjdCBsYWNrcyBhbiBvYmplY3RUeXBlIHByb3BlcnR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoXCJyZXBvcnRzIGEgU0hPVUxEX1ZJT0xBVElPTiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIGRpc3BsYXkgOiB7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwifX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5vYmplY3RUeXBlXCIsIFwiU0hPVUxEX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJ3aGVuIHRoZSBvYmplY3QgaXMgYW4gYWN0aXZpdHkgd2l0aCBhIG51bGwgZGVmaW5pdGlvbiBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KFwicmVwb3J0cyBhIE1VU1RfVklPTEFUSU9OIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHtcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogbnVsbH19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QuZGVmaW5pdGlvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIndoZW4gdGhlIG9iamVjdCBpcyBhbiBhY3Rpdml0eSB3aXRoIGFuIGFycmF5IGRlZmluaXRpb24gcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpdChcInJlcG9ydHMgYSBNVVNUX1ZJT0xBVElPTiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIGRpc3BsYXkgOiB7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIixcbiAgICAgICAgICAgIGRlZmluaXRpb246IFtdfX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5kZWZpbml0aW9uXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKFwid2hlbiB0aGUgb2JqZWN0IGlzIGFuIEFjdGl2aXR5IHdpdGggYSBkZWZpbml0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoXCJhbiBhcnJheSBmb3IgdGhlIG5hbWUgcHJvcGVydHkgcHJvZHVjZXMgYSBtdXN0IHZpb2xhdGlvbiBlcnJvci5cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOntuYW1lOltdfX19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QuZGVmaW5pdGlvbi5uYW1lXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJhIG51bWJlciBmb3IgdGhlIG5hbWUgcHJvcGVydHkgcHJvZHVjZXMgYSBtdXN0IHZpb2xhdGlvbiBlcnJvci5cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOntuYW1lOjEuMjN9fX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5kZWZpbml0aW9uLm5hbWVcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImFuIGludmFsaWQgbGFuZ3VhZ2UgTWFwIGtleSBmb3IgdGhlIG5hbWUgcHJvcGVydHkgcHJvZHVjZXMgYSBtdXN0IHZpb2xhdGlvbiBlcnJvci5cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOntuYW1lOntcIjEyMyB0b3RhbGx5IG5vdCBhIGxhbmd1YWdlIGNvZGVcIiA6IFwiY3JlYXRlZFwifX19fTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQub2JqZWN0LmRlZmluaXRpb24ubmFtZVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiYSBDTUkgaW50ZXJhY3Rpb25UeXBlIHZhbHVlIHByb2R1Y2VzIG5vIGVycm9yc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgYWN0b3IgOiB7bWVtYmVyOltdfSxcbiAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIGRpc3BsYXkgOiB7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIixcbiAgICAgICAgICAgIGRlZmluaXRpb246e3R5cGU6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvYWN0aXZpdGllcy9jbWkuaW50ZXJhY3Rpb25cIiwgaW50ZXJhY3Rpb25UeXBlOlwidHJ1ZS1mYWxzZVwifX19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QuZGVmaW5pdGlvbi5uYW1lXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLmZhbHNlO1xuICAgICAgfSk7XG5cblxuXG4gICAgICBpdChcImEgbm9uLUNNSSBpbnRlcmFjdGlvblR5cGUgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOnt0eXBlOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL2FjdGl2aXRpZXMvY21pLmludGVyYWN0aW9uXCIsIGludGVyYWN0aW9uVHlwZTpcImdyYXBoaWNHYXBNYXRjaEludGVyYWN0aW9uXCJ9fX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5kZWZpbml0aW9uLmludGVyYWN0aW9uVHlwZVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiYSBudW1lcmljIGNvcnJlY3RSZXNwb25zZXNQYXR0ZXJuIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHtcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjp7Y29ycmVjdFJlc3BvbnNlc1BhdHRlcm46IDEuMjN9fX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5kZWZpbml0aW9uLmNvcnJlY3RSZXNwb25zZXNQYXR0ZXJuXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJhIGZsYXQgc3RyaW5nIGNvcnJlY3RSZXNwb25zZXNQYXR0ZXJuIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHtcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjp7Y29ycmVjdFJlc3BvbnNlc1BhdHRlcm46IFwiMS4yM1wifX19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QuZGVmaW5pdGlvbi5jb3JyZWN0UmVzcG9uc2VzUGF0dGVyblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiYSBuZXN0ZWQgbnVtYmVyIGluIGEgY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4gQXJyYXkgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOntjb3JyZWN0UmVzcG9uc2VzUGF0dGVybjogWzEuMjNdfX19O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QuZGVmaW5pdGlvbi5jb3JyZWN0UmVzcG9uc2VzUGF0dGVyblswXVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiYSBuZXN0ZWQgc3RyaW5nIGluIGEgY29ycmVjdFJlc3BvbnNlc1BhdHRlcm4gQXJyYXkgdmFsdWUgcHJvZHVjZXMgbm8gZXJyb3JzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHtcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjp7Y29ycmVjdFJlc3BvbnNlc1BhdHRlcm46IFtcIjEuMjNcIl19fX07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5kZWZpbml0aW9uLmNvcnJlY3RSZXNwb25zZXNQYXR0ZXJuXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLmZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KFwiYW4gaW50ZXJhY3Rpb24gYWN0aXZpdHkgd2l0aG91dCB0aGUgc3RhbmRhcmQgXFxcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS9hY3Rpdml0aWVzL2NtaS5pbnRlcmFjdGlvblxcXCIgdmFsdWUgZm9yIHRoZSB0eXBlIHByb3BlcnR5IHNob3VsZCBwcm9kdWNlIGEgU0hPVUxEIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHtcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjp7dHlwZTpcImh0dHA6Ly9leGFtcGxlLmNvbS9zb21ldGhpbmdFbHNlXCIsIGludGVyYWN0aW9uVHlwZTpcImNob2ljZVwiLCBjaG9pY2VzOltdfX1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQub2JqZWN0LmRlZmluaXRpb24udHlwZVwiLCBcIlNIT1VMRF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICB9KTtcblxuICAgICAgaXQoXCJhbiBpbnRlcmFjdGlvbiBjb21wb25lbnQgYXJyYXkgcHJvcGVydHkgbm90IGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBpbnRlcmFjdGlvblR5cGUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOnt0eXBlOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL2FjdGl2aXRpZXMvY21pLmludGVyYWN0aW9uXCIsIGludGVyYWN0aW9uVHlwZTpcImNob2ljZVwiLCBzdGVwczpbXX19XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5kZWZpbml0aW9uLnN0ZXBzXCIsIFwiU0hPVUxEX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImFuIGludGVyYWN0aW9uIGNvbXBvbmVudCB3aXRoIHdoaXRlc3BhY2UgaW4gdGhlIGlkIHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICBhY3RvciA6IHttZW1iZXI6W119LFxuICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgZGlzcGxheSA6IHtcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjp7dHlwZTpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS9hY3Rpdml0aWVzL2NtaS5pbnRlcmFjdGlvblwiLCBpbnRlcmFjdGlvblR5cGU6XCJjaG9pY2VcIixcbiAgICAgICAgICAgICAgICBjaG9pY2VzOlt7aWQ6XCJoZWxsbyBpbnZhbGlkIGlkXCIsIGRlc2NyaXB0aW9uOnt9fV19fVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QuZGVmaW5pdGlvbi5jaG9pY2VzWzBdXCIsIFwiU0hPVUxEX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpdChcImFuIGludGVyYWN0aW9uIGNvbXBvbmVudCB3aXRoIHJlcGVhdGVkIG5vbi11bmlxdWUgaWQgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgIGFjdG9yIDoge21lbWJlcjpbXX0sXG4gICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBkaXNwbGF5IDoge1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCIsXG4gICAgICAgICAgICBkZWZpbml0aW9uOnt0eXBlOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL2FjdGl2aXRpZXMvY21pLmludGVyYWN0aW9uXCIsIGludGVyYWN0aW9uVHlwZTpcImNob2ljZVwiLFxuICAgICAgICAgICAgICAgIGNob2ljZXM6W3tpZDpcImlkQVwiLCBkZXNjcmlwdGlvbjp7fX0sIHtpZDpcImlkQVwiLCBkZXNjcmlwdGlvbjp7fX1dfX1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQub2JqZWN0LmRlZmluaXRpb24uY2hvaWNlc1sxXVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZ2l2ZW4gYSBzdGF0ZW1lbnQgcmVmZXJlbmNlIHR5cGUgb2JqZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdChcInJlcG9ydHMgYSBNVVNUIGVycm9yIHdoZW4gdGhlIGlkIHByb3BlcnR5IGlzIG1pc3NpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtvYmplY3RUeXBlOlwiU3RhdGVtZW50UmVmXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQub2JqZWN0LmlkXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwicmVwb3J0cyBhIE1VU1QgZXJyb3Igd2hlbiB0aGUgaWQgcHJvcGVydHkgaXMgbm90IGEgVVVJRFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkOiBcIm5vdCBhIFVVSURcIiwgb2JqZWN0VHlwZTpcIlN0YXRlbWVudFJlZlwifX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5pZFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZShcImdpdmVuIGEgc3Vic3RhdGVtZW50IHR5cGUgb2JqZWN0XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGl0KFwic2hvdWxkIG5vdCByZXBvcnQgYW4gZXJyb3Igd2hlbiB2YWxpZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdCA6IHsgb2JqZWN0VHlwZTpcIlN1YlN0YXRlbWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdG9yIDogeyBtYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogeyBpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9fX07XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGl0KFwicmVwb3J0cyBhIE1VU1QgZXJyb3Igd2hlbiB0aGUgaWQgcHJvcGVydHkgaXMgcHJlc2VudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIixcbiAgICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdCA6IHsgaWQ6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWExXCIsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6XCJTdWJTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0b3IgOiB7IG1ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHsgaWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX19O1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuXG4gICAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5pZFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaXQoXCJyZXBvcnRzIGEgTVVTVCBlcnJvciB3aGVuIHRoZSB2ZXJzaW9uIHByb3BlcnR5IGlzIHByZXNlbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgICAgICBvYmplY3QgOiB7IHZlcnNpb246IFwiMS4wLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOlwiU3ViU3RhdGVtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0b3IgOiB7IG1ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7IGlkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19fTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3QudmVyc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaXQoXCJyZXBvcnRzIGEgTVVTVCBlcnJvciB3aGVuIHRoZSBzdG9yZWQgcHJvcGVydHkgaXMgcHJlc2VudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IDogeyBzdG9yZWQ6IFwiMjAxMy0wNS0yOFQwNzoxMjo1Ny4yNDVaXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUeXBlOlwiU3ViU3RhdGVtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RvciA6IHsgbWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7IGlkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19fTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5vYmplY3Quc3RvcmVkXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpdChcInJlcG9ydHMgYSBNVVNUIGVycm9yIHdoZW4gdGhlIGF1dGhvcml0eSBwcm9wZXJ0eSBpcyBwcmVzZW50XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgOiB7IGF1dGhvcml0eTogeyBtYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFR5cGU6XCJTdWJTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdG9yIDogeyBtYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHsgaWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifX19O1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50Lm9iamVjdC5hdXRob3JpdHlcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZShcImdpdmVuIGEgbm9uLU9iamVjdCByZXN1bHRzIHByb3BlcnR5XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdChcImlmIG51bGwsIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiBudWxsfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0XCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiaWYgYW4gQXJyYXksIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiBbXX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnJlc3VsdFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImlmIGFuIG51bWJlciwgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IDEuMjN9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5yZXN1bHRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoXCJnaXZlbiBhIHJlc3VsdHMgcHJvcGVydHkgdGhhdCBpcyBhbiBvYmplY3RcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KFwiaWYgZW1wdHksIGFsbCBpcyBva2F5LCBubyBwcm9wZXJ0aWVzIHdlcmUgcmVxdWlyZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHt9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBub24tQm9vbGVhbiBzdWNjZXNzIHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7c3VjY2VzczoxMjN9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LnN1Y2Nlc3NcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIEJvb2xlYW4gc3VjY2VzcyBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge3N1Y2Nlc3M6ZmFsc2V9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBub24tQm9vbGVhbiBjb21wbGV0aW9uIHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7Y29tcGxldGlvbjoxMjN9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LmNvbXBsZXRpb25cIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIEJvb2xlYW4gY29tcGxldGlvbiBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge2NvbXBsZXRpb246ZmFsc2V9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG5vbi1TdHJpbmcgcmVzcG9uc2UgcHJvcGVydHkgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtyZXNwb25zZToxMjN9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LnJlc3BvbnNlXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBTdHJpbmcgcmVzcG9uc2UgcHJvcGVydHkgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtyZXNwb25zZTpcImlkQVwifX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbm9uLVN0cmluZyBkdXJhdGlvbiBwcm9wZXJ0eSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge2R1cmF0aW9uOjEyM319O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5yZXN1bHQuZHVyYXRpb25cIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG5vbi1JU08gODYwMSBkdXJhdGlvbiBTdHJpbmcgZHVyYXRpb24gcHJvcGVydHkgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtkdXJhdGlvbjpcIm5vdCBhbiBJU08gY29tcGxpYW50IGR1cmF0aW9uXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LmR1cmF0aW9uXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gSVNPIDg2MDEgZHVyYXRpb24gU3RyaW5nIHJlc3BvbnNlIHByb3BlcnR5IHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7ZHVyYXRpb246XCJQM1k2TTREVDEySDMwTTVTXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gSVNPIDg2MDEgZHVyYXRpb24gU3RyaW5nIHJlc3BvbnNlIHByb3BlcnR5IHdpdGggZnJhY3Rpb25hbCBzZWNvbmRzIHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7ZHVyYXRpb246XCJQM1k2TTREVDEySDMwTTUuMDFTXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZ2l2ZW4gYSBzY29yZSBwcm9wZXJ0eSBvbiB0aGUgcmVzdWx0c1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG5vbi1OdW1iZXIgcmF3IHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7c2NvcmU6e3JhdzpcIjEyM1wifX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5yZXN1bHQuc2NvcmUucmF3XCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBOdW1iZXIgcmF3IHByb3BlcnR5IHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7c2NvcmU6e3JhdzoxMjN9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgTnVtYmVyIHJhdyBwcm9wZXJ0eSBiZWxvdyBtaW4gcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7cmF3OjEyMywgbWluOjIwMH19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LnNjb3JlLnJhd1wiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgTnVtYmVyIHJhdyBwcm9wZXJ0eSBhYm92ZSBtYXggcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7cmF3OjEyMywgbWF4OjEwMH19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LnNjb3JlLnJhd1wiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgTnVtYmVyIHJhdyBwcm9wZXJ0eSBiZXR3ZWVuIG1pbiBhbmQgbWF4IHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7c2NvcmU6e3JhdzoxMjMsIG1pbjoxMjAsIG1heDoxMjV9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbm9uLU51bWJlciBzY2FsZWQgcHJvcGVydHkgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7c2NhbGVkOlwiMC41XCJ9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnJlc3VsdC5zY29yZS5zY2FsZWRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIE51bWJlciBzY2FsZWQgcHJvcGVydHkgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7c2NhbGVkOjAuNX19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBOdW1iZXIgc2NhbGVkIHByb3BlcnR5IGJlbG93IDAgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7c2NhbGVkOi0wLjV9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnJlc3VsdC5zY29yZS5zY2FsZWRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIE51bWJlciBzY2FsZWQgcHJvcGVydHkgYWJvdmUgMSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge3Njb3JlOntzY2FsZWQ6Mn19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LnNjb3JlLnNjYWxlZFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbm9uLU51bWJlciBtYXggcHJvcGVydHkgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7bWF4OlwiMTIzXCJ9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnJlc3VsdC5zY29yZS5tYXhcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIE51bWJlciBtYXggcHJvcGVydHkgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA6IHtzY29yZTp7bWF4OjEyM319fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBOdW1iZXIgbWF4IHByb3BlcnR5IGJlbG93IG1pbiBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge3Njb3JlOnttYXg6MTIzLCBtaW46MjAwfX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5yZXN1bHQuc2NvcmUubWF4XCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBub24tTnVtYmVyIG1pbiBwcm9wZXJ0eSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge3Njb3JlOnttaW46XCIxMjNcIn19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQucmVzdWx0LnNjb3JlLm1pblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgTnVtYmVyIG1pbiBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgcmVzdWx0IDoge3Njb3JlOnttaW46MTIzfX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIE51bWJlciBtaW4gcHJvcGVydHkgYWJvdmUgbWF4IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICByZXN1bHQgOiB7c2NvcmU6e21heDoxMjMsIG1pbjoyMDB9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnJlc3VsdC5zY29yZS5tYXhcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoXCJmb3IgYSBnaXZlbiBkZWZpbmVkIGNvbnRleHQgcHJvcGVydHlcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KFwiYW4gZW1wdHkgb2JqZWN0IHByb2R1Y2VzIG5vIGVycm9yc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge319O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBub24tb2JqZWN0IGNvbnRleHQgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IDEyM307XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBhcnJheSBjb250ZXh0IHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBbXX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG5vbi1VVUlEIHJlZ2lzdHJhdGlvbiB2YWx1ZSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3JlZ2lzdHJhdGlvbjpcIm5vdCBhIFVVSURcIn19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5jb250ZXh0LnJlZ2lzdHJhdGlvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgVVVJRCByZWdpc3RyYXRpb24gdmFsdWUgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtyZWdpc3RyYXRpb246XCJlZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIn19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBlbXB0eSBtYXAgZm9yIGFuIGluc3RydWN0b3IgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtpbnN0cnVjdG9yOnt9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQuaW5zdHJ1Y3RvclwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImFuIHVuaWRlbnRpZmllZCBBZ2VudCBmb3IgYW4gaW5zdHJ1Y3RvciB2YWx1ZSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2luc3RydWN0b3I6e29iamVjdFR5cGU6XCJBZ2VudFwifX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5jb250ZXh0Lmluc3RydWN0b3JcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiB1bmlkZW50aWZpZWQgR3JvdXAgd2l0aCBubyBtZW1iZXIgcHJvcGVydHkgZm9yIGFuIGluc3RydWN0b3IgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtpbnN0cnVjdG9yOntvYmplY3RUeXBlOlwiR3JvdXBcIn19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5pbnN0cnVjdG9yXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gQWdlbnQgaW5zdHJ1Y3RvciB2YWx1ZSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2luc3RydWN0b3I6e21ib3g6XCJtYWlsdG86Ym9iQGV4YW1wbGUuY29tXCJ9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgR3JvdXAgaW5zdHJ1Y3RvciBpZGVudGlmaWVkIGJ5IG1lbWJlciBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2luc3RydWN0b3I6e21ib3g6XCJtYWlsdG86Ym9iQGV4YW1wbGUuY29tXCIsIG1lbWJlcjpbXX19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBHcm91cCBpbnN0cnVjdG9yIGlkZW50aWZpZWQgYnkgb2JqZWN0VHlwZSBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2luc3RydWN0b3I6e21ib3g6XCJtYWlsdG86Ym9iQGV4YW1wbGUuY29tXCIsIG9iamVjdFR5cGU6XCJHcm91cFwifX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJpZiB0aGUgc3RhdGVtZW50J3Mgb2JqZWN0IGlzIGFuIEFnZW50LCB0aGUgcHJlc2VuY2Ugb2YgdGhlIHJldmlzaW9uIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7bWJveCA6IFwibWFpbHRvOmJvYkBleGFtcGxlLmNvbVwiLCBvYmplY3RUeXBlOlwiQWdlbnRcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3JldmlzaW9uOlwiMS4wXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5yZXZpc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImlmIHRoZSBzdGF0ZW1lbnQncyBvYmplY3QgaXMgYW4gR3JvdXAsIHRoZSBwcmVzZW5jZSBvZiB0aGUgcmV2aXNpb24gcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHttYm94IDogXCJtYWlsdG86Z3JvdXBAZXhhbXBsZS5jb21cIiwgb2JqZWN0VHlwZTpcIkdyb3VwXCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtyZXZpc2lvbjpcIjEuMFwifX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQucmV2aXNpb25cIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyByZXZpc2lvbiBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3JldmlzaW9uOlwiMS4wXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBub24tU3RyaW5nIG51bWVyaWMgcmV2aXNpb24gcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtyZXZpc2lvbjoxLjB9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5yZXZpc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVsbCByZXZpc2lvbiBwcm9wZXJ0eSB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3JldmlzaW9uOm51bGx9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5yZXZpc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLy9cbiAgICAgICAgaXQoXCJpZiB0aGUgc3RhdGVtZW50J3Mgb2JqZWN0IGlzIGFuIEFnZW50LCB0aGUgcHJlc2VuY2Ugb2YgdGhlIHBsYXRmb3JtIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7bWJveCA6IFwibWFpbHRvOmJvYkBleGFtcGxlLmNvbVwiLCBvYmplY3RUeXBlOlwiQWdlbnRcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3BsYXRmb3JtOlwiMS4wXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5wbGF0Zm9ybVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImlmIHRoZSBzdGF0ZW1lbnQncyBvYmplY3QgaXMgYW4gR3JvdXAsIHRoZSBwcmVzZW5jZSBvZiB0aGUgcGxhdGZvcm0gcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHttYm94IDogXCJtYWlsdG86Z3JvdXBAZXhhbXBsZS5jb21cIiwgb2JqZWN0VHlwZTpcIkdyb3VwXCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtwbGF0Zm9ybTpcIjEuMFwifX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQucGxhdGZvcm1cIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyBwbGF0Zm9ybSBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3BsYXRmb3JtOlwiMS4wXCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBub24tU3RyaW5nIG51bWVyaWMgcGxhdGZvcm0gcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtwbGF0Zm9ybToxLjB9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5wbGF0Zm9ybVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVsbCBwbGF0Zm9ybSBwcm9wZXJ0eSB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3BsYXRmb3JtOm51bGx9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5wbGF0Zm9ybVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVsbCB0ZWFtIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7dGVhbTpudWxsfX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQudGVhbVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgR3JvdXAgb2JqZWN0IHRlYW0gcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHt0ZWFtOntvYmplY3RUeXBlOlwiR3JvdXBcIiwgbWJveDpcIm1haWx0bzpncm91cEBleGFtcGxlLmNvbVwifX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFJGQyA1NjQ2IHN0cmluZyB2YWx1ZSBmb3IgdGhlIGxhbmd1YWdlIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7bGFuZ3VhZ2U6XCJlbi1VU1wifX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbm9uLVJGQyA1NjQ2IHN0cmluZyB2YWx1ZSBmb3IgdGhlIGxhbmd1YWdlIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7bGFuZ3VhZ2U6XCIxMjMgdG90YWxseSBub3QgUkZDIGNvbXBsaWFudFwifX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQubGFuZ3VhZ2VcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG51bGwgdmFsdWUgZm9yIHRoZSBsYW5ndWFnZSBwcm9wZXJ0eSB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2xhbmd1YWdlOm51bGx9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5sYW5ndWFnZVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbm9uLVN0cmluZyB2YWx1ZSBmb3IgdGhlIGxhbmd1YWdlIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7bGFuZ3VhZ2U6MX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5jb250ZXh0Lmxhbmd1YWdlXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgaXQoXCJhIG51bGwgdmFsdWUgZm9yIHRoZSBjb250ZXh0J3Mgc3RhdGVtZW50IHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7c3RhdGVtZW50Om51bGx9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5zdGF0ZW1lbnRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBBcnJheSB2YWx1ZSBmb3IgdGhlIGNvbnRleHQncyBzdGF0ZW1lbnQgcHJvcGVydHkgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtzdGF0ZW1lbnQ6W119fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5zdGF0ZW1lbnRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBlbXB0eSBvYmplY3QgdmFsdWUgZm9yIHRoZSBjb250ZXh0J3Mgc3RhdGVtZW50IHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIGVycm9yc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3N0YXRlbWVudDp7fX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAyKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5jb250ZXh0LnN0YXRlbWVudC5vYmplY3RUeXBlXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuY29udGV4dC5zdGF0ZW1lbnQuaWRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIHZhbGlkIHN0YXRlbWVudCByZWZlcmVuY2UgZm9yIHRoZSBjb250ZXh0J3Mgc3RhdGVtZW50IHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIG5vIGVycm9yc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge3N0YXRlbWVudDp7b2JqZWN0VHlwZTpcIlN0YXRlbWVudFJlZlwiLCBpZDpcImFiY2RjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwifX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoXCJmb3IgYSBjb250ZXh0IHByb3BlcnR5IHdpdGggYSBjb250ZXh0QWN0aXZpdGllcyBwcm9wZXJ0eVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG51bGwgY29udGV4dEFjdGl2aXRpZXMgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtjb250ZXh0QWN0aXZpdGllczpudWxsfX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQuY29udGV4dEFjdGl2aXRpZXNcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBBcnJheSBjb250ZXh0QWN0aXZpdGllcyB2YWx1ZSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2NvbnRleHRBY3Rpdml0aWVzOltdfX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQuY29udGV4dEFjdGl2aXRpZXNcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBOdW1lcmljIGNvbnRleHRBY3Rpdml0aWVzIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7Y29udGV4dEFjdGl2aXRpZXM6MS4yM319O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5jb250ZXh0LmNvbnRleHRBY3Rpdml0aWVzXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gZW1wdHkgY29udGV4dEFjdGl2aXRpZXMgb2JqZWN0IHZhbHVlIHByb2R1Y2VzIG5vIGVycm9yc1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgY29udGV4dDoge2NvbnRleHRBY3Rpdml0aWVzOnt9fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgc2luZ2xlIEFjdGl2aXR5IHBhcmVudCBwcm9wZXJ0eSB2YWx1ZSBwcm9kdWNlcyBhIFNIT1VMRCB3YXJuaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7Y29udGV4dEFjdGl2aXRpZXM6e3BhcmVudDp7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teU90aGVyQWN0aXZpdHlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn19fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQuY29udGV4dEFjdGl2aXRpZXNcIiwgXCJTSE9VTERfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImFuIGVtcHR5IEFycmF5IHBhcmVudCBwcm9wZXJ0eSB2YWx1ZSBwcm9kdWNlcyBubyBlcnJvcnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtjb250ZXh0QWN0aXZpdGllczp7cGFyZW50OltdfX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBBcnJheSB3aXRoIGEgdmFsaWQgQWN0aXZpdHkgaW4gdGhlIHBhcmVudCBwcm9wZXJ0eSBwcm9kdWNlcyBubyBlcnJvcnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtjb250ZXh0QWN0aXZpdGllczp7cGFyZW50Olt7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teU90aGVyQWN0aXZpdHlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn1dfX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBBcnJheSB3aXRoIGEgaW52YWxpZCBBY3Rpdml0eSBpbiB0aGUgcGFyZW50IHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7Y29udGV4dEFjdGl2aXRpZXM6e3BhcmVudDpbe29iamVjdFR5cGU6XCJBY3Rpdml0eVwifV19fX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmNvbnRleHQuY29udGV4dEFjdGl2aXRpZXMucGFyZW50WzBdLmlkXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZ2l2ZW4gYSB0aW1lc3RhbXAgcHJvcGVydHkgb24gdGhlIHN0YXRlbWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG51bGwgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbnVsbH07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnRpbWVzdGFtcFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVtZXJpYyB2YWx1ZSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAxLjIzfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQudGltZXN0YW1wXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBEYXRlIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCl9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC50aW1lc3RhbXBcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSBub3QgaW4gSVNPIDg2MDEgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogXCJ0b3RhbGx5IHdyb25nXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC50aW1lc3RhbXBcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTyA4NjAxIGF0IFVUQyB2aWEgWiBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTVaXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTyA4NjAxIGF0IFVUQyB2aWEgWiB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbiBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTUuMDA4WlwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBTdHJpbmcgdmFsdWUgd2l0aCBJU08gODYwMSB3aXRoIGEgcG9zaXRpdmUgdGltZXpvbmUgb2Zmc2V0IGhvdXIgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogXCIyMDEzLTA1LTA5VDE0OjQ1OjE1KzAxXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTyA4NjAxIHdpdGggYSBwb3NpdGl2ZSB0aW1lem9uZSBvZmZzZXQgaG91ciBhbmQgbWludXRlcyBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTUrMDE6MDJcIn07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgU3RyaW5nIHZhbHVlIHdpdGggSVNPIDg2MDEgd2l0aCBhIG5lZ2F0aXZlIHRpbWV6b25lIG9mZnNldCBob3VyIHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IFwiMjAxMy0wNS0wOVQxNDo0NToxNS0wMVwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBTdHJpbmcgdmFsdWUgd2l0aCBJU08gODYwMSB3aXRoIGEgbmVnYXRpdmUgdGltZXpvbmUgb2Zmc2V0IGhvdXIgYW5kIG1pbnV0ZXMgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogXCIyMDEzLTA1LTA5VDE0OjQ1OjE1LTAxOjAyXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTzg2MDEgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgb3IgWiBwcm9kdWNlcyBhIFNIT1VMRCBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTVcIn07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnRpbWVzdGFtcFwiLCBcIlNIT1VMRF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZ2l2ZW4gYSBzdG9yZWQgcHJvcGVydHkgb24gdGhlIHN0YXRlbWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG51bGwgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHN0b3JlZDogbnVsbH07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnN0b3JlZFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVtZXJpYyB2YWx1ZSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgc3RvcmVkOiAxLjIzfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuc3RvcmVkXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBEYXRlIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBzdG9yZWQ6IG5ldyBEYXRlKCl9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5zdG9yZWRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSBub3QgaW4gSVNPIDg2MDEgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHN0b3JlZDogXCJ0b3RhbGx5IHdyb25nXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5zdG9yZWRcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTyA4NjAxIGF0IFVUQyB2aWEgWiBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgc3RvcmVkOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTVaXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTyA4NjAxIGF0IFVUQyB2aWEgWiB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbiBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgc3RvcmVkOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTUuMDA4WlwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBTdHJpbmcgdmFsdWUgd2l0aCBJU08gODYwMSB3aXRoIGEgcG9zaXRpdmUgdGltZXpvbmUgb2Zmc2V0IGhvdXIgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHN0b3JlZDogXCIyMDEzLTA1LTA5VDE0OjQ1OjE1KzAxXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTyA4NjAxIHdpdGggYSBwb3NpdGl2ZSB0aW1lem9uZSBvZmZzZXQgaG91ciBhbmQgbWludXRlcyBwcm9kdWNlcyBubyBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgc3RvcmVkOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTUrMDE6MDJcIn07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgU3RyaW5nIHZhbHVlIHdpdGggSVNPIDg2MDEgd2l0aCBhIG5lZ2F0aXZlIHRpbWV6b25lIG9mZnNldCBob3VyIHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBzdG9yZWQ6IFwiMjAxMy0wNS0wOVQxNDo0NToxNS0wMVwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBTdHJpbmcgdmFsdWUgd2l0aCBJU08gODYwMSB3aXRoIGEgbmVnYXRpdmUgdGltZXpvbmUgb2Zmc2V0IGhvdXIgYW5kIG1pbnV0ZXMgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHN0b3JlZDogXCIyMDEzLTA1LTA5VDE0OjQ1OjE1LTAxOjAyXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIFN0cmluZyB2YWx1ZSB3aXRoIElTTzg2MDEgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgb3IgWiBwcm9kdWNlcyBhIFNIT1VMRCBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgc3RvcmVkOiBcIjIwMTMtMDUtMDlUMTQ6NDU6MTVcIn07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnN0b3JlZFwiLCBcIlNIT1VMRF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZm9yIGEgbm9uLW9iamVjdCBhdXRob3JpdHkgcHJvcGVydHkgb24gdGhlIHN0YXRlbWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG51bGwgYXV0aG9yaXR5IHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IG51bGx9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5hdXRob3JpdHlcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBBcnJheSBhdXRob3JpdHkgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogW119O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5hdXRob3JpdHlcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBOdW1lcmljIGF1dGhvcml0eSB2YWx1ZSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiBbXX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF1dGhvcml0eVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZShcImZvciBhbiBhdXRob3JpdHkgcHJvcGVydHkgd2l0aCBhbiBvYmplY3QgdmFsdWUgb24gdGhlIHN0YXRlbWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhbiBBZ2VudCBhdXRob3JpdHkgdmFsdWUgcHJvZHVjZXMgbm8gZXJyb3JzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHtvYmplY3RUeXBlOlwiQWdlbnRcIiwgbWJveDpcIm1haWx0bzpib2JAZXhhbXBsZS5jb21cIn19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBBZ2VudCBhdXRob3JpdHkgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3IgaWYgYW4gaW52YWxpZCBBZ2VudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiB7b2JqZWN0VHlwZTpcIkFnZW50XCJ9fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXV0aG9yaXR5XCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gR3JvdXAgYXV0aG9yaXR5IHZhbHVlIHdpdGggdHdvIG1lbWJlcnMgcHJvZHVjZXMgbm8gZXJyb3JzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHtvYmplY3RUeXBlOlwiR3JvdXBcIiwgbWVtYmVyOlt7b2JqZWN0VHlwZTpcIkFnZW50XCIsIG1ib3g6XCJtYWlsdG86Ym9iQGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgICAgICB7b2JqZWN0VHlwZTpcIkFnZW50XCIsIG1ib3g6XCJtYWlsdG86dG9tQGV4YW1wbGUuY29tXCJ9XX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBHcm91cCBhdXRob3JpdHkgdmFsdWUgd2l0aCBsZXNzIHRoYW4gdHdvIG1lbWJlcnMgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eToge29iamVjdFR5cGU6XCJHcm91cFwiLCBtZW1iZXI6W3tvYmplY3RUeXBlOlwiQWdlbnRcIiwgbWJveDpcIm1haWx0bzpib2JAZXhhbXBsZS5jb21cIn1dfX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF1dGhvcml0eS5tZW1iZXJcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBHcm91cCBhdXRob3JpdHkgdmFsdWUgd2l0aCBtb3JlIHRoYW4gdHdvIG1lbWJlcnMgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eToge29iamVjdFR5cGU6XCJHcm91cFwiLCBtZW1iZXI6W3tvYmplY3RUeXBlOlwiQWdlbnRcIiwgbWJveDpcIm1haWx0bzpib2JAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICAgIHtvYmplY3RUeXBlOlwiQWdlbnRcIiwgbWJveDpcIm1haWx0bzp0b21AZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgICAgIHtvYmplY3RUeXBlOlwiQWdlbnRcIiwgbWJveDpcIm1haWx0bzpmcmFua0BleGFtcGxlLmNvbVwifV19fTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXV0aG9yaXR5Lm1lbWJlclwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImFuIEdyb3VwIGF1dGhvcml0eSB2YWx1ZSB3aXRoIGFuIGludmFsaWQgbWVtYmVyIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdXRob3JpdHk6IHtvYmplY3RUeXBlOlwiR3JvdXBcIiwgbWVtYmVyOlt7b2JqZWN0VHlwZTpcIkFnZW50XCIsIG1ib3g6XCJtYWlsdG86Ym9iQGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgICAgICB7b2JqZWN0VHlwZTpcIkFnZW50XCJ9XX19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5hdXRob3JpdHkubWVtYmVyWzFdXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZm9yIGFuIHZlcnNpb24gcHJvcGVydHkgb24gdGhlIHN0YXRlbWVudCB3aXRoIGEgbm9uLXN0cmluZyB2YWx1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG51bGwgdmFsdWUgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHZlcnNpb246IG51bGx9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC52ZXJzaW9uXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBudW1lcmljIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAxLjB9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC52ZXJzaW9uXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKFwiZm9yIGFuIHZlcnNpb24gcHJvcGVydHkgd2l0aCBhIHN0cmluZyB2YWx1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIHNpbXBsZSBzZW1hbnRpYyB2ZXJzaW9uIHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIHNlbWFudGljIHZlcnNpb24gd2l0aCBpbnRlcm1peGVkIG5vbi1udW1iZXJzIGluIHRoZSBtYWpvci9taW5vci9wYXRjaCBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxLjAuYVwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQudmVyc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgc2VtYW50aWMgdmVyc2lvbiB3aXRoIHZhbGlkIHByZS1yZWxlYXNlIGluZm8gcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHZlcnNpb246IFwiMS4wLjAtcmMxXCJ9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIHNlbWFudGljIHZlcnNpb24gd2l0aCBpbnZhbGlkIHByZS1yZWxlYXNlIGluZm8gcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIHZlcnNpb246IFwiMS4wLjAtcmMuMVwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQudmVyc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgc2VtYW50aWMgdmVyc2lvbiB3aXRoIFNlbVZlciAyLjAuMCBidWlsZCByZWxlYXNlIGluZm8gY2hhcmFjdGVycyBub3QgaW4gU2VtVmVyIDEuMC4wIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wLWFscGhhLjFcIn07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LnZlcnNpb25cIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIHNlbWFudGljIHZlcnNpb24gd2l0aCBTZW1WZXIgMi4wLjAgYnVpbGQgcmVsZWFzZSBtZXRhZGF0YSBub3QgaW4gU2VtVmVyIDEuMC4wIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjEuMC4wLWFscGhhKzAwMVwifTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQudmVyc2lvblwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZShcImZvciBhbiBhdHRhY2htZW50cyBwcm9wZXJ0eSBvbiB0aGUgc3RhdGVtZW50IHdpdGggYSBub24tQXJyYXkgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KFwiYSBudWxsIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogbnVsbH07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBudW1lcmljIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogMS4wfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBvYmplY3QgbWFwIHZhbHVlIHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czoge319O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5hdHRhY2htZW50c1wiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZShcImZvciBhbiBhdHRhY2htZW50cyBwcm9wZXJ0eSBvbiB0aGUgc3RhdGVtZW50IHdpdGggYW4gQXJyYXkgdmFsdWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KFwiYW4gZW1wdHkgQXJyYXkgcHJvZHVjZXMgbm8gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBbXX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZShcImZvciBhbiBhdHRhY2htZW50IG9iamVjdCB3aXRoaW4gdGhlIGF0dGFjaG1lbnRzIHByb3BlcnR5J3MgQXJyYXkgb24gdGhlIHN0YXRlbWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoXCJhIG51bGwgb2JqZWN0IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW251bGxdfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNbMF1cIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJtaW5pbWFsIHZhbGlkIGF0dGFjaG1lbnQgb2JqZWN0IHByb2R1Y2VzIG5vIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGNvbnRlbnRUeXBlOlwidGV4dC9wbGFpblwiLCBsZW5ndGg6MTEsIHNoYTI6XCJ1VTBudVpOTlBnaWxMbExYMm4ycitzU0U3K042VTREdWtJajNyT0x2emVrPVwifV19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhbiBhYnNlbnQgdXNhZ2VUeXBlIHByb3BlcnR5IG9iamVjdCBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IFt7ZGlzcGxheTp7fSwgY29udGVudFR5cGU6XCJ0ZXh0L3BsYWluXCIsIGxlbmd0aDoxMSwgc2hhMjpcInVVMG51Wk5OUGdpbExsTFgybjJyK3NTRTcrTjZVNER1a0lqM3JPTHZ6ZWs9XCJ9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLnVzYWdlVHlwZVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVsbCB1c2FnZVR5cGUgcHJvcGVydHkgb2JqZWN0IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6bnVsbCwgZGlzcGxheTp7fSwgY29udGVudFR5cGU6XCJ0ZXh0L3BsYWluXCIsIGxlbmd0aDoxMSwgc2hhMjpcInVVMG51Wk5OUGdpbExsTFgybjJyK3NTRTcrTjZVNER1a0lqM3JPTHZ6ZWs9XCJ9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLnVzYWdlVHlwZVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVtZXJpYyB1c2FnZVR5cGUgcHJvcGVydHkgb2JqZWN0IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6MTIzLCBkaXNwbGF5Ont9LCBjb250ZW50VHlwZTpcInRleHQvcGxhaW5cIiwgbGVuZ3RoOjExLCBzaGEyOlwidVUwbnVaTk5QZ2lsTGxMWDJuMnIrc1NFNytONlU0RHVrSWozck9Mdnplaz1cIn1dfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNbMF0udXNhZ2VUeXBlXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gb2JqZWN0IHVzYWdlVHlwZSBwcm9wZXJ0eSBvYmplY3QgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBbe3VzYWdlVHlwZTp7fSwgZGlzcGxheTp7fSwgY29udGVudFR5cGU6XCJ0ZXh0L3BsYWluXCIsIGxlbmd0aDoxMSwgc2hhMjpcInVVMG51Wk5OUGdpbExsTFgybjJyK3NTRTcrTjZVNER1a0lqM3JPTHZ6ZWs9XCJ9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLnVzYWdlVHlwZVwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImFuIGFic2VudCBjb250ZW50VHlwZSBwcm9wZXJ0eSBvYmplY3QgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBbe3VzYWdlVHlwZTpcImh0dHA6Ly9leGFtcGxlLmNvbS91c2FnZS9pbmZvL0FcIiwgZGlzcGxheTp7fSwgbGVuZ3RoOjExLCBzaGEyOlwidVUwbnVaTk5QZ2lsTGxMWDJuMnIrc1NFNytONlU0RHVrSWozck9Mdnplaz1cIn1dfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNbMF0uY29udGVudFR5cGVcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG51bGwgY29udGVudFR5cGUgcHJvcGVydHkgb2JqZWN0IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGNvbnRlbnRUeXBlOm51bGwsIGxlbmd0aDoxMSwgc2hhMjpcInVVMG51Wk5OUGdpbExsTFgybjJyK3NTRTcrTjZVNER1a0lqM3JPTHZ6ZWs9XCJ9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLmNvbnRlbnRUeXBlXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYW4gYWJzZW50IGxlbmd0aCBwcm9wZXJ0eSBvYmplY3QgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBbe3VzYWdlVHlwZTpcImh0dHA6Ly9leGFtcGxlLmNvbS91c2FnZS9pbmZvL0FcIiwgZGlzcGxheTp7fSwgY29udGVudFR5cGU6XCJ0ZXh0L3BsYWluXCIsIHNoYTI6XCJ1VTBudVpOTlBnaWxMbExYMm4ycitzU0U3K042VTREdWtJajNyT0x2emVrPVwifV19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5hdHRhY2htZW50c1swXS5sZW5ndGhcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG51bGwgbGVuZ3RoIHByb3BlcnR5IG9iamVjdCBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IFt7dXNhZ2VUeXBlOlwiaHR0cDovL2V4YW1wbGUuY29tL3VzYWdlL2luZm8vQVwiLCBkaXNwbGF5Ont9LCBjb250ZW50VHlwZTpcInRleHQvcGxhaW5cIiwgbGVuZ3RoOm51bGwsIHNoYTI6XCJ1VTBudVpOTlBnaWxMbExYMm4ycitzU0U3K042VTREdWtJajNyT0x2emVrPVwifV19O1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB4YXBpVmFsaWRhdG9yLnZhbGlkYXRlU3RhdGVtZW50KGlucHV0U3RhdGVtZW50KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmVycm9ycykudG8uaGF2ZS5wcm9wZXJ0eShcImxlbmd0aFwiLCAxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXBvcnRIYXNFcnJvcldpdGhUcmFjZVByZWZpeChyZXN1bHRzLCBcInN0YXRlbWVudC5hdHRhY2htZW50c1swXS5sZW5ndGhcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIHN0cmluZyBsZW5ndGggcHJvcGVydHkgb2JqZWN0IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGNvbnRlbnRUeXBlOlwidGV4dC9wbGFpblwiLCBsZW5ndGg6XCIxMVwiLCBzaGEyOlwidVUwbnVaTk5QZ2lsTGxMWDJuMnIrc1NFNytONlU0RHVrSWozck9Mdnplaz1cIn1dfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNbMF0ubGVuZ3RoXCIsIFwiTVVTVF9WSU9MQVRJT05cIikpLnRvLmJlLnRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KFwiYSBub24taW50ZWdlciBsZW5ndGggcHJvcGVydHkgb2JqZWN0IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGNvbnRlbnRUeXBlOlwidGV4dC9wbGFpblwiLCBsZW5ndGg6MTEuNSwgc2hhMjpcInVVMG51Wk5OUGdpbExsTFgybjJyK3NTRTcrTjZVNER1a0lqM3JPTHZ6ZWs9XCJ9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLmxlbmd0aFwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVsbCBzaGEyIHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGNvbnRlbnRUeXBlOlwidGV4dC9wbGFpblwiLCBsZW5ndGg6MTEsIHNoYTI6bnVsbH1dfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNbMF0uc2hhMlwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImFuIGFic2VudCBzaGEyIHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGNvbnRlbnRUeXBlOlwidGV4dC9wbGFpblwiLCBsZW5ndGg6MTF9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLnNoYTJcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG51bWVyaWMgc2hhMiBwcm9wZXJ0eSBwcm9kdWNlcyBhbiBlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFN0YXRlbWVudCA9IHtpZCA6IFwiZmQ0MWM5MTgtYjg4Yi00YjIwLWEwYTUtYTRjMzIzOTFhYWEwXCIgLFxuICAgICAgICAgICAgICAgIGFjdG9yIDoge21ib3g6XCJtYWlsdG86YWdlbnRAZXhhbXBsZS5jb21cIn0sXG4gICAgICAgICAgICAgICAgdmVyYjogeyBcImlkXCI6XCJodHRwOi8vYWRsbmV0Lmdvdi9leHBhcGkvdmVyYnMvY3JlYXRlZFwiLCBcImRpc3BsYXlcIjp7XCJlbi1VU1wiOlwiY3JlYXRlZFwifX0sXG4gICAgICAgICAgICAgICAgb2JqZWN0IDoge2lkIDogXCJodHRwOi8vZXhhbXBsZS5jb20vbXlVbmlxdWVJZFwiLCBvYmplY3RUeXBlOlwiQWN0aXZpdHlcIn0sXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IFt7dXNhZ2VUeXBlOlwiaHR0cDovL2V4YW1wbGUuY29tL3VzYWdlL2luZm8vQVwiLCBkaXNwbGF5Ont9LCBjb250ZW50VHlwZTpcInRleHQvcGxhaW5cIiwgbGVuZ3RoOjExLCBzaGEyOjEuMjN9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLnNoYTJcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoXCJhIG5vbi1iYXNlNjQgc2hhMiBwcm9wZXJ0eSBvYmplY3QgcHJvZHVjZXMgYW4gZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTdGF0ZW1lbnQgPSB7aWQgOiBcImZkNDFjOTE4LWI4OGItNGIyMC1hMGE1LWE0YzMyMzkxYWFhMFwiICxcbiAgICAgICAgICAgICAgICBhY3RvciA6IHttYm94OlwibWFpbHRvOmFnZW50QGV4YW1wbGUuY29tXCJ9LFxuICAgICAgICAgICAgICAgIHZlcmI6IHsgXCJpZFwiOlwiaHR0cDovL2FkbG5ldC5nb3YvZXhwYXBpL3ZlcmJzL2NyZWF0ZWRcIiwgXCJkaXNwbGF5XCI6e1wiZW4tVVNcIjpcImNyZWF0ZWRcIn19LFxuICAgICAgICAgICAgICAgIG9iamVjdCA6IHtpZCA6IFwiaHR0cDovL2V4YW1wbGUuY29tL215VW5pcXVlSWRcIiwgb2JqZWN0VHlwZTpcIkFjdGl2aXR5XCJ9LFxuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiBbe3VzYWdlVHlwZTpcImh0dHA6Ly9leGFtcGxlLmNvbS91c2FnZS9pbmZvL0FcIiwgZGlzcGxheTp7fSwgY29udGVudFR5cGU6XCJ0ZXh0L3BsYWluXCIsIGxlbmd0aDoxMSwgc2hhMjpcInVzZXMgfiAtIGNoYXJhY3RlcnMgJl4lIG5vdCBpbiBiYXNlNjRcIn1dfTtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0geGFwaVZhbGlkYXRvci52YWxpZGF0ZVN0YXRlbWVudChpbnB1dFN0YXRlbWVudCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5lcnJvcnMpLnRvLmhhdmUucHJvcGVydHkoXCJsZW5ndGhcIiwgMSk7XG4gICAgICAgICAgICBleHBlY3QocmVwb3J0SGFzRXJyb3JXaXRoVHJhY2VQcmVmaXgocmVzdWx0cywgXCJzdGF0ZW1lbnQuYXR0YWNobWVudHNbMF0uc2hhMlwiLCBcIk1VU1RfVklPTEFUSU9OXCIpKS50by5iZS50cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdChcImEgbnVsbCBmaWxlVXJsIHByb3BlcnR5IHByb2R1Y2VzIGFuIGVycm9yXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0U3RhdGVtZW50ID0ge2lkIDogXCJmZDQxYzkxOC1iODhiLTRiMjAtYTBhNS1hNGMzMjM5MWFhYTBcIiAsXG4gICAgICAgICAgICAgICAgYWN0b3IgOiB7bWJveDpcIm1haWx0bzphZ2VudEBleGFtcGxlLmNvbVwifSxcbiAgICAgICAgICAgICAgICB2ZXJiOiB7IFwiaWRcIjpcImh0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS92ZXJicy9jcmVhdGVkXCIsIFwiZGlzcGxheVwiOntcImVuLVVTXCI6XCJjcmVhdGVkXCJ9fSxcbiAgICAgICAgICAgICAgICBvYmplY3QgOiB7aWQgOiBcImh0dHA6Ly9leGFtcGxlLmNvbS9teVVuaXF1ZUlkXCIsIG9iamVjdFR5cGU6XCJBY3Rpdml0eVwifSxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogW3t1c2FnZVR5cGU6XCJodHRwOi8vZXhhbXBsZS5jb20vdXNhZ2UvaW5mby9BXCIsIGRpc3BsYXk6e30sIGZpbGVVcmw6bnVsbCwgY29udGVudFR5cGU6XCJ0ZXh0L3BsYWluXCIsIGxlbmd0aDoxMSwgc2hhMjpcInVVMG51Wk5OUGdpbExsTFgybjJyK3NTRTcrTjZVNER1a0lqM3JPTHZ6ZWs9XCJ9XX07XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHhhcGlWYWxpZGF0b3IudmFsaWRhdGVTdGF0ZW1lbnQoaW5wdXRTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMuZXJyb3JzKS50by5oYXZlLnByb3BlcnR5KFwibGVuZ3RoXCIsIDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9ydEhhc0Vycm9yV2l0aFRyYWNlUHJlZml4KHJlc3VsdHMsIFwic3RhdGVtZW50LmF0dGFjaG1lbnRzWzBdLmZpbGVVcmxcIiwgXCJNVVNUX1ZJT0xBVElPTlwiKSkudG8uYmUudHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdfQ==
